<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.icon">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/small_favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="八股文也太多了吧 Java知识Java基本数据类型1byte  &#x3D;  8 bit  一个字节&#x3D;8位  byte(8位有符号) short(16) int(32) long(64) float(32) double(64) boolean(1) char(16)">
<meta property="og:type" content="article">
<meta property="og:title" content="面试知识点">
<meta property="og:url" content="http://example.com/2020/11/09/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="不斯">
<meta property="og:description" content="八股文也太多了吧 Java知识Java基本数据类型1byte  &#x3D;  8 bit  一个字节&#x3D;8位  byte(8位有符号) short(16) int(32) long(64) float(32) double(64) boolean(1) char(16)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gys9a1k5doj31ac068tad.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gys9a894u8j31ae03mmxy.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gys8rq75nxj31b60no425.jpg">
<meta property="og:image" content="http://example.com/2020/11/09/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/1.JPG">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gyamjjl39bj31a40a00x8.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gz6db23axvj30s60eigms.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gz6d8sk7fjj30uk0je770.jpg">
<meta property="og:image" content="http://example.com/2020/11/09/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/4.png">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gyotj6nq6uj313j0o4tan.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gyottyzosyj30xh0a1759.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gypouewmatj30xu0aiab6.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gyb8ncg399j31a408ktaq.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gyb8nkmxyxj30hx066q3i.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1gzmhatg675j21740leabd.jpg">
<meta property="og:image" content="http://example.com/2020/11/09/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/4.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gz8jbw57szj30h106bjrt.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1gzhqabbt5oj20qy0d2jt1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1gzhrhqc614j20u00ubwij.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1gzhsfbafegj20sy0ajta1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gz2njni4tbj311c0u0777.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gys94615ykj31aa0taq5o.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gys95810qlj31bm0jojxa.jpg">
<meta property="og:image" content="http://example.com/2020/11/09/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/2.png">
<meta property="og:image" content="http://example.com/2020/11/09/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/3.png">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gzcxgfvawtj30k2035dga.jpg">
<meta property="article:published_time" content="2020-11-09T11:15:23.000Z">
<meta property="article:modified_time" content="2022-02-22T10:47:41.722Z">
<meta property="article:author" content="Yang">
<meta property="article:tag" content="other">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gys9a1k5doj31ac068tad.jpg">

<link rel="canonical" href="http://example.com/2020/11/09/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面试知识点 | 不斯</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不斯</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/09/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yang">
      <meta itemprop="description" content="醉后不知天在水，满船星梦压星河">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不斯">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试知识点
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-09 19:15:23" itemprop="dateCreated datePublished" datetime="2020-11-09T19:15:23+08:00">2020-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-22 18:47:41" itemprop="dateModified" datetime="2022-02-22T18:47:41+08:00">2022-02-22</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>八股文也太多了吧</p>
<h2 id="Java知识"><a href="#Java知识" class="headerlink" title="Java知识"></a>Java知识</h2><h3 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h3><p>1byte  =  8 bit  一个字节=8位 </p>
<p>byte(8位有符号) short(16) int(32) long(64) float(32) double(64) boolean(1) char(16)</p>
<span id="more"></span>

<h3 id="default关键字"><a href="#default关键字" class="headerlink" title="default关键字"></a>default关键字</h3><p>default是在java8中引入的关键字，也可称为Virtual<br>extension methods——虚拟扩展方法。是指，在接口内部包含了一些默认的方法实现（也就是接口中可以包含方法体，这打破了Java之前版本对接口的语法限制），从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。</p>
<p>首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p>
<p><strong>如何使用default关键字?</strong></p>
<p><strong>1、调用父接口实现</strong></p>
<p>创建接口Interface1,并且在接口Interface1中定义默认方法helloWorld()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi i&#x27;m from Interface1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时可以编写一个类实现接口Interface1,并调用接口中定义的默认方法helloWorld()，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现接口Interface1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImplement</span> <span class="keyword">implements</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyImplement myImplement = <span class="keyword">new</span> MyImplement();</span><br><span class="line">        <span class="comment">//直接调用helloWorld()方法</span></span><br><span class="line">        myImplement.helloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，执行的结果为我们之前在接口Interface1中定义的默认方法。</p>
<h3 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h3><p><strong>Lamdba 表达式和函数式接口</strong></p>
<p><strong>接口默认方法和静态方法</strong>:默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，例子代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">DefaulableFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Interfaces now allow static methods</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Defaulable <span class="title">create</span><span class="params">( Supplier&lt; Defaulable &gt; supplier )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法引用</strong> 方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。</p>
<p><strong>重复注解</strong></p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p>
<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>
<p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p>
<p>以下是lambda表达式的重要特征:</p>
<ul>
<li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li>
<li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li>
<li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5  </span></span><br><span class="line">() -&gt; <span class="number">5</span>   </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x    </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值  </span></span><br><span class="line">(x, y) -&gt; x – y   </span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和  </span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y  </span><br><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure>

<h3 id="方法引用实例"><a href="#方法引用实例" class="headerlink" title="方法引用实例"></a>方法引用实例</h3><ul>
<li><p><strong>构造器引用：</strong>它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</p>
<p>final Car car = Car.create( Car::new ); final List&lt; Car &gt; cars = Arrays.asList( car );</p>
</li>
<li><p><strong>静态方法引用：</strong>它的语法是Class::static_method，实例如下：</p>
<p>cars.forEach( Car::collide );</p>
</li>
<li><p><strong>特定类的任意对象的方法引用：</strong>它的语法是Class::method实例如下：</p>
<p>cars.forEach( Car::repair );</p>
</li>
<li><p><strong>特定对象的方法引用：</strong>它的语法是instance::method实例如下：</p>
<p>final Car police = Car.create( Car::new ); cars.forEach( police::follow );</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      List&lt;String&gt; names = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        </span><br><span class="line">      names.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">      names.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">      names.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">      names.add(<span class="string">&quot;Baidu&quot;</span>);</span><br><span class="line">      names.add(<span class="string">&quot;Sina&quot;</span>);</span><br><span class="line">        </span><br><span class="line">      names.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Final-Static关键字"><a href="#Final-Static关键字" class="headerlink" title="Final Static关键字"></a>Final Static关键字</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p><strong>1.数据</strong></p>
<p>声明数据为常量。可以是编译时常量，也可以是运行时被初始化后不能改变的常量。</p>
<ul>
<li>对于基本数据类型，final使其数值不变</li>
<li>对于引用类型，final使其引用不变，也就不能引用其他对象，但被引用的对象本身是可以修改的</li>
</ul>
<p><strong>2.方法</strong></p>
<p>声明方法不能被子类重写</p>
<p>private方法被隐式地指定为final。</p>
<p><strong>3.类</strong></p>
<p>声明该类不允许被继承,类不可变</p>
<p>修饰的是基本类型，这个值本身不能修改</p>
<p>修饰的是引用类型，引用的指向不能修改</p>
<p>final Student student = new Student(1,”bubu”);</p>
<p>student.setAge(18)；//这个是合理的 </p>
<p><strong>final</strong>-修饰符(关键字)如果一个类被声明为 final,意味着它不能再派生出新的子类,不能作为父类被继承。因此一个类不能既被声明为 abstract的,又被声明为 final的,将变量或方法声明为 final,可以保证它们在使用中不被改变。被声明为 final f的变量必须在声明时给定初值,而在以后的引用中只能读取,不可修改。被声明为 final的方法也同样只能使用,不能重载</p>
<p><strong>finally</strong>-再异常处理时提供 finally块来执行任何清除操作,如果抛出一个异常,那么相匹配的catch子句就会执行,然后控制就会进入 finally块(如果有的话)・</p>
<p><strong>finalize</strong>-方法名。Java技术允许使用 finalize0方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作,这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的,它是在Ob ject类中定义的,因此所有的类都继承了它。</p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><strong>1.静态变量</strong></p>
<ul>
<li>静态变量：又称为类变量，也就是说这个变量是属于类的，类所有的实例都可以共享静态变量，可以直接通过类名来访问他，静态变量在内存中只存在一份</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死</li>
</ul>
<p><strong>2.静态方法</strong></p>
<p>静态方法在类加载的时候就已经存在了，它不依赖于任何实例，所以静态方法必须有实现，也就是说他不能是抽象方法</p>
<p>只能访问所属类的静态字段和静态方法，方法中不能有this和super关键字，因此这两个关键字与具体对象关联。</p>
<p><strong>3.静态语句块</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态语句块在类初始化的时候执行一次</p>
<p><strong>4.静态内部类</strong></p>
<p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类，而静态内部类不需要。</p>
<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>可以将一个类的定义放在另一个类的定义内部，就是内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">            name = <span class="string">&quot;chenssy&quot;</span>;</span><br><span class="line">            age = <span class="number">23</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要使用内部类？ 使用内部类最吸引人的一个地方就是每个内部类能够独立地继承一个接口的实现，所以无论外部类是否已经继承了某个接口的实现，对于内部类都没有影响。</p>
<ol>
<li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li>
<li>创建内部类对象的时刻并不依赖于外围类对象的创建。</li>
<li>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li>
<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**省略getter和setter方法**/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">            name = <span class="string">&quot;chenssy&quot;</span>;</span><br><span class="line">            age = <span class="number">23</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name：&quot;</span> + getName() +<span class="string">&quot;   ;age：&quot;</span> + getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        OuterClass.InnerClass innerClass = outerClass.<span class="function">new <span class="title">InnerClass</span><span class="params">()</span></span>;</span><br><span class="line">        innerClass.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------</span><br><span class="line">Output：</span><br><span class="line">name：chenssy   ;age：<span class="number">23</span></span><br></pre></td></tr></table></figure>

<p>内部类InnerClass可以对外部类OuterClass的属性进行访问，尽管他是private修饰的，这是因为我们在创建某个外部类的内部对象的时候，此时内部类对象必定会捕获一个指向那个外围类对象的引用</p>
<p> 在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。</p>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。</p>
<p>在成员内部类中要注意两点，<strong>第一：</strong>成员内部类中不能存在任何static的变量和方法；<strong>第二：</strong>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outerDisplay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;outerClass...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerDisplay</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//使用外围内的属性</span></span><br><span class="line">            str = <span class="string">&quot;chenssy...&quot;</span>;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">            <span class="comment">//使用外围内的方法</span></span><br><span class="line">            outerDisplay();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outer = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        OuterClass.InnerClass inner = outer.getInnerClass();</span><br><span class="line">        inner.innerDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------</span><br><span class="line">chenssy...</span><br><span class="line">outerClass...</span><br></pre></td></tr></table></figure>

<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在方法里</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destionation <span class="title">destionation</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestionation</span> <span class="keyword">implements</span> <span class="title">Destionation</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestionation</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">                label = whereTo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> label;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestionation(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel5 parcel5 = <span class="keyword">new</span> Parcel5();</span><br><span class="line">        Destionation d = parcel5.destionation(<span class="string">&quot;chenssy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义在作用域内</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span></span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                TrackingSlip(String s) &#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts = <span class="keyword">new</span> TrackingSlip(<span class="string">&quot;chenssy&quot;</span>);</span><br><span class="line">            String string = ts.getSlip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span></span>&#123;</span><br><span class="line">        internalTracking(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel6 parcel6 = <span class="keyword">new</span> Parcel6();</span><br><span class="line">        parcel6.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>​    我们就需要看清几个地方</p>
<p>​     <strong>1、</strong> 匿名内部类是没有访问修饰符的。</p>
<p>​     <strong>2、</strong> new 匿名内部类，这个类首先是要存在的。<strong>如果我们将那个InnerClass接口注释掉，就会出现编译出错</strong>。</p>
<p>​     <strong>3、</strong> 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，<strong>所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。</strong></p>
<p>​    <strong>4、</strong> 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> num,String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass()&#123;</span><br><span class="line">            <span class="keyword">int</span> number = num + <span class="number">3</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;        <span class="comment">/* 注意：分号不能省 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass out = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        InnerClass inner = out.getInnerClass(<span class="number">2</span>, <span class="string">&quot;chenssy&quot;</span>);</span><br><span class="line">        System.out.println(inner.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">Output:</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>在java提高篇—–关键字static中提到Static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：</p>
<p>   <strong>1、</strong> 它的创建是不需要依赖于外围类的。</p>
<p>   <strong>2、</strong> 它不能使用任何外围类的非static成员变量和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name = <span class="string">&quot;chenssy&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *静态内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass1</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 在静态内部类中可以存在静态成员 */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String _name1 = <span class="string">&quot;chenssy_static&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 静态内部类只能访问外围类的静态成员变量和方法</span></span><br><span class="line"><span class="comment">             * 不能访问外围类的非静态成员变量和方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(<span class="string">&quot;OutClass name :&quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非静态内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass2</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 非静态内部类中不能存在静态成员 */</span></span><br><span class="line">        <span class="keyword">public</span> String _name2 = <span class="string">&quot;chenssy_inner&quot;</span>;</span><br><span class="line">        <span class="comment">/* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;OuterClass name：&quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> 外围类方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> chenssy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@data</span> 2013-10-25</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/* 外围类访问静态内部类：内部类. */</span></span><br><span class="line">        System.out.println(InnerClass1._name1);</span><br><span class="line">        <span class="comment">/* 静态内部类 可以直接创建实例不需要依赖于外围类 */</span></span><br><span class="line">        <span class="keyword">new</span> InnerClass1().display();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 非静态内部的创建需要依赖于外围类 */</span></span><br><span class="line">        OuterClass.InnerClass2 inner2 = <span class="keyword">new</span> OuterClass().n<span class="function">ew <span class="title">InnerClass2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">/* 访问非静态内部类的成员需要使用非静态内部类的实例 */</span></span><br><span class="line">        System.out.println(inner2._name2);</span><br><span class="line">        inner2.display();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outer = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        outer.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------</span><br><span class="line">Output:</span><br><span class="line">chenssy_static</span><br><span class="line">OutClass name :chenssy</span><br><span class="line">chenssy_inner</span><br><span class="line">OuterClass name：chenssy</span><br></pre></td></tr></table></figure>

<h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p>分类主要分为以下两个类型</p>
<ul>
<li>collection:一个独立元素的序列，这些元素都服从一条或者多条规则，List必须按照插入的顺序保存元素，而set<strong>不能拥有重复的元素</strong>，queue按照排队规则来确定对象产生的顺序</li>
<li>Map:一组成对的键值对对象，允许使用键值对查找值</li>
</ul>
<p>Collection</p>
<ul>
<li>List<ul>
<li>LinkedList</li>
<li>ArrayList</li>
<li>Vector(Stack)</li>
</ul>
</li>
<li>Set<ul>
<li>HashSet</li>
<li>TreeSet</li>
<li>LinkedSet</li>
</ul>
</li>
</ul>
<p>Map:Hashtable,HashMap,WeakHashMap</p>
<h3 id="equals-hashcode"><a href="#equals-hashcode" class="headerlink" title="equals(),hashcode()"></a>equals(),hashcode()</h3><p><strong>1.等价关系</strong></p>
<p>两个对象具有等价关系，需要满足以下几个条件</p>
<p>自反性，对称性，传递性，一致性</p>
<p><strong>2.等价与相等</strong></p>
<ul>
<li><p>对于基本类型，==判断两个值是否相等，基本类型没有eauqls方法</p>
</li>
<li><p>对于引用类型，==判断两个变量是否引用同一个对象，而equals()判断引用的对象是否等价</p>
</li>
</ul>
<p><strong>初步认识equals与==的区别：</strong></p>
<ol>
<li> ==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同 </li>
<li> ==是指对内存地址进行比较 ， equals()是对字符串的内容进行比较</li>
<li> ==指引用是否相同， equals()指的是值是否相同</li>
<li> == 比较的是值，比较基本的数据类型是比较数值，比较引用类型比较的是引用指向的值</li>
<li> equals默认比较也是地址，自定义的类，如果需要比较的是内容，那么就要学Spring，重写equals方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">String s4 = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">String s5 = <span class="string">&quot;zszs&quot;</span>;</span><br><span class="line">String s6 = s3+s4;</span><br><span class="line">System.out.print(s6==s5);  <span class="comment">//false 变量相加会new 一个新的String所以还是false</span></span><br><span class="line"><span class="keyword">final</span> String s7 = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String s8 = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">String s9 = s3+s4;</span><br><span class="line">System.out.print(s9==s5);  <span class="comment">//true</span></span><br><span class="line"><span class="keyword">final</span> String s10 = s3+s4</span><br><span class="line">System.out.print(s10==s5);  <span class="comment">//false </span></span><br></pre></td></tr></table></figure>



<p>hashcode()</p>
<p>已知散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。<br>那么所以hashcode()作用就是提高效率。<br>当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）<br>也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。</p>
<h3 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h3><p>区别：</p>
<ul>
<li>抽象类的修饰符是abstract ，接口的修饰符是interface 。另外对于实现的子类来说，有extends 和 implements 之分</li>
<li>接口中的变量是public final 类型的共有常量，不能修改。抽象类中的变量可以进行修改赋值操作；。比如i,j</li>
<li>接口中的方法必须是抽象方法，而抽象类中的方法可以不是抽象方法，我们可以在非抽象方法中进行一些初始化操作，那么子类将会持有该属性，比如例子中的isLoading 字段</li>
<li>对于非抽象子类来说，必须实现或继承 接口或抽象类中的所有抽象方法 比如MyClass和MyClass2</li>
<li>对于抽象子类来说，可以不用实现或继承这些方法。比如MyClass3和MyClass4</li>
</ul>
<p>相同点：</p>
<ul>
<li>接口中的方法一定是抽象方法，抽象类的方法可以抽象方法,并且抽象方法一定是没有方法体的</li>
<li>抽象类和接口都不能被定义为私有的或final的，否则不能被继承或实现。</li>
</ul>
<p>JDK1.8之前：</p>
<ul>
<li>语法</li>
</ul>
<ol>
<li>抽象类：方法可以有抽象的，也可以有非抽象的，有构造器</li>
<li>接口：方法都是抽象的，属性都是常量，默认有public static final修饰</li>
</ol>
<ul>
<li>设计：</li>
</ul>
<ol>
<li>抽象类：用一类食物的抽取，比如针对Dao层操作的封装，BaseDao,BaseServiceImpl</li>
<li>接口：通常更像是一种标准的制定，定制系统间对接的标准</li>
<li>例子：单体项目，分层开发，interface作为各层之间的纽带，在controller中注入IUserService，在Service中注入IUserDao</li>
<li>分布式项目，面向服务的开发，抽取服务service,在这个时候就会产生服务的提供者和服务的消费者两个角色，这两个角色之间的纽带依然是接口</li>
</ol>
<p>JDK1.8之后：</p>
<ul>
<li>接口里面可以有实现的方法，注意要在方法的声明上加上default或者static</li>
</ul>
<h3 id="数组在内存中如何分配"><a href="#数组在内存中如何分配" class="headerlink" title="数组在内存中如何分配"></a>数组在内存中如何分配</h3><p>对于Java数组的初始化，有以下两种方式</p>
<ul>
<li>静态初始化：初始化时由程序员显示指定每个数组元素的初始值，由系统决定数组长度</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gys9a1k5doj31ac068tad.jpg" alt="image-20220127152045366"></p>
<ul>
<li>动态初始化：初始化时由程序员指定数组的长度，由系统为数据每个元素分配初始值</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gys9a894u8j31ae03mmxy.jpg" alt="image-20220127152057128"></p>
<p>静态初始化方式，虽然没有指定数组长度，但是系统已经移动帮我们分配了，而动态初始化方式，程序员虽然没有显示的指定初始化值，但是因为Java数组是引用类型的变量，所以系统也为每个元素分配了初始化值null，当然不同类型的初始化值也是不一样的，比如int应该是0.</p>
<h3 id="Java数据结构"><a href="#Java数据结构" class="headerlink" title="Java数据结构"></a>Java数据结构</h3><ul>
<li>枚举（Enumeration）</li>
<li>位集合（BitSet）</li>
<li>向量（Vector）</li>
<li>栈（Stack）</li>
<li>字典（Dictionary）</li>
<li>哈希表（Hashtable）</li>
<li>属性（Properties）</li>
<li>树</li>
</ul>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p><strong>二叉树</strong> 每个结点都最多只有两个子结点的树</p>
<p><strong>完全二叉树</strong> 高度为h的二叉树，其1-h-1层为满节点，叶子节点层的节点从左到右依次排序</p>
<p><strong>满二叉树</strong> 除最后一层外，每个节点都有左右子节点的二叉树</p>
<p><strong>平衡二叉树</strong> 任意节点的左右字数的高度差值不超过1，且左右子树均为平衡二叉树</p>
<h3 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String,StringBuffer,StringBuilder"></a>String,StringBuffer,StringBuilder</h3><p><strong>String跟其他两个类的区别</strong></p>
<p>String 是final类型，每次声明的都是不可变对象</p>
<p>所以每次操作都会产生新的String对象，然后将指针指向新的String对象</p>
<p>StringBuffer,StringBuilder都是在原有对象上进行操作</p>
<p>所以如果需要经常改变字符串内容则建议采用这两者</p>
<p>二者的区别是前者是线程安全的，后者是线程不安全的</p>
<p>线程不安全的性能更高，所以在开发中优先采用StringBuilder</p>
<p>线程安全：多线程环境下，对这个对象的访问不需要加入额外的同步控制，操作的数据结果依然是正确的，例如synchronized</p>
<p>什么时候会考虑线程安全问题呢？多个线程访问同一个资源的情况下才会考虑，单线程则不考虑。</p>
<p>StringBuilder:开发中来解决字符拼接的问题：StringBuilder.append(“…”);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//每个线程访问一个StringBuilder 可以不考虑线程安全问题</span></span><br></pre></td></tr></table></figure>

<h3 id="String创建对象"><a href="#String创建对象" class="headerlink" title="String创建对象"></a>String创建对象</h3><p>字符串创建对象方式有两种：直接赋值，new构造方法<br>比如 a,String name=”tom”；<br>b,String address=new String(“很恩贡特大学“）；<br>两个的区别<br>a,直接赋值；对象存入常量池中；当JVM创建字符串对象前会先去常量池中找有没有一个字符串内容与当前字符串相同，有：将已有的地址赋值给变量；无：创建新的对象。在字符串的比较是地址数的比较。</p>
<p>在String创建的类中是先把存入的字符串放到堆中变量池中，在栈中开辟个空间name来存入地址调用的。</p>
<p>new:直接存入<strong>堆内存</strong>，每new一次就会创建一个新的对象，在存入相同的内容时也不会设置两个引用变量指向同一块地方。<br>当我们在创建对象时就会在堆中自动创建个空间给new的对象了。</p>
<p>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;计算机&quot;</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">&quot;计算机&quot;</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的 String 对象</span></span><br><span class="line">String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str4 = str1 + str2; <span class="comment">//在堆上创建的新的对象      </span></span><br><span class="line">String str5 = <span class="string">&quot;string&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<p><strong>String a=”abc”与String b=new String(“abc”)一样吗</strong></p>
<p>从字节码中可以看到，String a=“abc”只创建了一个对象（就是”abc”，在运行时常量池）。然而String a=new String(“abc”)会<strong>创建额外的对象</strong>，看见new没有（意思是在堆上有创建了一个对象）。</p>
<p>a,b两个对象都是用ldc指令将常量”abc”（本身就是一个String类型）加载进操作数栈的，所以a= =b是true。然而String d=new String(“abc”)会在堆中新new一个String对象，所以d == b为false。</p>
<p>通过上面的解释，现在我们就知道了String a=“abc”会创建一个对象（在运行时常量池），而String a=new String(“abc”)会创建两个对象（一个在运行时常量池的”abc”，一个在堆里面）。需要注意的是这是在String a=”abc”与String a=new String(“abc”)不同时出现的情况下。</p>
<p>通常创建String对象时，推荐使用双引号这种方式。因为new的方式会额外创建一个对象。</p>
<h3 id="方法重载与重写"><a href="#方法重载与重写" class="headerlink" title="方法重载与重写"></a>方法重载与重写</h3><ul>
<li>重载：发生在一个类里面，方法名相同但是参数列表不同，跟返回类型没有关系 同一个方法 根据传入的参数不同，做出不同的处理</li>
<li>重写：发生在父类子类之间，方法名相同，参数列表相同</li>
</ul>
<h3 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h3><p>二者都继承自Collection接口</p>
<p>List 有序可重复 ArrayList LinkedList</p>
<p>Set 无序  不可重复 HashSet TreeSet，元素不可重复，重复元素会被覆盖掉，元素虽然无放入顺序，但是元素在set中的位置是由该元素的hashcode决定的，其位置其实是固定的，加上set的Object方法必须定义equals()方法。</p>
<h3 id="Collections-Collection-区别"><a href="#Collections-Collection-区别" class="headerlink" title="Collections Collection 区别"></a>Collections Collection 区别</h3><p>java工具类命名以s结尾 前者是工具类 后者是顶层的接口</p>
<p>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法</p>
<p>Collections 是针对集合类的一个帮助类，他提供了一系列静态方法实现对各种集合的搜索、排序、线程安全等操作。然后还有混排，反转，替换所有元素，拷贝，返回Collections中最小元素，最大元素，返回指定源列表中最后一次出现指定目标列表的起始位置，返回指定源列表中第一次出现指定目标列表的起始位置，根据指定的距离循环移动指定列表中的元素。</p>
<h3 id="Arrays-sort-和-Collections-sort实现原理和区别"><a href="#Arrays-sort-和-Collections-sort实现原理和区别" class="headerlink" title="Arrays.sort 和 Collections sort实现原理和区别"></a>Arrays.sort 和 Collections sort实现原理和区别</h3><p>事实上，Collections.sort方法底层就是调用array.sort方法</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gys8rq75nxj31b60no425.jpg" alt="image-20220127150309052"></p>
<p>java Arrays.sort()使用了两种排序方法，快速排序和合并排序</p>
<p>快速排序主要是对那些基本类型数据（int,short,long等）排序， 而合并排序用于对对象类型进行排序</p>
<p>使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于对象类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一直；另外一个原因是由于合并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，比较一般比移动耗时。</p>
<h3 id="ArrayList-LinkList"><a href="#ArrayList-LinkList" class="headerlink" title="ArrayList LinkList"></a>ArrayList LinkList</h3><p>对于处理一列数据项，Java 提供了两个类ArrayList 和LinkedList ，ArrayList 的内部实现是基于内部数组Object[] ，从概念上讲，它更像数组，但LinkedList 的内部实现是基于一组连接的记录，所以，它更像一个链表结构，它们在性能上有很大的差别。</p>
<p>  在ArrayList 的前面或中间插入数据时，必须将其后的所有数据相应的后移，这样必然要花费较多时间，所以，当你的操作是在一列数据的后面添加数据而不是在前面或中间，并且需要随机地访问其中的元素时，使用ArrayList 会提供比较好的性能；而访问链表中的某个元素时，就必须从链表的一端开始沿着连接方向一个一个元素地去查找，直到找到所需的元素为止，所以，当你的操作是在一列数据的前面或中间添加或删除数据，并且按照顺序访问其中的元素时，就应该使用LinkedList 了。</p>
<p>如果在编程中，两种情形交替出现，这时，可以考虑使用List 这样的通用接口，而不用关心具体的实现，在具体的情形下，它的性能由具体的实现来保证。</p>
<p><strong>案例：LinkedList 实现栈</strong></p>
<p>  ArrayList 的查询效率比较高，增删动作的效率比较差，适用于查询比较频繁，增删动作较少的元素管理的集合。LinkedList 的查询效率低，但是增删效率很高。适用于增删动作的比较频繁，查询次数较少的元素管理集合。</p>
<p>ArrayList ，LinkedList 都是线程不安全的。</p>
<p>实现栈 1 ）数组（ArrayList ，增删效率比较低，不适合）</p>
<p>​    2 ）LinkedList （实现堆栈的好方法）</p>
<p>​     3 ）java.util.Stack 类，Stack 是Vector 的子类，Vector 类是一个线程安全的（是一个重量级的类），并继承了Vector 的方法，Verctor 类和ArrayList 的功能近乎相同。（不推荐使用Stack 类来实现堆栈）。</p>
<p><strong>底层数据结构的差异</strong></p>
<p>ArrayList  数组 是连续一块内存空间</p>
<p>LinkedList 双向链表 不是连续的内存空间</p>
<p><strong>一个常规的结论</strong></p>
<p>ArrayList查找块，因为是连续的内存空间，方便寻址，但删除插入慢，因为需要发生数据的迁移</p>
<p>LinkedList 查找慢，因为需要通过指针一个个寻找，但删除，插入快，因为只需要该表前后节点的指针指向即可,LinkedList有头尾指针，尾部添加新元素不需要遍历~</p>
<p><img src="/2020/11/09/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/1.JPG"></p>
<p>需要存储1000个对象信息，二者那个更省内存？</p>
<p>初始化好空间，就是1000避免后期扩容</p>
<p>ArrayList就是数组，而后者还要存储指针，前指针和后指针，所以前者更省空间</p>
<p><strong>ArrayList细节分析</strong></p>
<ol>
<li><p>添加</p>
<p>添加到数组末尾，正常不需要做特别的处理，除非有数组空间不够了，需要扩容。数组的初始化容量是多大呢？10，当你知道需要存储多少数据时，建议在创建的时候直接设置初始值。</p>
<p>扩容？如何扩容呢 创建一个新数组，新数组的长度是原数组的1.5倍，通过位运算的方式创建，再将原数组的数据迁移到新数组中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> old = elementData.length;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">new</span> = old + (old&gt;&gt;<span class="number">1</span>);</span><br><span class="line">elementData = Arrays.copyOf(elementData,<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<p>删除末尾，并不需要迁移，删除其他的位置则需要搬迁</p>
</li>
<li><p>修改</p>
<p>修改之前需要定位</p>
<p>定位-查找-ArrayList</p>
</li>
</ol>
<h3 id="JAVA反射"><a href="#JAVA反射" class="headerlink" title="JAVA反射"></a>JAVA反射</h3><p>反射是指程序在运行状态中</p>
<ol>
<li>可以对任意一个类，都能够获取到这个类的所有属性和方法</li>
<li>对于任意一个对象，都可以调用它的任意一个方法和属性</li>
</ol>
<p>反射是一种能力</p>
<p>一种在程序运行时，动态获取当前类对象的所有属性的方法的能力，可以动态执行方法，给属性赋值等操作的能力</p>
<p>Class代表的就是所有的字节码对象的抽象 ，类</p>
<p>反射，让我们的java程序具备动态性</p>
<p>这种动态获取类信息以及调用对象方法的功能称为反射</p>
<p>在java中，class类就是关键API</p>
<p>在我们的许多框架的背后实现上，都采用了反射的机制来实现动态效果</p>
<p><strong>Java 获取反射是三种方法</strong></p>
<ul>
<li>通过new对象实现反射机制</li>
<li>通过路径实现反射机制</li>
<li>通过类名实现反射机制</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"> String name;</span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">boolean</span> sex;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">float</span> score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Get</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取反射机制三种方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"> <span class="comment">//方式一(通过建立对象)</span></span><br><span class="line"> Student stu = <span class="keyword">new</span> Student();</span><br><span class="line"> Class classobj1 = stu.getClass();</span><br><span class="line"> System.out.println(classobj1.getName());</span><br><span class="line"> <span class="comment">//方式二（所在通过路径-相对路径）</span></span><br><span class="line"> Class classobj2 = Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line"> System.out.println(classobj2.getName());</span><br><span class="line"> <span class="comment">//方式三（通过类名）</span></span><br><span class="line"> Class classobj3 = Student.class;</span><br><span class="line"> System.out.println(classobj3.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Object类下方法"><a href="#Object类下方法" class="headerlink" title="Object类下方法"></a>Object类下方法</h3><p><strong>1.Object()</strong></p>
<p>这个没什么可说的，Object类的构造方法。(非重点)</p>
<p><strong>2.registerNatives()</strong></p>
<p>为了使JVM发现本机功能，他们被一定的方式命名。例如，对于java.lang.Object.registerNatives，对应的C函数命名为Java_java_lang_Object_registerNatives。</p>
<p>通过使用registerNatives（或者更确切地说，JNI函数RegisterNatives），可以命名任何你想要你的C函数。(非重点)</p>
<p><strong>3.clone()</strong></p>
<p>clone()函数的用途是用来另存一个当前存在的对象。只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。（注意：回答这里时可能会引出设计模式的提问）</p>
<p><strong>4.getClass()</strong></p>
<p>final方法，用于获得运行时的类型。该方法返回的是此Object对象的类对象/运行时类对象Class。效果与Object.class相同。（注意：回答这里时可能会引出类加载，反射等知识点的提问）</p>
<p><strong>5.equals()</strong></p>
<p>equals用来比较两个对象的内容是否相等。默认情况下(继承自Object类)，equals和==是一样的，除非被覆写(override)了。</p>
<p><strong>6.hashCode()</strong></p>
<p>该方法用来返回其所在对象的物理地址（哈希码值），常会和equals方法同时重写，确保相等的两个对象拥有相等的hashCode。（同样，可能引出hashmap实现原理的提问）</p>
<p><strong>7.toString()</strong></p>
<p>toString()方法返回该对象的字符串表示，这个方法没什么可说的。</p>
<p><strong>8.wait()</strong></p>
<p>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。（引出线程通信及“wait和sleep的区别”的提问）</p>
<p><strong>9.wait(long timeout)</strong></p>
<p>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。（引出线程通信及“wait和sleep的区别”的提问）</p>
<p><strong>10.wait(long timeout, int nanos)</strong></p>
<p>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。（引出线程通信及“wait和sleep的区别”的提问）</p>
<p><strong>11.notify()</strong></p>
<p>唤醒在此对象监视器上等待的单个线程。（引出线程通信的提问）</p>
<p><strong>12. notifyAll()</strong></p>
<p>唤醒在此对象监视器上等待的所有线程。（引出线程通信的提问）</p>
<p><strong>13.finalize()</strong></p>
<p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。（非重点，但小心引出垃圾回收的提问）</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>垃圾收集GC（Garbage Collection）是Java语言的核心技术之一， 在Java中，程序员不需要去关心内存动态分配和垃圾回收的问题，这一切都交给了JVM来处理。针对GC我们这篇文章提出以下几个问题，GC中判定为垃圾的标准，标记垃圾的算法以及回收垃圾的算法。</p>
<p><strong>什么样的对象才是垃圾？</strong></p>
<p>这个问题其实很简单，对于Java对象来讲，如果说这个对象没有被其他对象所引用该对象就是无用的，此对象就被称为垃圾，其占用的内存也就要被销毁。那么自然而然的就引出了我们的第二个问题，判断对象为垃圾的算法都有哪些？</p>
<p><strong>什么时候触发GC</strong></p>
<p>(1)程序调用System.gc时可以触发，也不是立即触发，只是发了个通知要触发，时机由jvm自己把握</p>
<p>(2)系统自身来决定GC触发的时机(根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程)</p>
<p>GC又分为 minor GC 和 Full GC (也称为 Major GC )</p>
<p><strong>Minor GC触发条件</strong>：当Eden区满时，触发Minor GC。</p>
<p><strong>Full GC触发条件</strong>：</p>
<ol>
<li><p>调用System.gc时，系统建议执行Full GC，但是不必然执行</p>
</li>
<li><p>老年代空间不足</p>
</li>
<li><p>方法区空间不足</p>
</li>
<li><p>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p>
</li>
<li><p>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
</li>
</ol>
<p>Minor GC：</p>
<p>新生代GC，指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生熄灭的特点，所以Minor GC十分频繁，回收速度也较快。</p>
<p>Major GC：</p>
<p>老年代GC，指发生在老年代的垃圾收集动作</p>
<p><strong>标记垃圾的算法</strong></p>
<p>Java中标记垃圾的算法主要有两种， 引用计数法和可达性分析算法。我们首先来介绍引用计数法。</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>引用计数法就是给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的，可以当做垃圾收集。这种方法实现起来很简单而且优缺点都很明显。</p>
<ul>
<li><strong>优点 执行效率高，程序执行受影响较小</strong></li>
<li><strong>缺点 无法检测出循环引用的情况，导致内存泄露</strong></li>
</ul>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p>
<p><strong>那么什么对象可以作为GCRoot？</strong></p>
<ul>
<li>虚拟机栈中的引用对象</li>
<li>方法区中的常量引用对象</li>
<li>方法区中的类静态属性引用对象</li>
<li>本地方法栈中的引用对象</li>
<li>活跃线程中的引用对象</li>
</ul>
<p><strong>那么不可达的对象是否是必死之局呢？答案也是否定的</strong></p>
<p>在可达性分析法中不可达的对象，它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<h4 id="如何将垃圾回收？"><a href="#如何将垃圾回收？" class="headerlink" title="如何将垃圾回收？"></a>如何将垃圾回收？</h4><p>在Java中存在着四种垃圾回收算法，标记清除算法、复制算法、标记整理算法以及分代回收算法。</p>
<p><strong>标记清除算法</strong></p>
<p>该算法分为“标记”和“清除”两个阶段：标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题：</p>
<ul>
<li><strong>效率问题</strong></li>
<li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li>
</ul>
<p><strong>复制算法</strong></p>
<p>为了解决效率问题，我们开发出了复制算法。它可以将内存分为大小相同的两块，每次使用其中的一块。当第一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p>简单来说就是该对象分为对象面以及空闲面，对象在对象面上创建，对象面上存活的对象会被复制到空闲面，接下来就可以清除对象面的内存。</p>
<p>这种算法的优缺点也比较明显</p>
<ul>
<li><strong>优点：解决碎片化问题，顺序分配内存简单高效</strong></li>
<li><strong>缺点：只适用于存活率低的场景，如果极端情况下如果对象面上的对象全部存活，就要浪费一半的存储空间。</strong></li>
</ul>
<p><strong>标记整理算法</strong></p>
<p>为了解决复制算法的缺陷，充分利用内存空间，提出了标记整理算法。该算法标记阶段和标记清除一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。</p>
<p><strong>分代收集算法</strong></p>
<p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法就是根据具体的情况选择具体的垃圾回收算法。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><strong>注解的定义</strong></p>
<p><strong><em>Annontation</em></strong>是Java5开始引入的新特征，中文名称叫<strong>注解</strong>。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。<br>　　Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中</p>
<p><strong>注解的作用</strong></p>
<ul>
<li>生成文档,@param,@returb</li>
<li>跟踪代码依赖性，实现替代配置文件功能</li>
<li>在编译的时候进行格式检查，如@override放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检测出</li>
</ul>
<p><strong>元注解</strong></p>
<p>有四种专门的元注解，专门用来注解其他的注解</p>
<p>  @Documented – 注解是否将包含在JavaDoc中<br>  @Retention – 什么时候使用该注解<br>  @Target – 注解用于什么地方<br>  @Inherited – 是否允许子类继承该注解</p>
<p>1.）@Retention – 定义该注解的生命周期<br> ●  RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。<br> ●  RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式<br> ●  RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</p>
<p> 2.）Target – 表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括<br> ● ElementType.CONSTRUCTOR: 用于描述构造器<br> ● ElementType.FIELD: 成员变量、对象、属性（包括enum实例）<br> ● ElementType.LOCAL_VARIABLE: 用于描述局部变量<br> ● ElementType.METHOD: 用于描述方法<br> ● ElementType.PACKAGE: 用于描述包<br> ● ElementType.PARAMETER: 用于描述参数<br> ● ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明</p>
<p> 3.)@Documented – 一个简单的Annotations 标记注解，表示是否将注解信息添加在java 文档中。</p>
<p> 4.)@Inherited – 定义该注释和子类的关系<br>   @Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型，即参数化类型，顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数类型，然后在使用或者调用时传入具体的类型</p>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</p>
<p>也就是说，在泛型的使用过程中，操作的数据类型被指定为一个参数 ，这种参数类型可以用在类，接口和方法中</p>
<p>java中的泛型，只在编译阶段有效。在编译的过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法，也就是说泛型信息不会进入到运行时阶段</p>
<p><strong>泛型的好处</strong></p>
<p>在集合中存储对象并在使用前进行类型的转换想当不方便，泛型防止了 那种情况的发生，它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中</p>
<p><strong>java泛型如何工作的</strong></p>
<p>泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息，例如List<String>在运行时仅用一个List来表示。</String></p>
<p><strong>限定通配符和非限定通配符</strong></p>
<p>限定通配符对类型进行了限制，有两种限定通配符，一种是&lt;? extends T&gt;,它通过确保类型必须是T的子类来设定类型的上界，另一种是&lt;? super T&gt;它通过确保类型必须是T的父类来设定类型的下界，泛型类型必须使用限定内的类型来进行初始化，否则会导致编译错误。另一方面&lt; ? &gt;表示了非限定通配符。</p>
<p><strong>List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?</strong></p>
<p>这两个List的声明都是限定通配符的例子，List&lt;? extends T&gt;可以接受任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构成的List。例如List&lt;? extends Number&gt;可以接受List<Integer>或List<Float>。</Float></Integer></p>
<p><strong>泛型类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>泛型接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="OOM异常"><a href="#OOM异常" class="headerlink" title="OOM异常"></a>OOM异常</h3><p>OOM异常就是out of Memory Error，内存溢出异常，其中也分为多种</p>
<ul>
<li>java.lang.StackOverflowError</li>
<li>java.lang.OutOfMemoryError: Java heap space</li>
<li>java.lang.OutOfMemoryError：GC overhead limit exceeded</li>
<li>java.lang.OutOfMemoryError：Direct buffer memory</li>
<li>java.lang.OutOfMemoryError：unable to create new native thread</li>
<li>java.lang.OutOfMemoryError：MetaSpace</li>
</ul>
<p><strong>StackOverflowErroe</strong></p>
<p>报这个错误一般是由于方法深层次的调用，默认的线程栈空间大小一般具体的硬件平台有关，栈内存为线程私有的空间，每个线程都有自己私有的栈内存，栈空间内存设置过大，创建线程数量较多的时候会出现栈内存溢出。</p>
<p><strong>Heap space</strong></p>
<p>Heap size 设置 JVM堆的设置是指：java程序执行过程中JVM能够调配使用的内存空间的设置。JVM在启动的时候会自己主动设置Heap size的值，其<strong>初始空间(即-Xms)是物理内存的1/64</strong>，<strong>最大空间(-Xmx)是物理内存的1/4</strong>。能够利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。</p>
<p>Demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMHeapSpaceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改堆内存的初始容量和最大容量为5MB</p>
<p>运行程序，查看结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at jvm.OOMHeapSpaceDemo.main(OOMHeapSpaceDemo.java:<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p><strong>GC overhead limit exceeded</strong></p>
<p>GC回收时间过长时会抛出outOfMemroyError，过长的定义是：超过98%的时间用来做GC并且回收不到2%的堆内存。<br> 连续多次GC都只回收了不到2%的极端情况下会抛出。假如不抛出GC overhead limit 错误会发生什么信况呢?<br> 那就是GC清理的这么点内存很快会再次填满，迫使GC 再次执行。这样就形成恶性循环,<br>CPU使用率一直是100%， 两GC 却没有任何效果</p>
<p><strong>Direct buffer memory</strong></p>
<p>写NIO程序经常使用到ByteBuffer来读取或者写入数据，这是一种基于通道与缓冲区的I/O方式。它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中提高性能，因为避免了java堆和Native堆中来回复制数据。</p>
<ul>
<li>ByteBuffer.allocate(capability) ：这种方式是分配JVM堆内存，属于GC管辖范围之内。由于需要拷贝，所以速度相对较慢；</li>
<li>ByteBuffer.allocateDirect(capability)：这种方式是直接分配OS本地内存，不属于GC管辖范围之内，由于不需要内存拷贝所以速度相对较快。</li>
</ul>
<p>但是如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC,DirectByteBuffer对象就不会被回收。这时候堆内存充足，但是本地内存已经用光了，再次尝试分配的时候就会出现OutOfMemoryError，那么程序就直接崩溃了</p>
<p><strong>unable to create new native thread</strong></p>
<p>准确的说，这一个异常是和程序运行的平台相关的。导致的原因：</p>
<ul>
<li>创建了太多的线程，一个应用创建多个线程，超过系统承载极限；</li>
<li>服务器不允许应用程序创建这么多的线程，Linux系统默认的允许单个进程可以创建的线程数量是1024个，当创建多 线程数量多于这个数字的时候就会抛出此异常</li>
</ul>
<p>如何解决呢？</p>
<ul>
<li>想办法减少应用程序创建的线程的数量，分析应用是否真的需要创建这么多的线程。如果不是，改变代码将线程数量降到最低；</li>
<li>对于有的应用，确实需要创建很多的线程，远超过Linux限制的1024个 限制，那么可以通过修改Linux服务器的配置，扩大Linux的默认限制。</li>
</ul>
<p><strong>MetaSpace</strong></p>
<p>元空间的本质和永久代类似，都是对JVM规范中的方法区的实现。不过元空间与永久代之间最大的区别在于：元空间不在虚拟机中，而是使用的本地内存。因此，默认情况下，元空间的大小仅仅受到本地内存的限制 。</p>
<p>元空间存放了以下的内容：</p>
<ul>
<li>虚拟机加载的类信息；</li>
<li>常量池；</li>
<li>静态变量；</li>
<li>即时编译后的代码</li>
</ul>
<p>模拟MetaSpace空间溢出，我们不断生成类往元空间里灌，类占据的空间总是会超过MetaSpace指定的空间大小的</p>
<p>查看元空间的大小：<code>java -XX:+PrintFlagsInitial</code></p>
<h3 id="内存溢出-内存泄露"><a href="#内存溢出-内存泄露" class="headerlink" title="内存溢出/内存泄露"></a>内存溢出/内存泄露</h3><p>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p>
<p>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p>
<p>memory leak会最终会导致out of memory！</p>
<p>以发生的方式分类来看，内存泄露可以分为4类：</p>
<ul>
<li>常发性内存泄露。发生内存泄露的代码会被多次执行到，每次被执行的时候导致一块内存泄露</li>
<li>偶发性内存泄露。</li>
<li> 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 </li>
<li>隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏</li>
</ul>
<h2 id="Hash相关知识"><a href="#Hash相关知识" class="headerlink" title="Hash相关知识"></a>Hash相关知识</h2><h3 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h3><p>1.开放地址方法</p>
<p>　　（1）线性探测</p>
<p>　　　按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上往后加一个单位，直至不发生哈希冲突。　</p>
<p>　　（2）再平方探测</p>
<p>　　　按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上先加1的平方个单位，若仍然存在则减1的平方个单位。随之是2的平方，3的平方等等。直至不发生哈希冲突。</p>
<p>　　（3）伪随机探测</p>
<p>　　　按顺序决定值时，如果某数据已经存在，通过随机函数随机生成一个数，在原来值的基础上加上随机数，直至不发生哈希冲突。</p>
<p>2.链式地址法（HashMap的哈希冲突解决方法）</p>
<p>　　对于相同的值，使用链表进行连接。使用数组存储每一个链表。</p>
<p>　　优点：</p>
<p>　　（1）拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</p>
<p>　　（2）由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</p>
<p>　　（3）开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</p>
<p>　　（4）在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。<br>　　缺点：</p>
<p>　　指针占用较大空间时，会造成空间浪费，若空间用于增大散列表规模进而提高开放地址法的效率。</p>
<p>3.建立公共溢出区</p>
<p>　　建立公共溢出区存储所有哈希冲突的数据。</p>
<p>4.再哈希法</p>
<p>　　对于冲突的哈希值再次进行哈希处理，直至没有哈希冲突。</p>
<h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>上面通过数据库的例子介绍了哈希算法，然后也分析了它的劣势，当机器数量发生变动的时候，几乎所有的数据都会移动 (不移动的应该是运气比较好吧前后取模都是同一个值)，这个代价很大。此时的问题从水平如何拆分变成了，当增加或者删除节点时，对于大多数记录，保证原来分配到的某个节点，现在仍然应该分配到那个节点，将数据迁移量的降到最低，这就是一致性哈希要做的事情。在这里我们不指定是数据库还是什么，反正都是分布式存储节点。</p>
<p>一致性 Hash 算法也是使用取模的思想，只是，刚才描述的取模法是对节点数量进行取模，而一致性 Hash 算法是对 <code>2^32</code> 取模，什么意思呢？简单来说，一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数 H 的值空间为 0-2^32-1（即哈希值是一个 32 位无符号整形），整个哈希环如下，从 0 ~ 2^32-1 代表的分别是一个个的节点，这个环也叫哈希环。</p>
<p>然后我们将我们的节点进行一次哈希，按照一定的规则，比如按照 ip 地址的哈希值，让节点落在哈希环上。</p>
<p>然后就是需要通过数据 key 找到对应的服务器然后存储了，我们约定，通过数据 key 的哈希值落在哈希环上的节点，如果命中了机器节点就落在这个机器上，否则落在顺时针直到碰到第一个机器。</p>
<h3 id="HashMap基本"><a href="#HashMap基本" class="headerlink" title="HashMap基本"></a>HashMap基本</h3><p>HashMap是基于hashing的原理，我们使用put(key,value)存储对象到HashMap中，使用get(key)从中获取键值对。</p>
<p>HashMap是基于hashing的原理，我们使用**put(key, value)**存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出， HashMap是在bucket中储存键对象和值对象，作为Map.Entry</p>
<p>当两个对象的hashcode相同的时候会发生什么呢？</p>
<p>hashcode相同，而HashMap使用链表存储对象</p>
<p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。</p>
<p><strong>在获取HashMap的元素时，基本分两步 get(key)：</strong></p>
<ol>
<li>首先根据hashCode()做hash，然后确定bucket的index；</li>
<li>如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。</li>
</ol>
<p>在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。</p>
<p>因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题，在<a target="_blank" rel="noopener" href="http://www.importnew.com/14417.html">Java 8：HashMap的性能提升</a>一文中有性能测试的结果。</p>
<p><strong>为什么hashmap的长度是2的整数次幂</strong></p>
<p>答案是为了加快哈希计算以及减少哈希冲突</p>
<p>HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；<br>这个算法实际就是取模，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>%length，计算机中直接求余效率不如位移运算，源码中做了优化hash&amp;(length-1)，<br>hash%length==hash&amp;(length-1)的前提是length是2的n次方；</p>
<p>为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1 实际就是n个1；<br>例如长度为9时候，3&amp;(9-1)=0 2&amp;(9-1)=0 ，都在0上，碰撞了；<br>例如长度为8时候，3&amp;(8-1)=3 2&amp;(8-1)=2 ，不同位置上，不碰撞</p>
<p><strong>hashmap底层</strong></p>
<p>在jdk1.8之前，底层是数组和链表结合在一起也就是使用链表散列，hashmap通过key的hashcode值经过扰动函数处理得到的hash值，然后通过（n-1）&amp; hash 判断当前元素存放的位置，n为数组的长度，如果当前位置元素存在的话，就判断当前元素与要存入的元素的hash值以及key值是否相同，如果相同的话直接覆盖，不相同的话则通过拉链法解决冲突。</p>
<p>所谓扰动函数就是hashmap的hash方法，使用hash方法是为了防止一些实现比较差的hashCode()方法。</p>
<p>拉链法就是 将链表与数组结合，也是说创建一个链表数组，数组中每一格就是一个链表，若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><strong>Jdk1.8之后，当链表长度大于阈值默认为8，将链表转换为红黑树，以减少搜索时间，但是再转换前会进行一次判断，如果当前数组的长度小于64的话，那么会选择先进行数组扩容而不是转换成红黑树</strong>。</p>
<p>在理想情况下，链表长度符合<code>泊松分布</code>，各个长度的命中概率依次递减，当长度为 8 的时候，是最理想的值。</p>
<p>事实上，链表长度超过 8 就转为红黑树的设计，更多的是为了防止用户自己实现了不好的哈希算法时导致链表过长，从而导致查询效率低，而此时转为红黑树更多的是一种保底策略，用来保证极端情况下查询的效率。</p>
<p>通常如果 hash 算法正常的话，那么链表的长度也不会很长，那么红黑树也不会带来明显的查询时间上的优势，反而会增加空间负担。所以通常情况下，并没有必要转为红黑树，所以就选择了概率非常小，小于千万分之一概率，也就是长度为 8 的概率，把长度 8 作为转化的默认阈值。</p>
<p><strong>我们可以简单列下HashMap在1.7和1.8之间的变化：</strong></p>
<ul>
<li>1.7中采用数组+链表，1.8采用的是数组+链表/红黑树，即在1.7中链表长度超过一定长度后就改成红黑树存储。</li>
<li>1.7扩容时需要重新计算哈希值和索引位置，1.8并不重新计算哈希值，巧妙地采用和扩容后容量进行&amp;操作来计算新的索引位置。</li>
<li>1.7是采用表头插入法插入链表，1.8采用的是尾部插入法。</li>
<li>在1.7中采用表头插入法，在扩容时会改变链表中元素原本的顺序，以至于在并发场</li>
</ul>
<p><strong>为什么String, Interger这样的wrapper类适合作为键？</strong> String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。</p>
<p><strong>我们可以使用自定义的对象作为键吗？</strong> 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。</p>
<p><strong>我们可以使用CocurrentHashMap来代替Hashtable吗</strong>？这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。看看<a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2011/04/difference-between-concurrenthashmap.html">这篇博客</a>查看Hashtable和ConcurrentHashMap的区别。</p>
<h3 id="HashMap线程安全问题"><a href="#HashMap线程安全问题" class="headerlink" title="HashMap线程安全问题"></a>HashMap线程安全问题</h3><p>首先，其不是线程安全的</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyamjjl39bj31a40a00x8.jpg" alt="image-20220112091934193"></p>
<p>线程A，线程B同时写，两条不同的数据的哈希值是一样的，且这个位置没有其他位置写，线程A确认没有哈希冲突后，准备开始写，这时候cpu把线程资源给了吧B，因为A还没有写，所以这时候B检测不到哈希冲突，就直接写了，然后A重新获得资源并且直接写入值，覆盖了B的值</p>
<h3 id="HashMap扩容"><a href="#HashMap扩容" class="headerlink" title="HashMap扩容"></a>HashMap扩容</h3><p><strong>rehashing</strong></p>
<p>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。</p>
<p>1） 首先创建一个比现有哈希表更大的新哈希表（expand）<br>2） 然后将旧哈希表的所有元素都迁移到新哈希表去（rehash）</p>
<p>当向容器中添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值，即当前数据的长度乘以负载因子的值的时候，就要自动扩容了。</p>
<p>扩容就是重新计算容量，向hashmap对象里不停的添加元素，而hashmap对象内部的数组无法装在更多的元素时，对象就要扩大数组的长度，以便能够装入更多的元素。方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水就要换桶一样，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap hashMap = <span class="keyword">new</span> HashMap(cap);</span><br><span class="line">cap = <span class="number">3</span> 容量为<span class="number">4</span></span><br><span class="line">cap = <span class="number">4</span> 容量为<span class="number">4</span></span><br><span class="line">cap = <span class="number">5</span> 容量为<span class="number">8</span></span><br><span class="line">cap = <span class="number">9</span> 容量为<span class="number">16</span></span><br><span class="line">如果cap 是<span class="number">2</span>的n次方，则容量为cap,否则容量为大于cap的第一个<span class="number">2</span>的次方的数</span><br></pre></td></tr></table></figure>



<h3 id="Hashtable-HashMap-ConcurrentHashMap"><a href="#Hashtable-HashMap-ConcurrentHashMap" class="headerlink" title="Hashtable HashMap  ConcurrentHashMap"></a>Hashtable HashMap  ConcurrentHashMap</h3><p>Hashtable 线程安全的对象，内部有上锁的控制，sychronized put的时候不能get 效率不高</p>
<p>HashMap 线程不安全的对象，内部没有上锁 优点就是效率高，缺点是 如果多个线程同时操作可能会出现线程不安全甚至出现死锁的情况</p>
<p>ConcurrentHashMap 分段锁，将锁的力度变小，兼顾安全与性能</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>   <strong>ConcurrentHashMap是<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/java">Java </a>5中支持高并发、高吞吐量的线程安全HashMap实现。</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz6db23axvj30s60eigms.jpg" alt="image-20220208201805473"></p>
<p> HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作。第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。</p>
<p><strong>java 1.8后</strong></p>
<p>遍历查询链表效率太低了之前，因此1.8之后调整了底层的组成结构：</p>
<p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（<code>O(logn)</code></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz6d8sk7fjj30uk0je770.jpg" alt="image-20220208201552489"></p>
<p>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p>
<p>也将之前存放数据的HashEntry改成了Node,但是作用是一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node(<span class="keyword">int</span> hash,K key,V val,Node&lt;K,V&gt; next)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的 <code>val next</code> 都用了 volatile 修饰，保证了可见性。</p>
<p>synchronized 只锁定当前链表或红⿊⼆叉树的⾸节点，这样只要 hash 不冲突，就不会产⽣并发，效率⼜提升 N 倍。</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>最底层用的是map来做这些事,其值作为hashmap的key</p>
<p>其实原理就是HashMap</p>
<p><strong>HashSet是如何保证不重复的</strong></p>
<p>向hashset中add()元素的时候，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equals 方法比较，hashset()中的add()方法会使用hashmap的add()方法。HashMap的key的值时唯一的，由上面的代码可以看出，HashSet添加进去的值就是作为HashMap的key,所以不会重复（HashMap比较key是否相等是先比较hashcode在比较equals）</p>
<h3 id="HashSet-HashMap区别"><a href="#HashSet-HashMap区别" class="headerlink" title="HashSet HashMap区别"></a>HashSet HashMap区别</h3><p>HashSet实现了Set接口，它不允许集合中有重复的值，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。</p>
<p>public boolean add(Object o)方法用来在Set中添加元素，当元素值重复时则会立即返回false，如果成功添加的话会返回true。</p>
<p>HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键。Map接口有两个基本的实现，HashMap和TreeMap。TreeMap保存了对象的排列次序，而HashMap则不能。HashMap允许键和值为null。HashMap是非synchronized的，但collection框架提供方法能保证HashMap synchronized，这样多个线程同时访问HashMap时，能保证只有一个线程更改Map。</p>
<p>public Object put(Object Key,Object value)方法用来将元素添加到map中。</p>
<table>
<thead>
<tr>
<th><em>HashMap</em></th>
<th><em>HashSet</em></th>
</tr>
</thead>
<tbody><tr>
<td>HashMap实现了Map接口</td>
<td>HashSet实现了Set接口</td>
</tr>
<tr>
<td>HashMap储存键值对</td>
<td>HashSet仅仅存储对象</td>
</tr>
<tr>
<td>使用put()方法将元素放入map中</td>
<td>使用add()方法将元素放入set中</td>
</tr>
<tr>
<td>HashMap中使用键对象来计算hashcode值</td>
<td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td>
</tr>
<tr>
<td>HashMap比较快，因为是使用唯一的键来获取对象</td>
<td>HashSet较HashMap来说比较慢</td>
</tr>
</tbody></table>
<p><strong>为什么要采用hash算法，有什么优势，解决了什么问题？</strong></p>
<p>保证数据的唯一性，存储数据底层采用的是数组</p>
<p>当我们放数据的时候，如何判断唯一？</p>
<p>采用hash算法，通过计算存储对象的hashcode,然后再跟数组长度-1进行位运算，得到我们想要存储的位置，如果此位置没有数据，直接存储不用计较。</p>
<p>此处，我们只会用到hashcode</p>
<p>但是随着元素不断添加，可能会发生hash冲突，不同的值计算出来的hash值是相同的，这个时候就要进行比较，才需要用到equals方法</p>
<p>如果不相同，则形成链表</p>
<p><strong>哈希表是一张什么表？</strong>本质是数组，而数组的元素是链表</p>
<p>JDK1.8做了优化，随着元素的不断添加，链表可能会越来越长，会优化为红黑树</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="Java内存模型JMM"><a href="#Java内存模型JMM" class="headerlink" title="Java内存模型JMM"></a>Java内存模型JMM</h3><p>JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>
<p><img src="/2020/11/09/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/4.png"></p>
<p><strong>线程私有的：</strong></p>
<ul>
<li><p><strong>程序计数器</strong></p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
</li>
<li><p><strong>虚拟机栈</strong></p>
<p>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</p>
</li>
<li><p><strong>本地方法栈</strong></p>
<p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p>
</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li><p>堆</p>
<p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p><strong>Java世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.</p>
</li>
<li><p>方法区</p>
<p>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
</li>
<li><p>直接内存 (非运行时数据区的一部分)</p>
</li>
</ul>
<h2 id="Java-代理模式"><a href="#Java-代理模式" class="headerlink" title="Java 代理模式"></a>Java 代理模式</h2><p>代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。</p>
<p>代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以加上一些其他用途。</p>
<p>最直白的就是在Spring中的面向切面编程（AOP），我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>代理类在程序运行时创建的代理方式称为动态代理。在静态代理中，代理类是自己定义好的，在程序运行之前就已经编译完成了。然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。</p>
<p>动态代理的过程，代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。因为动态代理的过程中，我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象是通过InvocationHandler来完成的代理过程的。</p>
<p>与静态代理类对照的是动态代理类，动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。java.lang.reflect 包中的Proxy类和InvocationHandler 接口提供了生成动态代理类的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.battier.dao;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookFacade</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span></span>;  </span><br><span class="line">&#125; </span><br><span class="line">---------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> net.battier.dao.impl;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> net.battier.dao.BookFacade;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeImpl</span> <span class="keyword">implements</span> <span class="title">BookFacade</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;增加图书方法。。。&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">、BookFacadeProxy.java  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> net.battier.proxy;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * JDK动态代理代理类 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> student </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Object target;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 绑定委托对象并返回一个代理类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.target = target;  </span><br><span class="line">        <span class="comment">//取得代理对象  </span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),  </span><br><span class="line">                target.getClass().getInterfaces(), <span class="keyword">this</span>);   <span class="comment">//要绑定接口(这是一个缺陷，cglib弥补了这一缺陷)  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 调用方法 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        Object result=<span class="keyword">null</span>;  </span><br><span class="line">        System.out.println(<span class="string">&quot;事物开始&quot;</span>);  </span><br><span class="line">        <span class="comment">//执行方法  </span></span><br><span class="line">        result=method.invoke(target, args);  </span><br><span class="line">        System.out.println(<span class="string">&quot;事物结束&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>但是，JDK的动态代理依靠接口实现，如果有些类并没有实现接口，则不能使用JDK代理，这就要使用cglib动态代理了。 </p>
<h4 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h4><p>JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</p>
<p>demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.battier.dao;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookFacade</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br><span class="line">----------</span><br><span class="line"><span class="keyword">package</span> net.battier.dao.impl;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 这个是没有实现接口的实现类 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> student </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeImpl1</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;增加图书的普通方法...&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">----------</span><br><span class="line"><span class="keyword">package</span> net.battier.proxy;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;  </span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;  </span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 使用cglib动态代理 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> student </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookFacadeCglib</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Object target;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 创建代理对象 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.target = target;  </span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();  </span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());  </span><br><span class="line">        <span class="comment">// 回调方法  </span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);  </span><br><span class="line">        <span class="comment">// 创建代理对象  </span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="comment">// 回调方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args,  </span></span></span><br><span class="line"><span class="params"><span class="function">            MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;事物开始&quot;</span>);  </span><br><span class="line">        proxy.invokeSuper(obj, args);  </span><br><span class="line">        System.out.println(<span class="string">&quot;事物结束&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="keyword">package</span> net.battier.test;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> net.battier.dao.impl.BookFacadeImpl1;  </span><br><span class="line"><span class="keyword">import</span> net.battier.proxy.BookFacadeCglib;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCglib</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        BookFacadeCglib cglib=<span class="keyword">new</span> BookFacadeCglib();  </span><br><span class="line">        BookFacadeImpl1 bookCglib=(BookFacadeImpl1)cglib.getInstance(<span class="keyword">new</span> BookFacadeImpl1());  </span><br><span class="line">        bookCglib.addBook();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>从代码可以看出，它和jdk动态代理有所不同，对外表现上看CreatProxyedObj，它只需要一个类型class就可以产生一个代理对象， 所以说是“类的代理”，且创造的对象通过打印类型发现也是一个新的类型。不同于jdk动态代理，jdk动态代理要求对象必须实现接口（三个参数的第二个参数），cglib对此没有要求。</p>
<p>cglib的原理是这样，它生成一个继承B的类型C（代理类），这个代理类持有一个MethodInterceptor，我们setCallback时传入的。 C重写所有B中的方法（方法名一致），然后在C中，构建名叫“CGLIB”+“$父类方法名$”的方法（下面叫cglib方法，所有非private的方法都会被构建），方法体里只有一句话super.方法名()，可以简单的认为保持了对父类方法的一个引用，方便调用。</p>
<p>这样的话，C中就有了重写方法、cglib方法、父类方法（不可见），还有一个统一的拦截方法（增强方法intercept）。其中重写方法和cglib方法肯定是有映射关系的。</p>
<p>C的重写方法是外界调用的入口（LSP原则），它调用MethodInterceptor的intercept方法，调用时会传递四个参数，第一个参数传递的是this，代表代理类本身，第二个参数标示拦截的方法，第三个参数是入参，第四个参数是cglib方法，intercept方法完成增强后，我们调用cglib方法间接调用父类方法完成整个方法链的调用。</p>
<h4 id="JDK-Cglib区别"><a href="#JDK-Cglib区别" class="headerlink" title="JDK Cglib区别"></a>JDK Cglib区别</h4><p><strong>原理区别：</strong></p>
<p>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</p>
<p>而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p>
<p>1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP<br>2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP </p>
<p>3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</p>
<p><strong>如何强制使用CGLIB实现AOP？</strong><br> （1）添加CGLIB库，SPRING_HOME/cglib/*.jar<br> （2）在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt;</p>
<p><strong>JDK动态代理和CGLIB字节码生成的区别？</strong><br> （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类<br> （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法<br>  因为是继承，所以该类或方法最好不要声明成final</p>
<p><strong>JDK和CGLib动态代理区别</strong></p>
<p>1、JDK动态代理具体实现原理：</p>
<p>通过实现InvocationHandler接口创建自己的调用处理器；</p>
<p>通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理；</p>
<p>通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型；</p>
<p>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入；</p>
<p>JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力，Spring通过Java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。</p>
<p>2、CGLib动态代理：</p>
<p>利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p>
<p>3、两者对比：</p>
<p>JDK动态代理是面向接口的。</p>
<p>CGLib动态代理是通过字节码底层继承要代理类来实现，因此如果被代理类被final关键字所修饰，会失败。</p>
<p>4、使用注意：</p>
<p>如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）；</p>
<p>如果要被代理的对象不是个实现类那么，Spring会强制使用CGLib来实现动态代理。</p>
<h2 id="Java-锁"><a href="#Java-锁" class="headerlink" title="Java 锁"></a>Java 锁</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyotj6nq6uj313j0o4tan.jpg" alt="img"></p>
<h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁 悲观锁"></a>乐观锁 悲观锁</h3><p>悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>
<p>乐观锁：认为自己在使用数据的时候不会有别的线程来修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据，如果这个数据没有被更新则将自己的数据成功写入，如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作，例如报错或者自动重试。乐观锁在java中是通过无锁编程来实现的，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p>
<ul>
<li><p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确</p>
</li>
<li><p>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyottyzosyj30xh0a1759.jpg" alt="img"></p>
</li>
</ul>
<h3 id="自旋锁VS适应性自旋锁"><a href="#自旋锁VS适应性自旋锁" class="headerlink" title="自旋锁VS适应性自旋锁"></a>自旋锁VS适应性自旋锁</h3><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
<p>自旋锁本身是有缺点的，它不能代替阻塞，自旋锁虽然避免了线程切换的开销，但它要占用处理器的时间，如果锁被占用的时间很短，自旋锁等待的效果就会非常好，反之则会白白浪费处理器资源，因此自旋等待的时间必须要有一定的限度，自旋超过了限定次数，通常是10次没有成功获得，则挂起线程。</p>
<p>实现原理同样也是CAS.</p>
<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。</p>
<h3 id="无锁VS偏向锁VS轻量级锁VS重量级锁"><a href="#无锁VS偏向锁VS轻量级锁VS重量级锁" class="headerlink" title="无锁VS偏向锁VS轻量级锁VS重量级锁"></a>无锁VS偏向锁VS轻量级锁VS重量级锁</h3><p>这四种锁的状态是针对synchronized的。</p>
<p>目前锁的一共有四种状态，级别从低到高依次是 无锁 偏向锁 轻量级锁 和重量级锁，锁的状态只能升级不能降级</p>
<p>Mark Word内容（在对象头中）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gypouewmatj30xu0aiab6.jpg" alt="image-20220125100237895"></p>
<p><strong>无锁</strong></p>
<p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只能有一个线程能修改成功。</p>
<p>无锁的特点是修改在循环内进行，线程会不断地尝试修改共享资源。如果没有冲突就修改成功并退出，否则就继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能够修改成功，而其他修改失败的线程会不断尝试知道修改成功。</p>
<p><strong>偏向锁</strong></p>
<p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低锁获取锁的代价。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁的时候，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁，偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行）,它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到无锁（标志位01）或者轻量级锁（00）</p>
<p><strong>轻量级锁</strong></p>
<p>该锁是指锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁</p>
<p><strong>重量级锁</strong></p>
<p>升级为重量级锁时，锁标志的状态值变为10，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>
<h3 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h3><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<h3 id="可重入锁VS非可重入锁"><a href="#可重入锁VS非可重入锁" class="headerlink" title="可重入锁VS非可重入锁"></a>可重入锁VS非可重入锁</h3><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p>
<p>非可重入锁可能会出现死锁现象。</p>
<p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status==0表示没有其他线程在执行同步代码，则把status设置为1，当前线程开始执行。如果status≠0，则判断当前线程是否能够获取到这个锁的线程，如果是的话status+1，则当前线程可以在此获取到锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果不为0的话会导致其获取锁失败，当前线程阻塞。   </p>
<p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p>
<h3 id="独享锁VS共享锁"><a href="#独享锁VS共享锁" class="headerlink" title="独享锁VS共享锁"></a>独享锁VS共享锁</h3><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p>
<p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁所要解决的问题的本质是 能够对分布在多台机器中的线程对共享资源的互斥访问。</p>
<ul>
<li>基于Mysql,分布式环境中的线程连接同一个数据库，利用数据库中的行锁来达到互斥访问，但是性能较低</li>
<li>Zookeeper,Zookeeper中的数据是存在内存的，并且基于其的顺序节点，临时节点，Watch机制能非常好的来实现</li>
<li>基于Redis，Redis的数据也是具有内存的，基于Redis的消费订阅功能，数据超时功能，lua脚本功能等。</li>
</ul>
<h2 id="Java进程与线程"><a href="#Java进程与线程" class="headerlink" title="Java进程与线程"></a>Java进程与线程</h2><h3 id="创建进程的方式"><a href="#创建进程的方式" class="headerlink" title="创建进程的方式"></a>创建进程的方式</h3><ul>
<li><p>继承Thread类，并复写run方法，创建该类对象，调用start方法开启线程</p>
</li>
<li><p>实现runnable接口，复写run方法，创建Thread类对象，将Runnable子类对象传递给Thread类对象，调用start方法开启线程</p>
</li>
<li><p>创建FutureTask对象，创建Callable子类对象，复写call(相当于run)方法，将其传递给FutureTask对象（相当于一个Runnable）。</p>
<p>创建Thread类对象，将FutureTask对象传递给Thread对象。调用start方法开启线程。这种方式可以获得线程执行完之后的返回值。</p>
</li>
</ul>
<p>A extends Thread：</p>
<p>  简单</p>
<p>不能再继承其他类了(Java单继承)</p>
<p>同份资源不共享</p>
<p>A implements Runnable:(推荐)</p>
<p>多个线程共享一个目标资源，适合多线程处理同一份资源。</p>
<p>该类还可以继承其他类，也可以实现其他接口。</p>
<p><strong>Thread类中的start()和run()方法有什么区别？</strong></p>
<p> start（）方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码： 通过调用Thread类的start()方法来启动一个线程，这时此线程是处于就绪状态，并没有运行。然后通过此Thread类调用方法run()来完成其运行操作的，这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程终止，而CPU再运行其它线程。</p>
<p> run（）方法当作普通方法的方式调用，程序还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码： 而如果直接用run方法，这只是调用一个方法而已，程序中依然只有主线程–这一个线程，其程序执行路径还是只有一条，这样就没有达到多线程的目的</p>
<h3 id="线程间通信-wait"><a href="#线程间通信-wait" class="headerlink" title="线程间通信(wait)"></a>线程间通信(wait)</h3><p>​    <strong>Object类方法wait(),notify(),notifyAll()</strong><br>   线程执行wait()后，就放弃了运行资格，处于冻结状态；线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify()执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程。<br>   notifyall(), 唤醒线程池中所有线程。<br>   wait(), notify(),notifyall()都用在同步里面，因为这3个函数是对持有锁的线程进行操作，而只有同步才有锁，所以要使用在同步中。<br>   wait(),notify(),notifyall(), 在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这3个方法都是Object类中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;  <span class="comment">//生产者和消费者都要操作的资源  </span></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(flag)  </span><br><span class="line">            <span class="keyword">try</span>&#123;wait();&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;  </span><br><span class="line">        <span class="keyword">this</span>.name=name+<span class="string">&quot;---&quot;</span>+count++;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...生产者...&quot;</span>+<span class="keyword">this</span>.name);  </span><br><span class="line">        flag=<span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">this</span>.notify();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(!flag)  </span><br><span class="line">            <span class="keyword">try</span>&#123;wait();&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...消费者...&quot;</span>+<span class="keyword">this</span>.name);  </span><br><span class="line">        flag=<span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">this</span>.notify();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Resource res;  </span><br><span class="line">    Producer(Resource res)&#123;  </span><br><span class="line">        <span class="keyword">this</span>.res=res;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </span><br><span class="line">            res.set(<span class="string">&quot;商品&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Resource res;  </span><br><span class="line">    Consumer(Resource res)&#123;  </span><br><span class="line">        <span class="keyword">this</span>.res=res;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </span><br><span class="line">            res.out();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerDemo</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Resource r=<span class="keyword">new</span> Resource();  </span><br><span class="line">        Producer pro=<span class="keyword">new</span> Producer(r);  </span><br><span class="line">        Consumer con=<span class="keyword">new</span> Consumer(r);  </span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(pro);  </span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(con);  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;<span class="comment">//运行结果正常，生产者生产一个商品，紧接着消费者消费一个商品。  </span></span><br></pre></td></tr></table></figure>

<h3 id="Sleep-Wait区别"><a href="#Sleep-Wait区别" class="headerlink" title="Sleep Wait区别"></a>Sleep Wait区别</h3><p><strong>所属的类不同</strong> sleep是定义在Thread上，wait是定义在Object上</p>
<p><strong>对于锁资源的处理方式不同</strong>  sleep不会释放锁，wait会释放锁</p>
<p><strong>使用范围</strong>：sleep可以使用在任何代码块，wait必须在同步方法或者同步代码块中执行</p>
<p><strong>与wait配套使用的方法：</strong> </p>
<p>​    void notify()//唤醒在此对象监视器上等待的单个线程</p>
<p>​    void notifyAll() //唤醒在此对象监视器上的所有线程</p>
<p>​    void wait()//导致当前的线程等待，知道其他线程调用此对象的notify()方法或者notifyAll()方法</p>
<p><strong>为什么wait要定义在Object中，而不定义在Thread</strong></p>
<p>在同步代码块中，我们说需要一个对象锁来实现多线程的互斥效果 ，也就是说Java的锁是对象级别的，而不是线程级别的</p>
<p><strong>为什么wait必须写在同步代码块中</strong></p>
<p>原因是避免CPU切换到其他线程，而其他线程又提前执行了notify方法，那这样就达不到我们的预期，先wait再由其他线程来唤醒，所以需要一个同步锁来保护</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/def7f016dd5e">java wait()方法用法详解 - 简书 (jianshu.com)</a></p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><strong>线程安全的理解？</strong></p>
<p>一个专业的描述是，当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，就说这个线程是线程安全的</p>
<p><strong>如何做到线程安全嗯？</strong></p>
<p>实现线程安全的方法有很多种，其中在源码中最常见的方法是，采用sychronized关键字给代码块或方法加锁，比如StringBuffer</p>
<p><strong>什么时候需要线程安全？</strong></p>
<p>多个线程访问同一个资源</p>
<p>资源是有状态的，数据是会变化的</p>
<h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><p>先补充一下概念：Java 内存模型中的可见性、原子性和有序性。</p>
<p><strong>可见性：</strong></p>
<p>　　可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p>
<p>　　<strong>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。</strong>也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</p>
<p>　　在 Java 中 volatile、synchronized 和 final 实现可见性。</p>
<p><strong>原子性：</strong></p>
<p>　　<strong>原子是世界上的最小单位，具有不可分割性。</strong>比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</p>
<p>　　在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</p>
<p><strong>有序性：</strong></p>
<p>　　Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p>
<p>​        Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p>
<p>　　在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。    </p>
<p>​        当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</p>
<p>　　而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。</p>
<p>​        当一个变量定义为 volatile 之后，将具备两种特性：</p>
<p>　　1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhengbin/p/6407137.html">Java内存模型</a>）来完成。</p>
<p>　　2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个<strong>内存屏障</strong>（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。</p>
<p><strong>volatile 性能：</strong></p>
<p>　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>
<p><strong>volatile如何实现内存可见性：</strong></p>
<p>深入来说：通过加入内存屏障和禁止重排序优化来实现的。</p>
<p>1）对volatile变量执行写操作时，会在写操作后加入一条store屏障指令</p>
<p>2）对volatile变量执行读操作时，会在读操作前加入一条load屏障执行</p>
<p>通俗来讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。</p>
<p>这样任何时刻，不同的线程总能看到该变量的最新值。</p>
<p><strong>线程写volatile变量的过程：</strong></p>
<p>1，改变线程工作内存中volatile变量副本的值</p>
<p>2，将改变后的副本从工作内存刷新到主内存。</p>
<p><strong>线程读volatile变量过程：</strong></p>
<p>1）从主内存读取volatile变量的最新值到线程工作内存中</p>
<p>2）从工作内存读取volatile变量的副本</p>
<p><strong>观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</strong></p>
<p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
<p>　　2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<h3 id="Synchronized-关键字-wait-notify"><a href="#Synchronized-关键字-wait-notify" class="headerlink" title="Synchronized 关键字(wait notify)"></a>Synchronized 关键字(wait notify)</h3><p>该关键字解决的问题是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p><strong>最主要的三种使用方式</strong></p>
<ol>
<li><strong>修饰实例方法</strong>  作用于当前对象实例加锁，进入同步代码块之前要获得当前对象实例的锁</li>
<li><strong>修饰静态方法</strong>，也就是给当前类加锁，会作用于当前类的所有对象实例，进入同步代码块前要获得当前class的锁，记住访问静态synchronized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前实例对象锁。</li>
<li><strong>修饰代码块</strong>，指定加锁对象，对给定对象/类加锁， synchronized(this|object) 表示进入同步代码库前要获得给定对象的锁，synchronized(类.class) 表示进入同步代码块前要获得当前class的锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li>synchronized关键字加到static静态方法和synchronized(class)代码块上都是给class类上锁。</li>
<li>synchronized关键字加到实例方法是给对象实例上锁。</li>
<li>尽量不使用synchronized(String a)因为JVM中，字符串常量池具有缓存功能</li>
</ul>
<p><strong>Synchronized关键字的底层原理</strong></p>
<p>Synchronized 同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中前者指令指向同步代码块的开始位置，后者指令指向同步代码块的结束位置。</p>
<p>Synchronized修饰的方法并没有monitorenter 和 monitorexit 指令，取而代之的是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法。</p>
<p><strong>wait</strong></p>
<ol>
<li>wait方法The current thread must own this object’s monitor，当前线程必需获得这个对象的锁。因为一个线程进入了synchronized的代码块表示这个线程拿到了对象锁，那么这个wait方法必需在synchronized代码块中。</li>
<li>这个方法让进入到此处的线程丢掉对象锁并且挂起等待（能执行到wait方法的线程一定是拿到了对象锁的线程）。</li>
<li>其它线程调用这个对象的notify或notifyAll方法时，系统会在当前挂起等待在wait方法处的多个线程中，随机找出一个唤醒，被唤醒的线程会等待直到它拿到了对象锁并继续执行。</li>
</ol>
<p><strong>背景知识</strong></p>
<p>1、wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写。</p>
<p>2、wait()使当前线程阻塞，前提是 必须先获得锁，一般配合synchronized 关键字使用，即，一般在synchronized 同步代码块里使用 wait()、notify/notifyAll() 方法。</p>
<p>3、 由于 wait()、notify/notifyAll() 在synchronized 代码块执行，说明当前线程一定是获取了锁的。</p>
<p>当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。</p>
<p>只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。</p>
<p>也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程让其获得锁</p>
<p>4、wait() 需要被try catch包围，以便发生异常中断也可以使wait等待的线程唤醒。</p>
<p>5、notify 和wait 的顺序不能错，如果A线程先执行notify方法，B线程在执行wait方法，那么B线程是无法被唤醒的。</p>
<p>6、notify 和 notifyAll的区别</p>
<p>notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。</p>
<p>7、在多线程中要测试某个条件的变化，使用if 还是while？</p>
<p>要注意，notify唤醒沉睡的线程后，线程会接着上次的执行继续往下执行。所以在进行条件判断时候，可以先把 wait 语句忽略不计来进行考虑；显然，要确保程序一定要执行，并且要保证程序直到满足一定的条件再执行，要使用while进行等待，直到满足条件才继续往下执行</p>
<h3 id="Synchronized-Volatile-关键字"><a href="#Synchronized-Volatile-关键字" class="headerlink" title="Synchronized Volatile 关键字"></a>Synchronized Volatile 关键字</h3><p>二者是互补的存在，不是对立的存在</p>
<ul>
<li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好，但是volatile关键字只能作用于变量而synchronized关键字可以修饰方法以及代码块</li>
<li>volatile关键字能够保证数据的可见性，但不能保证数据的原子性，而synchronized关键字两者都能保证</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性</li>
</ul>
<h3 id="Synchronized-lock"><a href="#Synchronized-lock" class="headerlink" title="Synchronized lock"></a>Synchronized lock</h3><p>在Java中，synchronized关键字是用来控制线程同步的，就是在多线程的环境下，控制synchronized代码段不被多个线程同时执行。</p>
<p>synchronized既可以加在一段代码上，也可以加在方法上。</p>
<p><strong>作用的位置不同</strong> </p>
<p>前者可以给方法，代码块加锁，后者只能给代码块加锁</p>
<p><strong>锁的获取锁和释放机制不同</strong></p>
<p>前者无需手动获取锁和释放锁，发生异常会自动解锁，不会出现死锁</p>
<p>lock需要自己加锁和释放锁，如lock()和unlock()，如果忘记使用unlock(),则会出现死锁。所以一般都是在finally中使用unlock</p>
<pre><code>synchronized：
        1.使用简单，语义清晰，可以在任何地方使用

         2.是由JVM提供的，提供了很多优化手段(锁粗化、锁消除、偏向锁、轻量级锁)

         3.由JVM进行锁释放，不用手动操作，减少了产生死锁的可能性

          4.无法实现锁的一些高级功能如：公平锁、中断锁、超时锁、读写锁、共享锁等

  Lock:

        1.可以实现所有不能再synchronized关键字中的实现的锁的高级功能

        2.可以通过实现Lock接口来实现自定义的一些方法

        3.使用时一定要记住unlock锁，如果不释放，容易造成死锁。
</code></pre>
<p><strong>补充</strong></p>
<p>sychronized修饰成员方法时，默认的锁对象就是当前对象</p>
<p>sychronized修饰静态方法时，默认的锁对象，就是class对象，比如User.class</p>
<p>sychronized修饰代码块时，可以自己来设置锁对象，比如</p>
<p>sychronized(this){</p>
<p>​    //线程进入自动获取锁</p>
<p>​    //线程执行结束，自动释放锁</p>
<p>}</p>
<p><strong>lock使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// new一个锁对象，注意此处必须声明成类对象，保持只有一把锁,ReentrantLock是Lock的唯一实现类</span></span><br><span class="line">   Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String fileMessage)</span></span>&#123;</span><br><span class="line">      lock.lock();<span class="comment">// 上锁</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot;得到了锁，正在读取文件……&quot;</span>);</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;fileMessage.length(); i++)&#123;</span><br><span class="line">            System.out.print(fileMessage.charAt(i));</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">         System.out.println(<span class="string">&quot;文件读取完毕！&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放了锁！&quot;</span>);</span><br><span class="line">         lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">(<span class="keyword">final</span> String fileMessage)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 创建若干个线程</span></span><br><span class="line">      ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">      <span class="comment">// 提交20个任务</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">         service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               readFile(fileMessage);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">20</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 释放线程池中的线程</span></span><br><span class="line">      service.shutdown();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="synchronized和reentrantlock的区别"><a href="#synchronized和reentrantlock的区别" class="headerlink" title="synchronized和reentrantlock的区别"></a>synchronized和reentrantlock的区别</h3><p><strong>相似点</strong></p>
<p>这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）。</p>
<p><strong>功能区别：</strong></p>
<p>这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成</p>
<p>便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</p>
<p>锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized</p>
<p><strong>性能的区别：</strong></p>
<p>在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p>
<p><strong>1.Synchronized</strong></p>
<p>Synchronized进过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。</p>
<p> <strong>2.ReentrantLock</strong></p>
<p>由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有以下3项：</p>
<p>​    1.等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。通过lock.lockInterruptibly()来实现这个机制。</p>
<p>​    2.公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</p>
<p><em>公平锁、非公平锁的创建方式：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个非公平锁，默认是非公平锁</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//创建一个公平锁，构造传参true</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>​    3.锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</p>
<p><strong>ReenTrantLock实现的原理：</strong></p>
<p>之后还会总结一篇ReenTrantLock相关的原理底层原理分析，简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p>
<p><strong>什么情况下使用ReenTrantLock：</strong></p>
<p>答案是，如果你需要实现ReenTrantLock的三个独有功能时。</p>
<p>ReentrantLock的用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynDemo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line">		Runnable t1=<span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="keyword">new</span> Thread(t1,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(t1,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>　Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，在阻塞队列那一篇博文中就讲述到了，阻塞队列实际上是使用了Condition来模拟线程间协作。</p>
<ul>
<li>Condition是个接口，基本的方法就是await()和signal()方法；</li>
<li>Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition() </li>
<li> 调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用</li>
</ul>
<p>　　Conditon中的await()对应Object的wait()；</p>
<p>　　Condition中的signal()对应Object的notify()；</p>
<p>　　Condition中的signalAll()对应Object的notifyAll()。</p>
<p>Condition的执行方式，是当在线程Consumer中调用await方法后，线程Consumer将释放锁，并且将自己沉睡，等待唤醒，线程Producer获取到锁后，开始做事，完毕后，调用Condition的signalall方法，唤醒线程Consumer，线程Consumer恢复执行。</p>
<p>以上说明Condition是一个多线程间协调通信的工具类，使得某个，或者某些线程一起等待某个条件（Condition）,只有当该条件具备( signal 或者 signalAll方法被带调用)时 ，这些等待线程才会被唤醒，从而重新争夺锁。</p>
<p><strong>与wait区别</strong></p>
<p>两种在表现上有点相似，但是作用机制是有区别的<br>1.object wait() 不能单独使用，必须是在synchronized 下才能使用，<br>2.object wait()必须要通过Nodify()方法进行唤醒<br>3.condition await() 必须是当前线程被排斥锁 lock 后,，获取到condition 后才能使用<br>4.condition await() 必须通过 sign() 方法进行唤醒<br>5.Condition可以精准的对多个不同条件进行控制，wait/notify只能和synchronized关键字一起使用，并且只能唤醒一个或者全部的等待队列；</p>
<p>6.Condition需要使用Lock进行控制，使用的时候要注意lock()后及时的unlock()，Condition有类似于await的机制，因此不会产生加锁方式而产生的死锁出现，同时底层实现的是park/unpark的机制，因此也不会产生先唤醒再挂起的死锁，一句话就是不会产生死锁，但是wait/notify会产生先唤醒再挂起的死锁。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK 中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p>每一个ThreadLocal能够放一个线程级别的变量，可是它本身能够被多个线程共享使用，并且又能够达到线程安全的目的，且绝对线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; RESOURCE = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>RESOURCE代表一个能够存放String类型的ThreadLocal对象。此时不论什么一个线程能够并发訪问这个变量，对它进行写入、读取操作，都是线程安全的。比方一个线程通过RESOURCE.set(“aaaa”);将数据写入ThreadLocal中，在不论什么一个地方，都能够通过RESOURCE.get();将值获取出来。</p>
<p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p>
<p><strong>原理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p>
<p>结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，会使用 <code>Thread</code>内部都是使用仅有那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p>
<p><strong>ThreadLocal 内存泄露问题</strong></p>
<p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>弱引用介绍：</strong></p>
<blockquote>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
<p><strong>使用场景</strong></p>
<p>Spring的事务管理器通过AOP切入业务代码，在进入业务代码前，会依据相应的事务管理器提取出相应的事务对象，假如事务管理器是DataSourceTransactionManager，就会从DataSource中获取一个连接对象，通过一定的包装后将其保存在ThreadLocal中。而且Spring也将DataSource进行了包装，重写了当中的getConnection()方法，或者说该方法的返回将由Spring来控制，这样Spring就能让线程内多次获取到的Connection对象是同一个。<br>为什么要放在ThreadLocal里面呢？由于Spring在AOP后并不能向应用程序传递參数。应用程序的每一个业务代码是事先定义好的，Spring并不会要求在业务代码的入口參数中必须编写Connection的入口參数。此时Spring选择了ThreadLocal，通过它保证连接对象始终在线程内部，不论什么时候都能拿到，此时Spring很清楚什么时候回收这个连接，也就是很清楚什么时候从ThreadLocal中删除这个元素。<br>从Spring事务管理器的设计上能够看出。Spring利用ThreadLocal得到了一个非常完美的设计思路，同一时候它在设计时也十分清楚ThreadLocal中元素应该在什么时候删除。由此，我们简单地觉得ThreadLocal尽量使用在一个全局的设计上。而不是一种打补丁的间接方法。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能。</p>
<p>线程池的好处：</p>
<ul>
<li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</p>
</li>
<li><p>提高响应速度。当任务到达的时候，任务可以不需要等到线程创建能立即执行</p>
</li>
<li><p>可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</p>
</li>
<li><p>提供定时执行、定期执行、单线程、并发数控制等功能。</p>
</li>
<li><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p>
</li>
</ul>
<h4 id="Runnable-Calllable接口"><a href="#Runnable-Calllable接口" class="headerlink" title="Runnable Calllable接口"></a>Runnable Calllable接口</h4><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。**<code>Runnable</code> 接口** 不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong> 可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong> ，这样代码看起来会更加简洁。</p>
<p>工具类 <code>Executors</code> 可以实现将 <code>Runnable</code> 对象转换成 <code>Callable</code> 对象。（<code>Executors.callable(Runnable task)</code> 或 <code>Executors.callable(Runnable task, Object result)</code>）。</p>
<h4 id="Execute-submit"><a href="#Execute-submit" class="headerlink" title="Execute() submit()"></a>Execute() submit()</h4><p><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></p>
<p><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h4 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h4><p>java 提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池。</p>
<p><strong>四种线程池的创建：</strong></p>
<p>1）newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</p>
<p>2）newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<p>3）newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行，创建一个可定期或者延时执行任务的定长线程池，支持定时及周期性任务执行。 </p>
<p>4）newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<p><strong>阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>
<blockquote>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
</blockquote>
<p>因此创建的方法为：</p>
<p>方法1：通过构造方法实现</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyb8ncg399j31a408ktaq.jpg" alt="image-20220112220421654"></p>
<p><strong>方式二：通过 Executor 框架的工具类 Executors 来实现</strong></p>
<p>我们可以创建三种类型的 ThreadPoolExecutor：</p>
<ul>
<li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
<p>对应 Executors 工具类中的方法如图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyb8nkmxyxj30hx066q3i.jpg" alt="Executor框架的工具类"></p>
<h4 id="线程池七大参数（ThreadPoolExecutor）"><a href="#线程池七大参数（ThreadPoolExecutor）" class="headerlink" title="线程池七大参数（ThreadPoolExecutor）"></a><strong>线程池七大参数（ThreadPoolExecutor）</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                        TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                        RejectedExecutionHandler handler)</span> </span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>corePoolSize 线程池核心线程大小</strong></li>
</ul>
<p>线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会 被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。<strong>最小可以同时运行的线程数量</strong></p>
<ul>
<li><strong>maximumPoolSize 线程池最大线程数量</strong></li>
</ul>
<p>一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接执行，如果没有则会缓存到工作队列（后面会介绍）中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。 <strong>当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数</strong></p>
<ul>
<li><strong>keepAliveTime 空闲线程存活时间</strong></li>
</ul>
<p>一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定</p>
<ul>
<li><strong>unit 空闲线程存活时间单位</strong></li>
</ul>
<p>keepAliveTime的计量单位</p>
<ul>
<li><strong>workQueue 工作队列</strong></li>
</ul>
<p><strong>当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</strong></p>
<p>新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：</p>
<p>​    ①ArrayBlockingQueue</p>
<p>基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。</p>
<p>​    ②LinkedBlockingQuene</p>
<p>基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使用该工作队列时，参数maxPoolSize其实是不起作用的。</p>
<p>​    ③SynchronousQuene</p>
<p>一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。</p>
<p>​    ④PriorityBlockingQueue</p>
<p>具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</p>
<ul>
<li>threadFactory 线程工厂</li>
</ul>
<p>创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</p>
<ul>
<li>handler 拒绝策略</li>
</ul>
<h4 id="线程池策略"><a href="#线程池策略" class="headerlink" title="线程池策略"></a><strong>线程池策略</strong></h4><p><strong>corePoolSize：核心线程数；maximunPoolSize：最大线程数</strong><br>每当有新的任务到线程池时，<br><strong>第一步：</strong> 先判断线程池中当前线程数量是否达到了<strong>corePoolSize</strong>，若未达到，则新建线程运行此任务，且任务结束后将该线程保留在线程池中，不做销毁处理，若当前线程数量已达到<strong>corePoolSize</strong>，则进入下一步；<br><strong>第二步：</strong> 判断工作队列(workQueue)是否已满，未满则将新的任务提交到工作队列中，满了则进入下一步；<br><strong>第三步：</strong> 判断线程池中的线程数量是否达到了<strong>maxumunPoolSize</strong>，如果未达到，则新建一个工作线程来执行这个任务，如果达到了则使用<strong>拒绝策略</strong>来处理这个任务。<strong>注意：</strong> 在线程池中的线程数量超过<strong>corePoolSize</strong>时，每当有线程的空闲时间超过了keepAliveTime，这个线程就会被终止。直到线程池中线程的数量不大于<strong>corePoolSize</strong>为止。<br>（由第三步可知，在一般情况下，Java线程池中会长期保持<strong>corePoolSize</strong>个线程。）</p>
<p><strong>拒绝策略</strong></p>
<p><strong>当工作队列满且线程个数达到maximunPoolSize后所采取的策略</strong>：<br>1.AbortPolicy：<strong>默认策略；</strong>新任务提交时直接抛出未检查的异常RejectedExecutionException，该异常可由调用者捕获。<br>2.CallerRunsPolicy：既不抛弃任务也不抛出异常，使用调用者所在线程运行新的任务。<br>3.DiscardPolicy：丢弃新的任务，且不抛出异常。<br>4.DiscardOldestPolicy：调用poll方法丢弃工作队列队头的任务，然后尝试提交新任务<br>5.自定义策略：根据用户需要定制。</p>
<h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">mport java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><p>框架不仅包括了线程池的管理，还提供了线程工厂，队列以及拒绝策略等</p>
<p><strong>框架结构</strong></p>
<p>1）任务(runnable/callable) 执行任务需要的实现的runnable接口或者callable接口，二者实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行</p>
<p>2）任务的执行（Exexutor）包括任务执行机制的核心接口 <strong><code>Executor</code></strong> ，以及继承自 <code>Executor</code> 接口的 <strong><code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code></strong> 和 <strong><code>ScheduledThreadPoolExecutor</code></strong> 这两个关键类实现了 <strong>ExecutorService 接口</strong>。</p>
<p>3）异步计算的结果(Future) <strong><code>Future</code></strong> 接口以及 <code>Future</code> 接口的实现类 <strong><code>FutureTask</code></strong> 类都可以代表异步计算的结果。</p>
<p>当我们把 <strong><code>Runnable</code>接口</strong> 或 <strong><code>Callable</code> 接口</strong> 的实现类提交给 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。（调用 <code>submit()</code> 方法时会返回一个 <strong><code>FutureTask</code></strong> 对象）</p>
<ol>
<li><strong>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</strong></li>
<li><strong>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的 对象直接交给 <code>ExecutorService</code> 执行</strong>: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li>
<li><strong>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象</strong>（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li>
<li><strong>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行</strong></li>
</ol>
<h3 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h3><p><code>Atomic</code> 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</p>
<h4 id="JUC包中的原子类"><a href="#JUC包中的原子类" class="headerlink" title="JUC包中的原子类"></a>JUC包中的原子类</h4><p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整形原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整形数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整形字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整形字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器</li>
</ul>
<h4 id="AtomicInteger-cas"><a href="#AtomicInteger-cas" class="headerlink" title="AtomicInteger(cas)"></a>AtomicInteger(cas)</h4><p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="comment">// 使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。</span></span></span><br><span class="line"><span class="function">  class AtomicIntegerTest </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS，在java.util.concurrent.locks包中，AbstractQueuedSynchronizer这个类是并发包中的核心，了解其他类之前，需要先弄清楚AQS。在JUC的很多类中都会存在一个内部类Sync，Sync都是继承自AbstractQueuedSynchronizer。</p>
<p>AQS就是一个同步器，要做的事情就相当于一个锁，所以就会有两个动作：一个是获取，一个是释放。获取释放的时候该有一个东西来记住他是被用还是没被用，这个东西就是一个状态。如果锁被获取了，也就是被用了，还有很多其他的要来获取锁，总不能给全部拒绝了，这时候就需要他们排队，这里就需要一个队列。这大概就清楚了AQS的主要构成了：</p>
<ul>
<li>获取和释放两个动作</li>
<li>同步状态（原子操作）</li>
<li>阻塞队列</li>
</ul>
<h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>AQS用32位整形来表示同步状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure>

<p>在互斥锁中表示线程是否已经获取了锁，0未获取，1已经获取，大于1表示重入数。</p>
<p>AQS提供了getState(),setState(),compareAndSetState()来获取和修改state的值，这些操作需要atomic包的支持，采用CAS操作，保证其原子性和可见性。</p>
<h4 id="CLH锁队列"><a href="#CLH锁队列" class="headerlink" title="CLH锁队列"></a>CLH锁队列</h4><p>CLH其实就是一个FIFO的队列，只不过稍微做了点改进。AQS中内部使用内部类Node来实现，是一个链表队列，原始CLH使用自旋锁，AQS的CLH则在每个node里使用一个状态字段来控制阻塞，不是自旋。</p>
<p>AQS的CLH队列锁中，每个节点代表着一个需要获取锁的线程，该node中有两个常量SHARED共享模式，EXCLUSIVE独占模式。</p>
<p>共享模式允许多个线程可以获取同一个锁，独占模式则一个锁只能被一个线程持有，其他线程必须要等待。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzmhatg675j21740leabd.jpg" alt="img"></p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS操作包含三个操作数-内存位置V，预期原值A，新值B</p>
<p>分为三个步骤：</p>
<ol>
<li>读取内存中的值</li>
<li>将读取的值和预期的值进行比较</li>
<li>如果比较的结果符合预期，则写入新值，如果不符合，则什么都不做</li>
</ol>
<p><strong>在多CPU下，不能保证两个线程同时CAS，那如何CAS机制又是如何保证线程安全的呢？</strong></p>
<p>比如在cpu1下执行完比较准备修改时，cpu2火速完成了一次CAS从而让内存中的值发生了变化，此时cpu1再写入明显就不对了。</p>
<p>解决：使用volatile。<br>volatile的特性：</p>
<p><strong>可见性：volatile修饰的对象在加载时会告知JVM，对象在cpu缓存上对多个线程是同时可见的。</strong><br><strong>顺序性：保证线程操作对象时时顺序执行的，不会进行指令重排序。</strong><br><strong>一致性：可以保证多个线程读取数据时，读到的数据是最新的。</strong><br>解决以上问题的关键就在volatile的一致性，volatile的写操作是安全的，因为他在写入的时候lock会锁住cpu总线导致其他cpu不能访问内存（现在多用缓存一致性协议，即处理器嗅探总线上传播的数据来判断自己缓存的值是否过期），所以当cpu2火速修改了变量的值时，这就让该变量在所有cpu上缓存的值都失效了，cpu1在进行写操作时，发现自己缓存的值已经失效了，那么CAS操作失败，（Java的AutomicInteger中，会不停的CAS直到成功）。所以即使在多cpu多线程下，CAS机制也能保证线程安全。</p>
<p>CAS存在的问题：</p>
<ol>
<li>ABA问题：<br>CAS会检查值有没有发生变化，没有则更新，但如果一个值A，变成了B，又变成了A，CAS检查时会发现它没有变化，但实际是变化了。<br>解决：使用版本号，每次变量更新把版本号加1，A－B－A 就会变成1A-2B－3A。</li>
</ol>
<p>JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全相等，则以原子的方式将该引用和该标志的值设置为给定的更新值。</p>
<p>2.循环时间长，开销大：<br>自旋CAS如果长时间不成功，会不断尝试，长时间占用CPU，带来非常大的执行开销。<br>解决：如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<p>3.只能保证一个共享变量的原子操作：<br>当对一个共享变量执行操作时，可以使用循环CAS来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性了。这个时候就要用到锁了。<br>或者把多个共享变量合并成一个共享变量来操作，比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p>
<h3 id="join关键字"><a href="#join关键字" class="headerlink" title="join关键字"></a>join关键字</h3><p>join()方法的作用，是等待这个线程结束</p>
<p>也就是说，t.join()方法<strong>阻塞调用此方法的线程</strong>(calling thread)进入 <strong>TIMED_WAITING</strong> 状态，<strong>直到线程t完成，此线程再继续</strong>；</p>
<p>通常用于在main()主线程内，等待其它线程完成再结束main()主线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Waits at most &lt;code&gt;millis&lt;/code&gt; milliseconds for this thread to  </span></span><br><span class="line"><span class="comment">     * die. A timeout of &lt;code&gt;0&lt;/code&gt; means to wait forever.    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//此处A timeout of 0 means to wait forever 字面意思是永远等待，其实是等到t结束后。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span>    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从代码中，我们可以发现。当millis==0时，会进入while( isAlive() )循环；即只要子线程是活的，主线程就不停的等待。<br>我们根据上面解释join()作用时的代码来理解join()的用法！<br>wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前运行的线程。虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！ </p>
<p>这样理解: 例子中的Thread t只是一个对象 , isAlive()判断当前对象(例子中的t对象)是否存活, wait()阻塞的是当前执行的线程(例子中的main方法)</p>
<p>可以看出，Join方法实现是通过wait()。 当main线程调用t.join时候，main线程会获得线程对象t的锁（wait 意味着拿到该对象的锁),调用该对象的wait()，直到该对象唤醒main线程 ，比如退出后。这就意味着main 线程调用t.join时，必须能够拿到线程t对象的锁<br>————————————————</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">设置cnt初始值为<span class="number">3</span></span><br><span class="line">CountDownLatch cnt=<span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">TA线程启动</span><br><span class="line">调用cnt.await()方法</span><br><span class="line">TA线程等待</span><br><span class="line">T1线程执行完成</span><br><span class="line">调用cnt.countDown()方法，此时 cnt=<span class="number">3</span>-<span class="number">1</span>=<span class="number">2</span></span><br><span class="line">T2线程执行完成</span><br><span class="line">调用cnt.countDown()方法，此时 cnt=<span class="number">2</span>-<span class="number">1</span>=<span class="number">1</span></span><br><span class="line">T3线程执行完成</span><br><span class="line">调用cnt.countDown()方法，此时 cnt=<span class="number">1</span>-<span class="number">1</span>=<span class="number">0</span></span><br><span class="line">cnt=<span class="number">0</span> 重新唤醒TA主线程继续执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="例题-主线程等待子线程结束再结束"><a href="#例题-主线程等待子线程结束再结束" class="headerlink" title="例题 主线程等待子线程结束再结束"></a>例题 主线程等待子线程结束再结束</h3><p>在主线程中启动一些子线程，等待所有子线程执行结束后，主线程再继续执行</p>
<p>比如：老板分配任务，众多工人开始工作，等所有工人完成工作后，老板进行检查</p>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Worker w1 = <span class="keyword">new</span> Worker(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Worker w2 = <span class="keyword">new</span> Worker(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        Worker w3 = <span class="keyword">new</span> Worker(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Worker&gt; workers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        workers.add(w1);</span><br><span class="line">        workers.add(w2);</span><br><span class="line">        workers.add(w3);</span><br><span class="line"></span><br><span class="line">        Boss boss = <span class="keyword">new</span> Boss(workers);</span><br><span class="line">        boss.work();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(List&lt;Worker&gt; workers)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;老板招收工人。&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.workers = workers;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;老板开始安排工人工作...&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老板安排&quot;</span> + worker.getWorkerName() + <span class="string">&quot;的工作&quot;</span>);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;老板安排工作结束...&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;老板正在等所有的工人干完活......&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    w.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;e = &quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;工人活都干完了，老板开始检查了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String workerName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String workerName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.workerName = workerName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.workerName + <span class="string">&quot;正在干活...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;e = &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.workerName + <span class="string">&quot;活干完了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getWorkerName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> workerName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        Worker w1 = <span class="keyword">new</span> Worker(latch, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Worker w2 = <span class="keyword">new</span> Worker(latch, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        Worker w3 = <span class="keyword">new</span> Worker(latch, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Worker&gt; workers = <span class="keyword">new</span> ArrayList&lt;Worker&gt;();</span><br><span class="line">        workers.add(w1);</span><br><span class="line">        workers.add(w2);</span><br><span class="line">        workers.add(w3);</span><br><span class="line"></span><br><span class="line">        Boss boss = <span class="keyword">new</span> Boss(workers, latch);</span><br><span class="line">        boss.work();</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch downLatch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(List&lt;Worker&gt; workers, CountDownLatch downLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.workers = workers;</span><br><span class="line">            <span class="keyword">this</span>.downLatch = downLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;老板开始安排工人工作...&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老板安排&quot;</span> + worker.getWorkerName() + <span class="string">&quot;的工作&quot;</span>);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;老板安排工作结束...&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;老板正在等所有的工人干完活......&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//latch.await()，是等待子线程结束。</span></span><br><span class="line">                <span class="keyword">this</span>.downLatch.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;e = &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;工人活都干完了，老板开始检查了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch downLatch;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String workerName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(CountDownLatch downLatch, String workerName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.downLatch = downLatch;</span><br><span class="line">            <span class="keyword">this</span>.workerName = workerName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.workerName + <span class="string">&quot;正在干活...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;e = &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.workerName + <span class="string">&quot;活干完了！&quot;</span>);</span><br><span class="line">            <span class="comment">//latch.countDown()，是用于在子线程执行结束后计数器减一，即未完成子线程数减一。</span></span><br><span class="line">            <span class="keyword">this</span>.downLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getWorkerName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> workerName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>此方法不会阻塞主线程，但是会监听所有子线程结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// parties : 障碍清除之前，必须调用&#123;@link#await&#125;的线程数</span></span><br><span class="line">        <span class="comment">// barrierAction : 当障碍物清除 时要执行的命令</span></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;工人活都干完了，老板开始检查了！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker w1 = <span class="keyword">new</span> Worker(<span class="string">&quot;张三&quot;</span>, barrier);</span><br><span class="line">        Worker w2 = <span class="keyword">new</span> Worker(<span class="string">&quot;李四&quot;</span>, barrier);</span><br><span class="line">        Worker w3 = <span class="keyword">new</span> Worker(<span class="string">&quot;王五&quot;</span>, barrier);</span><br><span class="line"></span><br><span class="line">        List&lt;Worker&gt; workers = <span class="keyword">new</span> ArrayList&lt;Worker&gt;();</span><br><span class="line">        workers.add(w1);</span><br><span class="line">        workers.add(w2);</span><br><span class="line">        workers.add(w3);</span><br><span class="line"></span><br><span class="line">        Boss boss = <span class="keyword">new</span> Boss(workers);</span><br><span class="line">        boss.work();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(List&lt;Worker&gt; workers)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.workers = workers;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;老板开始安排工人工作...&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老板安排&quot;</span> + worker.getWorkerName() + <span class="string">&quot;的工作&quot;</span>);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;老板安排工作结束...&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;老板正在等所有的工人干完活......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String workerName;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String workerName, CyclicBarrier barrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.workerName = workerName;</span><br><span class="line">            <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.workerName + <span class="string">&quot;正在干活...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;e = &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.workerName + <span class="string">&quot;活干完了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getWorkerName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> workerName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="例题-Java多个线程顺序打印数字"><a href="#例题-Java多个线程顺序打印数字" class="headerlink" title="例题 Java多个线程顺序打印数字"></a>例题 Java多个线程顺序打印数字</h3><p><strong>要求：</strong>启动N个线程，这N个线程要不间断按顺序打印数字1-N，将问题简化为3个线程无线循环打印1-3</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/milton/p/11311148.html">https://www.cnblogs.com/milton/p/11311148.html</a></p>
<h4 id="使用synchronized"><a href="#使用synchronized" class="headerlink" title="使用synchronized"></a>使用synchronized</h4><p>三个线程无序竞争同步锁，如果遇上的是自己的数字，就打印，这种方式会浪费大量的循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSequential1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos == i) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;T-&quot;</span> + i + <span class="string">&quot; &quot;</span> + count);</span><br><span class="line">                pos = i % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestSequential1 demo = <span class="keyword">new</span> TestSequential1();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    demo.one(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="synchronized配个wait-notifyAll"><a href="#synchronized配个wait-notifyAll" class="headerlink" title="synchronized配个wait() notifyAll()"></a>synchronized配个wait() notifyAll()</h4><p>竞争同步锁时使用wait()和notifyAll(), 可以避免浪费循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSequential01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> next = i % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(i + <span class="string">&quot; in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (pos != i) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        System.out.println(i + <span class="string">&quot; wait&quot;</span>);</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;T-&quot;</span> + i + <span class="string">&quot; &quot;</span> + count);</span><br><span class="line">                    pos = next;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    obj.notifyAll();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestSequential01 demo = <span class="keyword">new</span> TestSequential01();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                demo.run(j);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="number">3</span> in</span><br><span class="line"><span class="number">3</span> wait</span><br><span class="line"><span class="number">1</span> in</span><br><span class="line">T-<span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> in</span><br><span class="line"><span class="number">1</span> wait</span><br><span class="line"><span class="number">2</span> in</span><br><span class="line">T-<span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> in</span><br><span class="line"><span class="number">2</span> wait</span><br><span class="line"><span class="number">1</span> wait</span><br><span class="line">T-<span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> in</span><br><span class="line"><span class="number">3</span> wait</span><br><span class="line">T-<span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="comment">///</span></span><br></pre></td></tr></table></figure>

<h4 id="可重入锁（公平锁）"><a href="#可重入锁（公平锁）" class="headerlink" title="可重入锁（公平锁）"></a>可重入锁（公平锁）</h4><p>用Lock做, 非公平锁, 三个线程竞争, 如果遇上的是自己的数字, 就打印. 这种方式会浪费大量的循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSequential01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> next = i % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (pos == i) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;T-&quot;</span> + i + <span class="string">&quot; &quot;</span> + count);</span><br><span class="line">                pos = next;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestSequential01 demo = <span class="keyword">new</span> TestSequential01();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                demo.run(j);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>` `<span class="keyword">final</span>` `Lock lock = ``<span class="keyword">new</span>` `ReentrantLock(``<span class="keyword">true</span>``);</span><br><span class="line"><span class="comment">// 和3一样, 但是使用公平锁, 这种情况下基本上可以做到顺序执行, 偶尔会产生多一次循环</span></span><br></pre></td></tr></table></figure>



<h3 id="Leetcode上按序打印"><a href="#Leetcode上按序打印" class="headerlink" title="Leetcode上按序打印"></a>Leetcode上按序打印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123; print(<span class="string">&quot;first&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">()</span> </span>&#123; print(<span class="string">&quot;second&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">()</span> </span>&#123; print(<span class="string">&quot;third&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个不同的线程 A、B、C 将会共用一个 Foo 实例。</p>
<p>线程 A 将会调用 first() 方法<br>线程 B 将会调用 second() 方法<br>线程 C 将会调用 third() 方法<br>请设计修改程序，以确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</p>
<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) object.wait();</span><br><span class="line">            printFirst.run();</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            object.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) object.wait();</span><br><span class="line">            printSecond.run();</span><br><span class="line">            flag = <span class="number">3</span>;</span><br><span class="line">            object.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">3</span>) object.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="借助原子类操作"><a href="#借助原子类操作" class="headerlink" title="借助原子类操作"></a>借助原子类操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">AtomicFoo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger atomic = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        printFirst.run();</span><br><span class="line">        atomic.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (atomic.get() != <span class="number">1</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        printSecond.run();</span><br><span class="line">        atomic.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (atomic.get() != <span class="number">2</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程交替打印FooBar"><a href="#多线程交替打印FooBar" class="headerlink" title="多线程交替打印FooBar"></a>多线程交替打印FooBar</h3><p>给你一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>两个不同的线程将会共用一个 FooBar 实例：</p>
<p>线程 A 将会调用 foo() 方法，而<br>线程 B 将会调用 bar() 方法<br>请设计修改程序，以确保 “foobar” 被输出 n 次。</p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>实现原理：ReentrantLock主要使用CAS+AQS队列来实现。它支持公平锁和非公平锁</p>
<p>AS：Compare and Swap，比较并交换。CAS有3个操作数：内存值V、预期值A、要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。该操作是一个原子操作，被广泛的应用在Java的底层实现中。在Java中，CAS主要是由sun.misc.Unsafe这个类通过JNI调用CPU底层指令实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> fooExec = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fooExec) &#123;</span><br><span class="line">                    printFoo.run();</span><br><span class="line">                    fooExec = <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fooExec) &#123;</span><br><span class="line">                    printBar.run();</span><br><span class="line">                    fooExec = <span class="keyword">true</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> fooExec = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fooExec) &#123;<span class="comment">//fooExec为false时，该线程等待，为true的时候执行下面的操作</span></span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                fooExec = <span class="keyword">false</span>;</span><br><span class="line">                obj.notifyAll();<span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fooExec) &#123;</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                fooExec = <span class="keyword">true</span>;</span><br><span class="line">                obj.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分布式锁-1"><a href="#分布式锁-1" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>在单台服务器内部，可以通过线程加锁的方式来同步，但是在分布式场景下就需要分布式锁来保证实例并发安全访问共享变量，</p>
<p>分布式锁的目的是保证在分布式部署的应用集群中，多个服务在请求同一个方法或者同一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行，避免出现问题，</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ul>
<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；</li>
<li>高可用的获取锁与释放锁；</li>
<li>高性能的获取锁与释放锁；</li>
<li>具备可重入特性；</li>
<li>具备锁失效机制，防止死锁；</li>
<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</li>
</ul>
<h3 id="常用实现"><a href="#常用实现" class="headerlink" title="常用实现"></a>常用实现</h3><p>实现分布式锁目前有三种流行方案，即基于关系型数据库，Redis,ZooKeeper的方案</p>
<h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>基于关系型数据库实现分布式锁，是依赖数据库的唯一性来实现资源锁定，比如主键和唯一索引。</p>
<p>以唯一索引为例，创建一张锁表，定义方法或者资源名、失效时间等字段，同时针对加锁的信息添加唯一索引，比如方法名，当要锁住某个方法或资源时，就在该表中插入对应方法的一条记录，插入成功表示获取了锁，想要释放锁的时候就删除这条记录。</p>
<p>比如下面创建一张基于数据库的分布式锁表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `methodLock` (</span><br><span class="line"> </span><br><span class="line">`id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line"> </span><br><span class="line">`method_name` varchar(64) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;锁定的方法或者资源&#x27;,</span><br><span class="line"> </span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line"> </span><br><span class="line">UNIQUE KEY `uidx_method_name` (`method_name `) USING BTREE</span><br><span class="line"> </span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;对方法加锁&#x27;;</span><br><span class="line"></span><br><span class="line"># 当希望对某个方法加锁的时候，执行以下SQL语句</span><br><span class="line">insert into methodLock(method_name) values (&#x27;method_name&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在数据表定义中，我们对 method_name 做了唯一性约束，如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么就可以认为操作成功的那个线程获得了该方法的锁，可以执行后面的业务逻辑。</p>
<p>当方法执行完毕之后，想要释放锁的话，在数据库中删除对应的记录即可。</p>
<p>基于数据库实现分布式锁操作简单，但是并不是一个可以落地的方案，有很多地方需要优化。</p>
<p>缺点：</p>
<ul>
<li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ul>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>使用命令介绍：</p>
<p>（1）SETNX</p>
<p>SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。</p>
<p>（2）expire</p>
<p>expire key timeout：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。</p>
<p>（3）delete</p>
<p>delete key：删除key</p>
<p>实现方法</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(setnx(key,value)==<span class="number">1</span>)&#123;</span><br><span class="line"> </span><br><span class="line">    expire(key,expireTime)   <span class="comment">//设置过期时间</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//业务处理</span></span><br><span class="line"> </span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">//释放锁</span></span><br><span class="line"> </span><br><span class="line">       del(key)</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<p>1.setnx和expire不是原子操作，所以存在设置了setnx 之后突然崩溃，导致锁没有设置过期时间，那么这个锁就会一直存在，无法被其他线程获取。此时可以用Redis 2.8以后支持set和expire的原子操作</p>
<blockquote>
<p> SET key value expireTime nx</p>
</blockquote>
<p>2.Redis集群下可能会出现竟态</p>
<p>​    客户端 A 从 Master 节点获取锁；</p>
<p>​    Master 节点宕机，主从复制过程中，对应锁的 key 还没有同步到 Slave 节点上；</p>
<p>​    Slave 升级为 Master 节点，于是集群丢失了锁数据；</p>
<p>​    其他客户端请求新的 Master 节点，获取到了对应同一个资源的锁；出现多个客户端同时持有同一个资源的锁，不满足锁的互斥性。</p>
<p>关于集群下如何实现分布式锁，Redis 的作者 Antirez（Salvatore Sanfilippo）提出了 Redlock 算法</p>
<p>Redlock 算法的流程</p>
<p>Redlock 算法是在单 Redis 节点基础上引入的高可用模式，Redlock 基于 N 个完全独立的 Redis 节点，一般是大于 3 的奇数个（通常情况下 N 可以设置为 5），可以基本保证集群内各个节点不会同时宕机。</p>
<p> 假设当前集群有 5 个节点，运行 Redlock 算法的客户端依次执行下面各个步骤，来完成获取锁的操作：</p>
<pre><code>  客户端记录当前系统时间，以毫秒为单位；

 依次尝试从 5 个 Redis 实例中，使用相同的 key 获取锁，当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，超时时间应该小于锁的失效时间，避免因为网络故障出现的问题；

 客户端使用当前时间减去开始获取锁时间就得到了获取锁使用的时间，当且仅当从半数以上的 Redis 节点获取到锁，并且当使用的时间小于锁失效时间时，锁才算获取成功；

 如果获取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间，减少超时的几率；

 如果获取锁失败，客户端应该在所有的 Redis 实例上进行解锁，即使是上一步操作请求失败的节点，防止因为服务端响应消息丢失，但是实际数据添加成功导致的不一致。
</code></pre>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="七层模型"><a href="#七层模型" class="headerlink" title="七层模型"></a>七层模型</h3><p>应用层 表示层 会话层  为<strong>操作系统</strong>或<strong>网络应用程序</strong>提供访问网络服务的接口</p>
<p>传输层(TCP UDP) 实现两个<strong>应用程序</strong>之间的数据透明传送（<strong>不一定可靠(UDP)**）。将上层数据分段，提供</strong>端到端**的可靠的(TCP)和不可靠的(UDP)服务。</p>
<p>网络层  实现两个<strong>主机</strong>之间的数据透明传送（<strong>不一定可靠(IP)**）。主要功能：路由选择Routing；存储转发Forwarding；（一部分的）拥塞控制 **ICMP</strong>  路由器</p>
<p>数据链路层  将源自网络层来的数据<strong>可靠地</strong>传输到<strong>相邻节点</strong>的目标机网络层 **Ethernet以太网协议，用于实现链路层的数据传输和地址封装 **交换机</p>
<p>物理层 确保原始的数据可在各种物理媒体上以比特流的形式<strong>可靠地</strong>传输</p>
<p><strong>TCP/IP的体系结构</strong></p>
<p>应用层（各种应用层协议如TELNET,FTP,SMTP等），运输层，网际层IP，网络接口层</p>
<p><strong>五层协议的体系结构</strong></p>
<p>应用层 运输层 网络层 数据链路层 物理层</p>
<p>应用层的任务是通过应用进程间的交互来完成特定网络应用。</p>
<p><strong>应用层协议如下：</strong></p>
<p>(1)域名系统(Domain Name System，DNS)：用于实现网络设备名字到IP地址映射的网络服务。</p>
<p>(2)文件传输协议(File Transfer Protocol，FTP)：用于实现交互式文件传输功能。</p>
<p>(3)简单邮件传送协议(Simple Mail Transfer Protocol, SMTP)：用于实现电子邮箱传送功能。</p>
<p>(4)超文本传输协议(HyperText Transfer Protocol，HTTP)：用于实现WWW服务。</p>
<p>(5)简单网络管理协议(simple Network Management Protocol，SNMP)：用于管理与监视网络设备。</p>
<p>(6)远程登录协议(Telnet)：用于实现远程登录功能。</p>
<p><strong>ICMP</strong>是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。属于网络层协议</p>
<p>控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>
<p><strong>运输层</strong></p>
<p>运输层的主要任务是负责向两台主机进程之间的通信提供通用的数据传输服务。</p>
<p><strong>网络层</strong></p>
<p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的主要任务就是选择合适的网间路由和交换结点，确保数据及时传送。</p>
<p><strong>数据链路层</strong></p>
<p>数据链路层通常简称为链路层。两台主机之间的数据传输，总是一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧。</p>
<h3 id="端到端，点到点的区别"><a href="#端到端，点到点的区别" class="headerlink" title="端到端，点到点的区别"></a>端到端，点到点的区别</h3><ul>
<li><strong>端到端是针对传输层</strong>说的。在数据传输之前，先为数据的传输开辟一条通道，然后在进行传输。</li>
<li><strong>点到点通信是针对数据链路层或网络层</strong>来说的，是指一个设备发数据给<strong>直接连接</strong>的其他设备，通过一台一台直接相连的设备把数据传递到接收端。</li>
<li>端到端的优点是，链路建立之后，发送端知道接收端<strong>一定能收到</strong>。而点到点发送端发出数据后，<strong>不知道</strong>接收端能否收到或何时能收到数据。</li>
<li>端到端传输的缺点是直到接收端收到数据为止，<strong>发送端的设备一直要参与</strong>传输。点到点传输则在发送端设备送出数据后，它的<strong>任务已经完成</strong>。</li>
<li>端到端经过中间交换设备时不需要进行存储转发（至少不可见），而点到点需要。但如果接收端设备关机或故障，点到点传输可以采用<strong>存储转发技术进行缓冲</strong>，端到端则传输失败。</li>
</ul>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><ol>
<li>GET是<strong>幂等</strong>的，即读取同一个资源总是得到相同的数据，POST不是幂等的；</li>
<li>GET一般用于从服务器<strong>获取</strong>资源，而POST有可能<strong>改变</strong>服务器上的资源；</li>
<li>GET请求（包括参数）<strong>可被保存</strong>到收藏夹，POST则不可以</li>
<li>GET请求的数据明文附在<strong>URL之后</strong>；POST请求的数据在HTTP <strong>body中</strong>；</li>
<li>GET只允许ASCII字符，POST对<strong>数据类型</strong>没有要求，也允许二进制数据；</li>
<li>GET的长度有限制（操作系统或者浏览器），而POST<strong>数据大小</strong>无限制</li>
</ol>
<h3 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h3><ul>
<li>1xx：信息服务器收到请求，需要请求者继续执行操作</li>
<li>2xx：成功 </li>
<li>3xx：重定向</li>
<li>4xx:客户端错误</li>
<li>5xx:服务器错误</li>
</ul>
<p>301（永久移动）请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。</p>
<p>302（临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</p>
<p>400（错误请求）服务器不理解请求的语法。</p>
<p>401（未授权）请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。</p>
<p>403（禁止）服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。</p>
<p>404（未找到）服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。</p>
<p>如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。</p>
<p>如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。</p>
<p>500（服务器内部错误）服务器遇到错误，无法完成请求。</p>
<p>501（尚未实施）服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</p>
<p>502（错误网关）服务器作为网关或代理，从上游服务器收到无效响应。</p>
<p>503（服务不可用）服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</p>
<h3 id="HTTP与Https"><a href="#HTTP与Https" class="headerlink" title="HTTP与Https"></a>HTTP与Https</h3><p><strong>HTTP：80端口 keep-alive：请求应答模式无连接协议，输入这个客户端到服务端连接持续有效</strong></p>
<p><strong>https: 443端口 http+ssl</strong> </p>
<ol>
<li>端口不同：HTTP使用的是80端口，HTTPS使用443端口；</li>
<li>HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；</li>
<li>HTTPS由于加密解密会带来更大的CPU和内存开销；</li>
<li>HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买</li>
</ol>
<p><strong>http长连接 短连接</strong></p>
<p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
<h4 id="TCP长连接"><a href="#TCP长连接" class="headerlink" title="TCP长连接"></a>TCP长连接</h4><p>长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>
<p>TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。</p>
<p>如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态：</p>
<ul>
<li>客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。</li>
<li>客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li>
<li>客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。</li>
</ul>
<h4 id="长连接短连接优点"><a href="#长连接短连接优点" class="headerlink" title="长连接短连接优点"></a>长连接短连接优点</h4><p><strong>长连接</strong>可以<strong>省去较多的TCP建立和关闭的操作，减少浪费，节约时间</strong>。对于频繁请求资源的客户来说，较适用长连接。不过这里<strong>存在一个问题</strong>，<strong>存活功能的探测周期太长</strong>，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，<strong>Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候</strong>，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p>
<p><strong>短连接</strong>对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户<strong>请求频繁</strong>，将在<strong>TCP的建立和关闭操作上浪费时间和带宽</strong>。</p>
<p><strong>http无状态，如何保存用户信息</strong></p>
<p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>
<h3 id="https建立连接过程"><a href="#https建立连接过程" class="headerlink" title="https建立连接过程"></a>https建立连接过程</h3><p>非对称加密+对称加密结合 而且得尽量减少非对称加密的次数。非对称加密、解密各只需用一次即可。<br>请看一下这个过程：</p>
<ol>
<li>某网站拥有用于非对称加密的公钥A、私钥A’。</li>
<li>浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。</li>
<li>浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。</li>
<li>服务器拿到后用私钥A’解密得到密钥X。</li>
<li>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密。</li>
</ol>
<p>完美！HTTPS基本就是采用了这种方案。完美？还是有漏洞的。</p>
<p>漏洞就是无法保证就是服务器发送的，可能会有中间人攻击</p>
<p>此时就需要证书与签名</p>
<h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a><strong>中间人攻击</strong></h4><p>中间人的确无法得到浏览器生成的密钥B，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开拿到它呀！然而中间人却完全不需要拿到密钥A’就能干坏事了。请看：</p>
<ol>
<li>某网站拥有用于非对称加密的公钥A、私钥A’。</li>
<li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li>
<li><strong>中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）</strong>。</li>
<li>浏览器随机生成一个用于对称加密的密钥X，用<strong>公钥B</strong>（浏览器不知道公钥被替换了）加密后传给服务器。</li>
<li><strong>中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器</strong>。</li>
<li>服务器拿到后用私钥A’解密得到密钥X。</li>
</ol>
<p>这样在双方都不会发现异常的情况下，中间人得到了密钥B。<strong>根本原因是浏览器无法确认自己收到的公钥是不是网站自己的</strong>。那么下一步就是解决下面这个问题：</p>
<h4 id="如何证明浏览器收到的公钥一定是该网站的公钥？"><a href="#如何证明浏览器收到的公钥一定是该网站的公钥？" class="headerlink" title="如何证明浏览器收到的公钥一定是该网站的公钥？"></a><strong>如何证明浏览器收到的公钥一定是该网站的公钥？</strong></h4><p>现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中能不能搞这么个公信机构呢？给网站颁发一个“身份证”？</p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a><strong>数字证书</strong></h4><p>网站在使用HTTPS前，需要向“<strong>CA机构</strong>”申请颁发一份<strong>数字证书</strong>，数字证书里有证书持有者、证书持有者的公钥等信息，服务器把证书传输给浏览器，浏览器从证书里取公钥就行了，证书就如身份证一样，可以证明“该公钥对应该网站”。然而这里又有一个显而易见的问题了，证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？身份证有一些防伪技术，数字证书怎么防伪呢？解决这个问题我们就基本接近胜利了！</p>
<h4 id="如何放防止数字证书被篡改？"><a href="#如何放防止数字证书被篡改？" class="headerlink" title="如何放防止数字证书被篡改？"></a><strong>如何放防止数字证书被篡改？</strong></h4><p>我们把证书内容生成一份“签名”，比对证书内容和签名是否一致就能察觉是否被篡改。这种技术就叫<code>数字签名</code>：</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a><strong>数字签名</strong></h4><p>这部分内容建议看下图并结合后面的文字理解，图中左侧是数字签名的制作过程，右侧是验证过程（原图出处找不到了，可以看出来这图已经被转载了无数次了。。。）</p>
<p><img src="/2020/11/09/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/4.jpg" alt="img"></p>
<p><strong>数字签名的制作过程</strong>：</p>
<ol>
<li>CA拥有非对称加密的私钥和公钥。</li>
<li>CA对证书明文信息进行hash。</li>
<li>对hash后的值用私钥加密，得到数字签名。</li>
</ol>
<p>明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。<br>那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）</p>
<p><strong>浏览器验证过程：</strong></p>
<ol>
<li>拿到证书，得到明文T，数字签名S。</li>
<li>用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。</li>
<li>用证书里说明的hash算法对明文T进行hash得到T’。</li>
<li>比较S’是否等于T’，等于则表明证书可信。</li>
</ol>
<p>为什么这样可以证明证书可信呢？我们来仔细想一下。</p>
<h4 id="中间人有可能篡改该证书吗？"><a href="#中间人有可能篡改该证书吗？" class="headerlink" title="中间人有可能篡改该证书吗？"></a><strong>中间人有可能篡改该证书吗？</strong></h4><p>假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。<br>既然不可能篡改，那整个证书被掉包呢？</p>
<h4 id="中间人有可能把证书掉包吗？"><a href="#中间人有可能把证书掉包吗？" class="headerlink" title="中间人有可能把证书掉包吗？"></a><strong>中间人有可能把证书掉包吗？</strong></h4><p>假设有另一个网站B也拿到了CA机构认证的证书，它想搞垮网站A，想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，会导致上文提到的漏洞。<br>其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</p>
<h4 id="为什么制作数字签名时需要hash一次？"><a href="#为什么制作数字签名时需要hash一次？" class="headerlink" title="为什么制作数字签名时需要hash一次？"></a><strong>为什么制作数字签名时需要hash一次？</strong></h4><p>我初学HTTPS的时候就有这个问题，似乎以上过程中hash有点多余，把hash过程去掉也能保证证书没有被篡改。<br>最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加密解密就会快很多。<br>当然还有安全上的原因，这部分内容相对深一些，感兴趣的可以看这篇解答：<a href="https://link.zhihu.com/?target=https://link.juejin.im/?target=https://crypto.stackexchange.com/a/12780">crypto.stackexchange.com/a/12780</a></p>
<h4 id="怎么证明CA机构的公钥是可信的？"><a href="#怎么证明CA机构的公钥是可信的？" class="headerlink" title="怎么证明CA机构的公钥是可信的？"></a><strong>怎么证明CA机构的公钥是可信的？</strong></h4><p>你们可能会发现上文中说到CA机构的公钥，我几乎一笔带过，“浏览器保有它的公钥”，这是个什么保有法？怎么证明这个公钥是否可信？<br>让我们回想一下数字证书到底是干啥的？没错，为了证明某公钥是可信的，即“该公钥是否对应该网站/机构等”，那这个CA机构的公钥是不是也可以用数字证书来证明？没错，操作系统、浏览器本身会预装一些它们信任的根证书，如果其中有该CA机构的根证书，那就可以拿到它对应的可信公钥了。<br>实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做<code>信任链</code>或<code>数字证书链</code>，也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。<br>另外，不知你们是否遇到过网站访问不了、提示要安装证书的情况？这里安装的就是跟证书。说明浏览器不认给这个网站颁发证书的机构，那么没有该机构的根证书，你就得手动下载安装（风险自己承担XD）。安装该机构的根证书后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。</p>
<h4 id="HTTPS必须在每次请求中都要先在SSL-TLS层进行握手传输密钥吗？"><a href="#HTTPS必须在每次请求中都要先在SSL-TLS层进行握手传输密钥吗？" class="headerlink" title="HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？"></a><strong>HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？</strong></h4><p>这也是我当时的困惑之一，显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？用session就行。<br>服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！</p>
<ol>
<li>客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；</li>
<li>服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，<strong>加密公钥</strong>（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；</li>
<li>客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；</li>
<li>如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个<strong>随机密钥</strong>（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行<strong>摘要</strong>计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；</li>
<li>服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；</li>
<li>浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密</li>
</ol>
<p>总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。</p>
<h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL TLS"></a>SSL TLS</h3><p>SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。</p>
<p>提供服务</p>
<p>1）认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>2）加密数据以防止数据中途被窃取；</p>
<p>3）维护数据的完整性，确保数据在传输过程中不被改变。</p>
<p><strong>SSL介绍：</strong></p>
<p>　　安全套接字（Secure Socket Layer，SSL）协议是Web浏览器与Web服务器之间安全交换信息的协议，提供两个基本的安全服务：鉴别与保密。</p>
<p>　　SSL是Netscape于1994年开发的，后来成为了世界上最著名的web安全机制，所有主要的浏览器都支持SSL协议。</p>
<p>　　目前有三个版本：2、3、3.1，最常用的是第3版，是1995年发布的。</p>
<p>　　<strong>SSL协议的三个特性</strong></p>
<p>　　① 保密：在握手协议中定义了会话密钥后，所有的消息都被加密。</p>
<p>　　② 鉴别：可选的客户端认证，和强制的服务器端认证。</p>
<p>　　③ 完整性：传送的消息包括消息完整性检查（使用MAC）。</p>
<h3 id="输入url到页面加载"><a href="#输入url到页面加载" class="headerlink" title="输入url到页面加载"></a>输入url到页面加载</h3><p>1、输入地址</p>
<p>2、浏览器查找域名的 IP 地址，DNS解析，TCP连接　</p>
<p>3、浏览器向 web 服务器发送一个 HTTP 请求</p>
<p>4、服务器的永久重定向响应</p>
<p>5、浏览器跟踪重定向地址</p>
<p>6、服务器处理请求</p>
<p>7、服务器返回一个 HTTP 响应　</p>
<p>8、浏览器显示 HTML</p>
<p>9、浏览器发送请求获取嵌入在 HTML 中的资源（如CSS、JS、图片、音频、视频等）</p>
<p><strong>查找ip过程</strong></p>
<p>请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p>
<p>如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地的DNS服务器 ，本地DNS服务器一般都是由你的网络接入服务器商提供，比如中国电信、中国移动。</p>
<p>你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</p>
<p>根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址，这个过程是迭代的过程。</p>
<p>本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器， .com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器请求的域名的解析服务器地址。</p>
<p>最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还会把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>
<h3 id="Cookie-Session区别"><a href="#Cookie-Session区别" class="headerlink" title="Cookie,Session区别"></a>Cookie,Session区别</h3><p>Cookie一般用来保存用户信息，比如网页的自动登录的功能，存放一个Token在Cookie中，下次登录的时候根据Token值来查找用户即可。</p>
<p>Session的主要作用是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，服务端给特定的用户创建特定的session后就可以标识这个用户。</p>
<h4 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h4><ul>
<li>Session: 服务端</li>
<li>Cookie:客户端</li>
</ul>
<h4 id="存储的数据格式"><a href="#存储的数据格式" class="headerlink" title="存储的数据格式"></a>存储的数据格式</h4><ul>
<li>Session:value为对象，Object为类型</li>
<li>Cookie:value为字符串，如果我们存储一个对象，这个时候，就需要将对象转换为JSON</li>
</ul>
<h4 id="存储的数据大小"><a href="#存储的数据大小" class="headerlink" title="存储的数据大小"></a>存储的数据大小</h4><ul>
<li>Session:受服务器内存控制</li>
<li>Cookie：一般来说，最大为4k</li>
</ul>
<h4 id="声明周期"><a href="#声明周期" class="headerlink" title="声明周期"></a>声明周期</h4><ul>
<li>Session:服务器段控制，默认是30分钟，注意当用户关闭了浏览器，session并不会消失</li>
<li>Cookie:客户端控制，其实是客户端的一个文件，分两种情况<ol>
<li>默认的事会话级的cookie,这种随着浏览器的关闭而消失，比如保存sessionid的cookie</li>
<li>非会话级的cookie，通过设置有效期来控制，比如这种7天免登录这种功能，就需要设置有效期，setMaxAge</li>
</ol>
</li>
<li>Cookie 可以设置任意时间有效，而 Session 一般失效时间短</li>
</ul>
<h4 id="二者联系"><a href="#二者联系" class="headerlink" title="二者联系"></a>二者联系</h4><p>http协议本身是一个无状态协议，服务器为了记住用户的状态，我们采用session的机制，而session机制背后的原理是，服务器会自动生成会话级的cookie来保存session的标识</p>
<p>session.setAttribute()  get</p>
<p><strong>浏览器关闭，session就销毁了嘛？</strong></p>
<ul>
<li>要看session是否过期，和浏览器是否关闭无关。</li>
</ul>
<p><strong>服务器关闭，session就销毁了嘛？</strong></p>
<ul>
<li>正常关闭不会。非正常关闭可能就…销毁了。</li>
</ul>
<p><strong>禁用cookie，如何使用Session ID</strong></p>
<ul>
<li>url重写</li>
</ul>
<p>Session存在哪里，怎么把session_id返回给客户端？</p>
<ul>
<li>服务器端（内存，数据库，文件）</li>
<li>在<strong>返回头</strong>中有setCookie，把session_id存到cookie中</li>
</ul>
<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>对于初学者来说，对Token和Session的使用难免会限于困境，开发过程中知道有这个东西，但却不知道为什么要用他？更不知道其原理，今天我就带大家一起分析分析这东西。</p>
<p>  一、我们先解释一下他的含义：</p>
<p>1、Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p>
<p>2、Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p>
<p>3、使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p>
<p>  了解了Token的意义后，我们就更明确的知道为什么要用他了。</p>
<p>  二、如何使用Token？</p>
<p>  这是本文的重点，在这里我就介绍常用的两种方式。</p>
<p>1、用设备号/设备mac地址作为Token（推荐）</p>
<p>  客户端：客户端在登录的时候获取设备的设备号/mac地址，并将其作为参数传递到服务端。</p>
<p>  服务端：服务端接收到该参数后，便用一个变量来接收同时将其作为Token保存在数据库，并将该Token设置到session中，客户端每次请求的时候都要统一拦截，并将客户端传递的token和服务器端session中的token进行对比，如果相同则放行，不同则拒绝。</p>
<p>分析：此刻客户端和服务器端就统一了一个唯一的标识Token，而且保证了每一个设备拥有了一个唯一的会话。该方法的缺点是客户端需要带设备号/mac地址作为参数传递，而且服务器端还需要保存；优点是客户端不需重新登录，只要登录一次以后一直可以使用，至于超时的问题是有服务器这边来处理，如何处理？若服务器的Token超时后，服务器只需将客户端传递的Token向数据库中查询，同时并赋值给变量Token，如此，Token的超时又重新计时。</p>
<p>2、用session值作为Token</p>
<p>  客户端：客户端只需携带用户名和密码登陆即可。</p>
<p>  客户端：客户端接收到用户名和密码后并判断，如果正确了就将本地获取sessionID作为Token返回给客户端，客户端以后只需带上请求数据即可。</p>
<p>分析：这种方式使用的好处是方便，不用存储数据，但是缺点就是当session过期后，客户端必须重新登录才能进行访问数据。</p>
<h3 id="转发重定向区别"><a href="#转发重定向区别" class="headerlink" title="转发重定向区别"></a>转发重定向区别</h3><h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>发生在服务器内部的跳转，所以对于客户端来说，至始至终就是一个请求，所以这期间，保存在request对象中的数据可以进行传递</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>发生在客户端的跳转，所以是多次请求，这个时候，如果需要在多次请求之间传递数据，就需要用session对象</p>
<p>在后台程序，想要跳转到百度应该使用重定向，因为转发的范围限制在服务器内部</p>
<h3 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h3><h4 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h4><p>概念 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。<br>功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。<br>传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST<br>使用RESTful操作资源 ： 可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！<br><a target="_blank" rel="noopener" href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT</p>
<p><a target="_blank" rel="noopener" href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestFulController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原来的： http://localhost:8080/add?a=1&amp;b=2</span></span><br><span class="line">    <span class="comment">//RestFul: http://localhost:8080/add/a/b</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">test1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Model model)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = a+b;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;结果为&quot;</span>+res);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/add/&#123;a&#125;/&#123;b&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">test2</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> a,<span class="meta">@PathVariable</span> <span class="keyword">int</span> b, Model model)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = a+b;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;结果为&quot;</span>+res);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：使用路径变量的好处？<br>使路径变得更加简洁；<br>获得参数更加方便，框架会自动进行类型转换。<br>通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这<br>里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。</p>
<p>使用method属性指定请求类型<br>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT,PATCH, DELETE, TRACE等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射访问路径,必须是POST请求</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.POST&#125;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">index2</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">	model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：<br>Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。<br>所有的地址栏请求默认都会是 HTTP GET 类型的。<br>方法级别的注解变体有如下几个： 组合注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="meta">@DeleteMapping</span></span><br><span class="line"><span class="meta">@PatchMapping</span></span><br></pre></td></tr></table></figure>

<p>@GetMapping 是一个组合注解<br>它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。<br>平时使用的会比较多！</p>
<h3 id="TCP-UDP区别"><a href="#TCP-UDP区别" class="headerlink" title="TCP UDP区别"></a>TCP UDP区别</h3><p>两者都是传输层协议</p>
<p>其次</p>
<p>tcp提供可靠的传输协议，传输前需要建立连接，面向字节流，传输慢，效率低 适合一对一 无界的连续数据分成多块发送</p>
<p>udp无法保证传输的可靠性，无需创建连接，以报文的方式传输，效率高 广播多播</p>
<p>TCP应用场景：<br>效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</p>
<p>UDP应用场景：<br>效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</p>
<h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a><strong>TCP三次握手</strong></h4><p>第一次握手：建立连接时，客户端发送syn包（syn=1，seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手</p>
<p><strong>为什么需要三次握手</strong></p>
<p>三次握手的目的就是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<p><strong>为什么需要SYN</strong></p>
<p>接收端传回所发送的SYN是为了告诉发送端，我接收到的信息确实就是你所发送的信号。</p>
<p><strong>为什么还需要ACK</strong></p>
<p>双方通信无误必须是两者互相发送信息都是无误的。传了SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ack信号来确认。</p>
<p><strong>三次握手改成两次会出现什么情况</strong></p>
<p>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
<p>有人会困惑为什么要进行三次握手呢（两次确认）？这主要是为了防止已失效的请求连接报文忽然又传送到了，从而产生错误。<br>假定A向B发送一个连接请求，由于一些原因，导致A发出的连接请求在一个网络节点逗留了比较多的时间。此时A会将此连接请求作为无效处理 又重新向B发起了一次新的连接请求，B正常收到此连接请求后建立了连接，数据传输完成后释放了连接。如果此时A发出的第一次请求又到达了B，B会以为A又发起了一次连接请求，<code>如果是两次握手：此时连接就建立了，B会一直等待A发送数据，从而白白浪费B的资源</code>。 <code>如果是三次握手：由于A没有发起连接请求，也就不会理会B的连接响应，B没有收到A的确认连接，就会关闭掉本次连接</code>。</p>
<p>序列号的确认号的作用<br>TCP协议工作在OSI的传输层，是一种可靠的面向连接的数据流协议，TCP之所以可靠，是因为它保证了传送数据包的顺序。顺序是用一个序列号来保证的。响应包内也包括一个序列号，表示接收方准备好这个序列号的包。在TCP传送一个数据包时，它会把这个数据包放入重发队列中，同时启动计时器，如果收到了关于这个包的确认信息，便将此数据包从队列中删除，如果在计时器超时的时候仍然没有收到确认信息，则需要重新发送该数据包。另外，TCP通过数据分段中的序列号来保证所有传输的数据可以按照正常的顺序进行重组，从而保障数据传输的完整！</p>
<p><strong>初始序列号</strong></p>
<p>TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002…三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。</p>
<p><strong>第2次握手传回了ACK，为什么还要传回SYN？</strong></p>
<p>接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。”</p>
<h4 id="tcp四次挥手"><a href="#tcp四次挥手" class="headerlink" title="tcp四次挥手"></a><strong>tcp四次挥手</strong></h4><p>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些</p>
<h4 id="time-wait状态"><a href="#time-wait状态" class="headerlink" title="time_wait状态"></a>time_wait状态</h4><p>  为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ </p>
<p>  – 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
<h4 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h4><p>TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的半关闭。</p>
<p><strong>为什么需要半关闭</strong></p>
<p>为了保证数据的完全交换，应该留出足够长的连接时间，但是应该留出多长的时间呢？</p>
<p>比如客户端连接到服务器，服务器将一个文件传输给客户端，客户端收到后发送确认数据给服务器端</p>
<p>这时服务器端只需要连续的传输文件数据，而客户端却无法知道需要接收数据到何时，客户端也不可能无休止的调用输入函数，因为这有可能导致程序阻塞(调用的函数未返回)</p>
<p>服务器端应该在数据发送完毕后传递EOF表示文件结束，客户端接收到EOF即停止接收数据并向服务器端发送确认数据。close函数与shutdown都可以向客户端发送EOF数据，但使用close发送EOF后也无法接收对方传输的数据了，所以使用shutdown </p>
<p>注意：即使使用了shutdown函数实现TCP套接字的半关闭，在最后依旧要使用close函数关闭套接字</p>
<h4 id="TCP如何保证数据传输的可靠性"><a href="#TCP如何保证数据传输的可靠性" class="headerlink" title="TCP如何保证数据传输的可靠性"></a><strong>TCP如何保证数据传输的可靠性</strong></h4><ul>
<li>应用数据被分割成TCP认为最适合发送的数据块</li>
<li>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传输给应用层</li>
<li>校验和：TCP将保持它首部的数据的校验和。这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化，如果收到的校验和有差错，tcp将丢弃这个报文段和不确认收到此报文段</li>
<li>tcp的接收端会丢弃重复的数据</li>
<li>流量控制：tcp连接的每一方都有固定大小的缓冲空间，tcp的接收端只允许发送端发送连接接收端缓冲区能接纳的数据，当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。tcp使用的流量控制协议是可变大小的滑动窗口协议</li>
<li>拥塞控制：当网络拥塞时，减少数据的发送</li>
<li>停止等待协议ARQ：基本原理是每发完一个分组就停止发送，等待对方确认，在收到确认后再发下一个分组。</li>
<li>超时重传：当tcp发出一个字段后，它启动一个定时器，等待目的端确认收到这个报文段，如果不能及时确认，将重发</li>
</ul>
<p><strong>滑动窗口</strong></p>
<ul>
<li>TCP 利用滑动窗口实现流量控制的机制。</li>
<li>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</li>
<li>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小</li>
</ul>
<p><strong>拥塞控制</strong></p>
<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p>
<p>为了进行拥塞控制，TCP发送方要维持一个拥塞窗口（cwnd）的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。</p>
<p>TCP的拥塞控制四种算法  <strong>慢开始 拥塞避免 快重传 快恢复</strong></p>
<p><strong>慢开始</strong>：由小到大逐渐增大发送窗口 ，要注意，发送方每收到一个确认报文段，cwnd+1（不包括缺失重传的确认），也就是说，每经过一个传输伦次（RTT时间），cwnd加倍。初始值为1。</p>
<p><strong>拥塞避免</strong>：设置一个窗口值，大于时采用拥塞避免，让拥塞窗口cwnd缓慢增大，每经过一个往返时间RTT就把发送的cwnd+1</p>
<p><strong>快重传与快恢复</strong>：当接收方收到了一个失序的报文，马上报告给发送方，我没收到，赶紧重传（<strong>天下武功唯快不破</strong>），假如M2收到了，M3没有收到，之后的M4,M5,M6又发送了，此时接收方一共连续给发送方反馈了4个M2确认报文。那么快重传规定，发送方只要连续收到3个重复确认，立即重传对方发来的M3</p>
<p><strong>ARQ协议</strong></p>
<p>自动重传请求。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ协议包括停止等待ARQ和连续ARQ协议。</p>
<p><strong>停止等待ARQ</strong></p>
<ul>
<li>停止等待ARQ协议是为了实现可靠传输的，他的基本原理就是每发完一个分组就停止发送，等待对方确认，通过ack，如果过了一段时间，还是没有收到ack确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</li>
<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</li>
</ul>
<p><strong>连续ARQ协议</strong></p>
<p>连续ARQ协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明这个分组为止的所有分组都已经正确收到了。</p>
<p>优点：信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p>缺点：不能向发送方反映出已经正确收到的所有分组的信息。</p>
<h4 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h4><p>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
<p>出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。</p>
<p><strong>出现原因</strong></p>
<ul>
<li>发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。</li>
<li>接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。</li>
</ul>
<p>粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。</p>
<p>不是所有的粘包现象都需要处理，若传输的数据为不带结构的连续流数据（如文件传输），则不必把粘连的包分开（简称分包）。但在实际工程应用中，传输的数据一般为带结构的数据，这时就需要做分包处理。</p>
<p>在处理定长结构数据的粘包问题时，分包算法比较简单；在处理不定长结构数据的粘包问题时，分包算法就比较复杂。特别是粘在一起的包有不完整的包的粘包情况，由于一包数据内容被分在了两个连续的接收包中，处理起来难度较大。实际工程应用中应尽量避免出现粘包现象。</p>
<p>为了避免粘包现象，可采取以下几种措施：</p>
<p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</p>
<p>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；</p>
<p>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。</p>
<p>以上提到的三种措施，都有其不足之处。</p>
<p>（1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</p>
<p>（2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</p>
<p>（3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</p>
<p>一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开</p>
<h3 id="SYN-攻击"><a href="#SYN-攻击" class="headerlink" title="SYN 攻击"></a>SYN 攻击</h3><p>SYN攻击属于<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://baike.baidu.com/view/365.htm">DoS</a>攻击的一种，它利用<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://baike.baidu.com/view/1240122.htm">TCP协议</a>缺陷，通过发送大量的半连接请求，耗费<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://baike.baidu.com/view/2089.htm">CPU</a>和<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://baike.baidu.com/view/1082.htm">内存</a>资源。</p>
<p>TCP三次握手的第二次握手时服务器接收到连接请求（syn= j），将此信息加入未连接队列，并发送请求包给客户（syn=k,ack=j+1），此时进入SYN_RECV状态。当服务器未收到客户端的确认包时，重发请求包，一直到超时或半连接数量超过半连接队列的最大值时，将此条目从未连接队列删除。<br> SYN攻击利用TCP协议三次握手的原理，大量发送伪造源IP的SYN包也就是<strong>伪造第一次握手数据包</strong>，服务器每接收到一个SYN包就会为这个连接信息分配核心内存并放入半连接队列，如果短时间内接收到的SYN太多，半连接队列就会溢出，操作系统会把这个连接信息丢弃造成不能连接，当攻击的SYN包超过半连接队列的最大值时，正常的客户发送SYN数据包请求连接就会被服务器丢弃。目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。每种操作系统半连接队列大小（Backlog参数）不一样所以抵御SYN攻击的能力也不一样。</p>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>　　这是为了实现以上的通信过程而建立成来的通信管道，其真实的代表是客户端和服务器端的一个通信进程，双方进程通过socket进行通信，而通信的规则采用指定的协议。</p>
<p>　　socket只是一种连接模式，不是协议，socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API）。</p>
<p>　　通过Socket，我们才能使用TCP/IP协议。tcp、udp，简单的说（虽然不准确）是两个最基本的协议。</p>
<p>　　很多其它协议都是基于这两个协议。如http就是基于tcp的，用socket可以创建tcp连接，也可以创建udp连接。</p>
<p>　　这意味着，用socket可以创建任何协议的连接，因为其它协议都是基于此的。</p>
<p>　　一个Socket实例由一个IP地址和一个端口号唯一确定。<br>　　Socket是一种用于网络通信的低层开发接口，借助于通信两端的应用程序(实际上是Socket)可以利用输入输出流完成数据交换。</p>
<p><strong>Socket 传输的优点</strong><br>　　1) 传输数据为字节级，传输数据可自定义，数据量小（对于手机应用讲：费用低）；<br>　　2）传输数据时间短，性能高；<br>　　　　　　　　　　　　　　　　　　3）适合于客户端和服务器端之间信息实时交互；<br>　　　　　　　　　　　　　　　　　　4）可以加密,数据安全性强。 </p>
<p><strong>Socket 传输的缺点</strong><br>　　1）需对传输的数据进行解析，转化成应用级的数据；<br>　　2）对开发人员的开发水平要求高；<br>　　3）相对于Http协议传输，增加了开发量</p>
<p>基于Socket传输的特点：Socket 传输方式适合于对传输速度，安全性，实时交互，费用等要求高的应用中，如网络游戏，手机应用，银行内部交互等‘’。</p>
<h2 id="Mysql数据库知识点"><a href="#Mysql数据库知识点" class="headerlink" title="Mysql数据库知识点"></a>Mysql数据库知识点</h2><h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><ol>
<li>第一范式：列不可分</li>
<li>第二范式：要有主键</li>
<li>第三范式：不可存在传递依赖，你如商品表里面关联商类别表，那么只需要一个关联字段peoduct_type_name,那就属于存在传递依赖的情况，第三范式主要是从空间的角度来考虑，避免产生冗余信息，浪费磁盘空间</li>
</ol>
<h3 id="两种存储引擎"><a href="#两种存储引擎" class="headerlink" title="两种存储引擎"></a>两种存储引擎</h3><p>MyISAM是MySql的默认数据库引擎，虽然性能极佳，而且提高了大量的特性，包括全文索引，压缩，空间函数等。但MyISAM不支持事务和行级锁，而且做大的缺陷是崩溃后无法安全恢复。</p>
<p>InnoDB 和 MyISAM</p>
<ul>
<li>InnoDB<strong>支持事务</strong>，可以进行Commit和Rollback；</li>
<li>MyISAM 只支持表级锁，而 InnoDB 还<strong>支持行级锁</strong>，提高了并发操作的性能；</li>
<li>InnoDB <strong>支持外键</strong>；</li>
<li>MyISAM <strong>崩溃</strong>后发生损坏的概率比 InnoDB 高很多，而且<strong>恢复的速度</strong>也更慢；</li>
<li>MyISAM 支持<strong>压缩</strong>表和空间数据索引，InnoDB需要更多的内存和存储；</li>
<li>InnoDB 支持在线<strong>热备份</strong></li>
<li>MVCC:InnodDB支持。</li>
</ul>
<p><strong>MyISAM</strong> 管理非事务表。它提供高速存储和检索（MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的SELECT），还是可以使用MyISAM；</p>
<p><strong>InnoDB</strong> 支持事务，并发情况下有很好的性能，基本可以替代MyISAM</p>
<h3 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h3><p>1.客户端发送一条查询给服务器</p>
<p>2.服务器先检查<strong>查询缓存</strong>(见下面注释),如果命中了缓存,则立刻返回存储在缓存中的结果.否则,进入下一个阶段</p>
<p>3.服务器进行SQL解析.预处理,再由优化器生成对应的执行计划.</p>
<p>4.MySQL根据优化器生成的执行计划,调用存储引擎的API来执行查询.</p>
<p>5.将结果返回给客户端</p>
<p>注释</p>
<p><strong>查询缓存</strong></p>
<p>在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希查找实现的。查询和缓存中的查询即使只有一个字节不同，那也不会匹配缓存结果，这种情况查询会进入下一个阶段的处理。<br>如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前MySQL会检查一次用户权限。这仍然是无须解析查询SQL语句的，因为在查询缓存中已经存放了当前查询需要访问的表信息。如果权限没有问题，MySQL会跳过所有其他阶段，直接从缓存中拿到结果并返回给客户端。这种情况下，查询不会被解析，不用生成执行计划，不会被执行。</p>
<h3 id="事务的特点-ACID"><a href="#事务的特点-ACID" class="headerlink" title="事务的特点 ACID"></a>事务的特点 ACID</h3><p>ACID</p>
<ul>
<li>原子性：事务是数据库的逻辑工作单位，事务中包含的各操作要么完成，要么都不完成</li>
<li>一致性：事务一致性是指数据库中的数据在事务操作前后都必须要满足业务规则约束  转账前后总金额应该是一样的</li>
<li>隔离性：一个事务的执行不能被其他事务干扰。即一个事务内部的操作以及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰</li>
<li>持久性：事务一旦提交，结果便是永久性的，及时发生宕机，仍然可以依靠事务日志完成数据的持久化工作</li>
</ul>
<p><strong>事务的原子性是通过undo log来实现的</strong>(undo log通过记录被修改前的数据的回滚日志，每条数据变更操作都伴随一条undo log的生成，并且回滚日志必须先于数据持久化到磁盘上)</p>
<p><strong>事务的持久性是通过redo log来实现的</strong></p>
<p>​            先了解一下MySQL的数据存储机制，MySQL的表数据是存放在磁盘上的，因此想要存取的时候都要经历磁盘IO,然而即使是使用SSD磁盘IO也是非常消耗性能的。</p>
<p>为此，为了提升性能InnoDB提供了缓冲池(Buffer Pool)，Buffer Pool中包含了磁盘数据页的映射，可以当做缓存来使用：</p>
<ul>
<li><p>读数据：会首先从缓冲池中读取，如果缓冲池中没有，则从磁盘读取在放入缓冲池；</p>
</li>
<li><p>写数据：会首先写入缓冲池，缓冲池中的数据会定期同步到磁盘中；</p>
</li>
</ul>
<p>上面这种缓冲池的措施虽然在性能方面带来了质的飞跃，但是它也带来了新的问题，当MySQL系统宕机，断电的时候可能会丢数据！！！因为我们的数据已经提交了，但此时是在缓冲池里头，还没来得及在磁盘持久化，所以我们急需一种机制需要存一下已提交事务的数据，为恢复数据使用。于是 redo log就派上用场了，redo log会记录操作的动作</p>
<ul>
<li>redo log 的存储是顺序存储，而缓存同步是随机操作。</li>
<li>缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。</li>
<li>redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据</li>
</ul>
<p><strong>事务的隔离性是通过(读写锁+MVCC来实现的)</strong></p>
<p><strong>事务的一致性是通过原子性+持久性+隔离性来实现的</strong></p>
<h3 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a><strong>事务的并发问题</strong></h3><p>　　<strong>1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</strong></p>
<p>　　<strong>2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</strong></p>
<p>　　<strong>3、幻读：在同一事务内查询返回不同的结果集合。一般是由于其他事务插入并提交了一些记录造成的在一个事务中使用相同的 SQL 两次读取，第二次读取到了其他事务新插入的行。幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</strong></p>
<p>​       <strong>4、丢失修改：是指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据，这样第一个事务内的修改的结果就被丢失了</strong></p>
<p>　　<strong>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</strong></p>
<p><strong>不可重复读和幻读区别：</strong></p>
<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>InnoDB默认是可重复读</p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交 read-uncommitted</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读read-committed 读提交</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读 repeatable-read</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化serializable 序列化</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<ul>
<li><p>MySQL的可重复读底层是怎么实现的:MVCC</p>
</li>
<li><p><strong>读未提交</strong>，顾名思义，就是一个事务可以读取另一个未提交事务的数据。</p>
<p>事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。</p>
<p>　　分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。因此，在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。如无特殊情况，基本是不会使用这种隔离级别的。</p>
<p>　　那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。</p>
</li>
<li><p><strong>读提交，</strong>顾名思义，就是只能读到已经提交了的内容</p>
<p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p>
<p>　　分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。</p>
<p>  　这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的避免脏读，但除非在查询中显示的加锁，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>

<p>　　不然，普通的查询是不会加锁的。</p>
<p>　　那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢？</p>
<p>　　这就要说道另一个机制“快照（snapshot）”，而这种既能保证一致性又不加锁的读也被称为“快照读（Snapshot Read）”</p>
<p>　　假设没有“快照读”，那么当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞（因为上了X锁，即写锁，所以不能得到S锁，即读锁），这种情况下，并发能力就相当的差。而“快照读”就可以完成高并发的查询，不过，“读提交”只能避免“脏读”，并不能避免“不可重复读”和“幻读”。</p>
</li>
<li><p><strong>可重复读</strong>，对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</p>
<p>顾名思义，就是专门针对“不可重复读”这种情况而制定的隔离级别，自然，它就可以有效的避免“不可重复读”。<strong>而它也是MySql的默认隔离级别。</strong></p>
<p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p>
<p>　　分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。</p>
<p>　　在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时，就不允许进行“修改操作（Update）”了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的。</p>
<p>　　那怎么解决幻读问题？Serializable！</p>
</li>
<li><p><strong>串行化</strong> 这是数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行。这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。</p>
</li>
</ul>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>间隙锁（Gap Lock）是Innodb在可重复读提交下为了解决幻读问题时引入的锁机制，（下面的所有案例没有特意强调都使用可重复读隔离级别）幻读的问题存在是因为新增或者更新操作，这时如果进行范围查询的时候（加锁查询），会出现不一致的问题，这时使用不同的行锁已经没有办法满足要求，需要对一定范围内的数据进行加锁，间隙锁就是解决这类问题的。在可重复读隔离级别下，数据库是通过行锁和间隙锁共同组成的（next-key lock），来实现的</p>
<p>加锁规则有以下特性，我们会在后面的案例中逐一解释：</p>
<ul>
<li>1.加锁的基本单位是（next-key lock）,他是前开后闭原则</li>
<li>2.插叙过程中访问的对象会增加锁</li>
<li>3.索引上的等值查询–给唯一索引加锁的时候，next-key lock升级为行锁</li>
<li>4.索引上的等值查询–向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁</li>
<li>5.唯一索引上的范围查询会访问到不满足条件的第一个值为止</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>MVCC是多版本并发控制机制，顾名思义支持MVCC的数据库表中每一行数据都可能存在多个版本，对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，通过读写数据时读不同的版本来避免加锁阻塞。</p>
<p>MVCC的实现主要依赖于数据库在每个表中添加的三个隐藏字段以及事务在查询时创建的快照（read view）和数据库的数据版本链(Undo log)。这里先介绍这三个部分的作用，然后再介绍它们是如何联合作战进行非阻塞的实现RC和RR隔离级别。</p>
<p>MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突</p>
<p>MVCC的重要特性:<br>(1)MVCC只支持RC(读取已提交)和RR(可重复读)隔离级别。<br>(2)MVCC能解决脏读、不可重复读问题，不能解决丢失更新问题和幻读问题。<br>(3)MVCC是用来解决读写操作之间的阻塞问题。使得在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能。</p>
<p><strong>总结</strong></p>
<p>1、MVCC的实现主要依赖于数据库在每个表中添加的三个隐藏字段以及事务在查询时创建的快照（read view）和数据库支持多版本数据，数据库中存在数据版本链(Undo log)。<br>2、InnoDB支持多版本数据，在更新或者删除数据时，并不会立马删除原有行记录，而是将旧版本存入回滚段中的Undo log内，并通过回滚指针形成一个数据链，可以通过这个指针访问链上的历代数据版本，正是这种机制使得数据库数据产生了多个版本，为通过MVCC进行快照读提供了可能。<br>3、并不是所有的查询都是进行快照读，使用普通的select 语句进行查询时会生成快照，进行快照读；使用select … lock in share mode，select … for update，insert，update，delete 语句等语句进行查询或者更新时还是会使用锁机制，进行锁阻塞。<br>4、使用MVCC的作用(意义)是非阻塞的解决了事务读写冲突，提高了并发性能。<br>5、MVCC只支持RC(读取已提交)和RR(可重复读)隔离级别。<br>6、MVCC能解决脏读、不可重复读问题，不能解决丢失更新问题和幻读问题。<br>7、InnoDB使用锁机制和MVCC来共同作用，进行并发控制的，虽然MVCC不能解决幻读和丢失更新问题，但通过与锁机制(行级锁的Next-Key Locks算法的使用、排他锁等）一起作用可以达到可串行化隔离级别的效果，禁止了幻读、更新丢失等问题。</p>
<h3 id="MySql如何解决幻读"><a href="#MySql如何解决幻读" class="headerlink" title="MySql如何解决幻读"></a>MySql如何解决幻读</h3><p>为什么需要解决幻读？ 高并发数据库系统中，需要保证事务与事务之间的隔离性和数据本身的一致性。</p>
<h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><ul>
<li>事务在读操作时，先加表级别的共享锁，直到事务结束才释放</li>
<li>事务在写操作时，先加表级别的排它锁，直到事务结束才释放</li>
</ul>
<h4 id="MVCC-快照读-一致性读"><a href="#MVCC-快照读-一致性读" class="headerlink" title="MVCC(快照读/一致性读)"></a>MVCC(快照读/一致性读)</h4><p>因为MySQL默认的隔离级别是<strong>可重复读</strong>，这种隔离级别下，我们普通的SELECT语句都是快照读，也就是在一个事务内，多次执行SELECT语句，查询到的数据都是事务开始时那个状态的数据（这样就不会受其他事务修改数据的影响），这样就解决了幻读的问题。</p>
<p>多数数据库都实现了多版本并发控制，并且都是靠保存数据快照来实现的。</p>
<p>以 <code>InnoDB</code> 为例。可以理解为每一行中都冗余了两个字段，一个是行的创建版本，一个是行的删除（过期）版本。</p>
<p>具体的版本号（trx_id）存在 <code>information_schema.INNODB_TRX</code> 表中。版本号（trx_id）随着每次事务的开启自增。</p>
<p>事务每次取数据的时候都会取创建版本小于当前事务版本的数据，以及过期版本大于当前版本的数据。</p>
<p>InnoDB 的 MVCC， 是 通过 在 每 行 记录 后面 保存 两个 隐藏 的 列 来 实现 的。 这 两个 列， 一个 保存 了 行的 创建 时间， 一个 保存 行的 过期 时间（ 或 删除 时间）。 当然 存储 的 并不是 实际 的 时间 值， 而是 系统 版 本号（ system version number）。 每 开始 一个 新的 事务， 系统 版本 号 都会 自动 递增。 事务 开始时 刻 的 系统 版 本号 会 作为 事务 的 版 本号， 用来 和 查询 到 的 每 行 记录 的 版本 号 进行 比较。</p>
<p>MVCC 只在 REPEATABLE READ 和 READ COMMITTED 两个 隔离 级别 下 工作。</p>
<p>MVCC快照读需满足条件：</p>
<ol>
<li>InnoDB 只 查找 版本 早于 当前 事务 版本 的 数据 行（ 也就是， 行的系统版本号小于或等于事务的系统版本号 这样可以确保事务读 取的行 要么是在事务开始前已经存在的， 要么是事务自身插入或者修改过的。</li>
<li>行的删除版本要么未定义， 要么大于当前事务版本号。 这可以确保事务读取到的行 在事务开始之前未被删除。</li>
</ol>
<p>MVCC <strong>解决了基于快照读下的幻读</strong>，但是无法解决当前读下的幻读。</p>
<h4 id="实时读"><a href="#实时读" class="headerlink" title="实时读"></a>实时读</h4><p>Next-key锁，包含两部分，记录锁(行锁), 间隙锁。</p>
<p>记录锁是加在索引上的锁，间隙锁是加在索引之间的锁</p>
<p>如果说快照读总是读取事务开始时那个状态的数据，实时读就是查询时总是执行这个查询时数据库中的数据。</p>
<p>一般使用以下这两种查询语句进行查询时就是实时读。</p>
<p>for update：IX锁(意向排它锁)，即在符合条件的rows上都加了排它锁</p>
<p>lock in share mode：是IS锁(意向共享锁)，即在符合条件的rows上都加了共享锁</p>
<p> 排它锁：X锁、 写锁，事务A对一个资源加了X锁后只有A本身能对该资源进行读和写操作，其他事务对该资源的读和写操作都将被阻塞，直到A释放锁为止 </p>
<p>共享锁：S锁、 读锁， 事务A锁定的数据其他事务可以共享读该资源，但不能写，直到事务A释放</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT *** FOR UPDATE 在查询时会先申请X锁</span><br><span class="line">SELECT *** IN SHARE MODE 在查询时会先申请S锁</span><br><span class="line"></span><br><span class="line">select * from tb where id&gt;100 for update</span><br><span class="line"></span><br><span class="line">#主键索引id 会给id =100 的记录加上行锁</span><br><span class="line"># 索引id会加上gap锁，锁住id(100 , 无穷大)这个范围 其他事务对id&gt;100的范围的记录读和写操作都会被阻塞，插入id=1000时，会命中索引加上的锁会报出事务异常</span><br></pre></td></tr></table></figure>

<h3 id="锁机制与InnoDB锁算法"><a href="#锁机制与InnoDB锁算法" class="headerlink" title="锁机制与InnoDB锁算法"></a>锁机制与InnoDB锁算法</h3><ul>
<li>InnoDB 支持行级锁和表级锁，默认是行级锁</li>
<li>MyISAM采用表级锁</li>
</ul>
<p>表级锁与行级锁的对比：</p>
<ul>
<li>表级锁：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁</li>
<li>行级锁：MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。</li>
</ul>
<p><strong>InnoDB存储引擎的锁的算法有三种</strong></p>
<ul>
<li>Record lock:单个行记录上的锁</li>
<li>Gap lock:间隙锁 锁定一个范围，不包括记录本身</li>
<li>Next-key lock:record + gap 锁定一个范围，包含记录本身</li>
</ul>
<h3 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h3><p>当MySQL单表记录数过大的时候，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<ul>
<li>限定数据的范围，查询的时候添加范围，例如时间范围等</li>
<li>读/写分离，经典的数据库拆分方案，主库负责写，从库负责读</li>
<li>垂直分区：根据数据库里面数据表的相关性进行拆分，简单来说就是数据表列的拆分，把一张比较多的表拆分为多张表</li>
<li>水平分区：保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。</li>
</ul>
<h3 id="池化设计思想，数据库连接池"><a href="#池化设计思想，数据库连接池" class="headerlink" title="池化设计思想，数据库连接池"></a>池化设计思想，数据库连接池</h3><p>这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。除了初始化资源，池化设计还包括了如下特征：池子的初始值，池子的活跃值，池子的最大值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。</p>
<p>数据库连接本质就是一个socket的连接。数据库服务端还要维护一些缓存和用户权限信息之类的所以占用了一些内存。在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中。</p>
<h3 id="mysql联合索引详解"><a href="#mysql联合索引详解" class="headerlink" title="mysql联合索引详解"></a>mysql联合索引详解</h3><p>联合索引又叫复合索引。对于复合索引：Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index （a,b,c）。 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</p>
<p>  两个或更多个列上的索引被称作复合索引。</p>
<p>  利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。</p>
<p>  所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。</p>
<h3 id="慢查询优化-explain"><a href="#慢查询优化-explain" class="headerlink" title="慢查询优化 explain"></a>慢查询优化 explain</h3><p><strong>分析慢查询日记</strong></p>
<p>直接分析mysql慢查询日志 ,利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句</p>
<p>   例如：执行EXPLAIN SELECT * FROM res_user ORDER BYmodifiedtime LIMIT 0,1000</p>
<p>​    得到如下结果： 显示结果分析：  </p>
<p>​          table | type | possible_keys | key |key_len | ref | rows | Extra EXPLAIN列的解释：      </p>
<p>​          table         显示这一行的数据是关于哪张表的      </p>
<p>​           type         这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL </p>
<p>​           rows        显示需要扫描行数</p>
<p>​           key          使用的索引</p>
<p><strong>常见的慢查询优化</strong></p>
<p> （1）索引没起作用的情况</p>
<p>​     1. 使用LIKE关键字的查询语句</p>
<p>​        在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置索引才会起作用。</p>
<p>​     2. 使用多列索引的查询语句</p>
<p>​        MySQL可以为多个字段创建索引。一个索引最多可以包括16个字段。对于多列索引，只有查询条件使用了这些字段中的第一个字段时，索引才会被使用。</p>
<p> （2）优化数据库结构</p>
<p>​       合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p>
<p>​     1. 将字段很多的表分解成多个表 </p>
<p>​        对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p>
<p>​     2. 增加中间表</p>
<p>​        对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。</p>
<p> （3）分解关联查询</p>
<p>​     将一个大的查询分解为多个小查询是很有必要的。</p>
<p>​     很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效</p>
<p>（4）优化LIMIT分页</p>
<p>​     在系统中需要分页的操作通常会使用limit加上偏移量的方法实现，同时加上合适的order by 子句。如果有对应的索引，通常效率会不错，否则MySQL需要做大量的文件排序操作。</p>
<p>​     一个非常令人头疼问题就是当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。</p>
<p>​     优化此类查询的一个最简单的方法是尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。</p>
<p>​     对于下面的查询：</p>
<p>​     select id,title from collect limit 90000,10;</p>
<p>​     该语句存在的最大问题在于limit M,N中偏移量M太大（我们暂不考虑筛选字段上要不要添加索引的影响），导致每次查询都要先从整个表中找到满足条件 的前M条记录， 之后舍弃这M条记录并从第M+1条记录开始再依次找到N条满足条件的记录。</p>
<p>​     如果表非常大，且筛选字段没有合适的索引，且M特别大那么这样的代价是非常高的。 试想，如我们下一次的查询能从前一次查询结束后标记的位置开始查找，找到满足条件的100条记录，并记下下一次查询应该开始的位置，以便于下一次查询能直接从该位置 开始，这样就不必每次 查询都先从整个表中先找到满足条件的前M条记录，舍弃，在从M+1开始再找到100条满足条件的记录了。</p>
<p>​     方法一：考虑筛选字段（title）上加索引<br>​            title字段加索引 （此效率如何未加验证）</p>
<p>​     方法二：先查询出主键id值</p>
<p>​           select id,title from collect where id&gt;=(select id from collect order by id limit 90000,1) limit 10;</p>
<p>​           原理：先查询出90000条数据对应的主键id的值，然后直接通过该id的值直接查询该id后面的数据。</p>
<p>​      方法三：“关延迟联”<br>​            如果这个表非常大，那么这个查询可以改写成如下的方式：</p>
<p>​            Select news.id, news.description from news inner join (select id from news order by title limit 50000,5) as myNew using(id);</p>
<p>​            这里的“关延迟联”将大大提升查询的效率，它让MySQL扫描尽可能少的页面，获取需要的记录后再根据关联列回原表查询需要的所有列。这个技术也可以用在优化关联查询中的limit。</p>
<p>​      方法四：建立复合索引 acct_id和create_time</p>
<p>​            select * from acct_trans_log WHERE  acct_id = 3095  order by create_time desc limit 0,10</p>
<p>​           注意sql查询慢的原因都是:引起filesort</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><ul>
<li>文档(Document)：一般搜索引擎的处理对象是互联网网页，而文档这个概念要更宽泛些，代表以文本形式存在的存储对象，相比网页来说，涵盖更多种形式，比如Word，PDF，html，XML等不同格式的文件都可以称之为文档。再比如一封邮件，一条短信，一条微博也可以称之为文档。在本书后续内容，很多情况下会使用文档来表征文本信息。</li>
<li>文档集合(Document Collection)：由若干文档构成的集合称之为文档集合。比如海量的互联网网页或者说大量的电子邮件都是文档集合的具体例子。</li>
<li>文档编号(Document ID)：在搜索引擎内部，会将文档集合内每个文档赋予一个唯一的内部编号，以此编号来作为这个文档的唯一标识，这样方便内部处理，每个文档的内部编号即称之为“文档编号”，后文有时会用DocID来便捷地代表文档编号。</li>
<li>单词编号(Word ID)：与文档编号类似，搜索引擎内部以唯一的编号来表征某个单词，单词编号可以作为某个单词的唯一表征。</li>
<li>倒排索引(Inverted Index)：倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。</li>
<li>单词词典(Lexicon)：搜索引擎的通常索引单位是单词，单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。</li>
<li>倒排列表(PostingList)：倒排列表记载了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。</li>
<li>倒排文件(Inverted File)：所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件即被称之为倒排文件，倒排文件是存储倒排索引的物理文件。</li>
</ul>
<h3 id="Mysql索引实现（B-B树）"><a href="#Mysql索引实现（B-B树）" class="headerlink" title="Mysql索引实现（B+ B树）"></a>Mysql索引实现（B+ B树）</h3><h4 id="索引定义"><a href="#索引定义" class="headerlink" title="索引定义"></a>索引定义</h4><p>数据库索引：索引是对数据库中的一个或多个列的值进行排序的数据结构，以协助快速查询，更新数据库表中的数据</p>
<p>MYSQL索引使用的数据结构主要是BTree索引和哈希索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能高，其余情况建议使用BTree索引。</p>
<p>B-tree，B是balance，一般用于<strong>数据库的索引</strong>。使用B-tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。而B+tree是B-tree的一个变种，MySQL就普遍使用B+tree实现其索引结构。　　</p>
<p>　　一般来说，索引本身也很大，不可能全部存储在内存中，因此<strong>索引往往以索引文件的形式存储的磁盘上</strong>。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</p>
<p>　　为了达到这个目的，磁盘按需读取，要求每次都会预读的长度一般为页的整数倍。而且数据库系统将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。并把B-tree中的m值设的非常大，就会让树的高度降低，有利于一次完全载入</p>
<p>InnoDB:在根据主索引搜索时，直接找到key所在的节点即可取出数据，在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</p>
<p><strong>聚集索引：</strong></p>
<p>　　该索引中键值的<strong>逻辑顺序决定了表中相应行的物理顺序</strong>。 </p>
<p>　　聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。 </p>
<p><strong>非聚集索引：</strong>　　</p>
<p>　　该索引中索引的<strong>逻辑顺序与磁盘上行的物理存储顺序不同</strong>。 </p>
<p>　　索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</p>
<h4 id="哪些情况下索引会失效？"><a href="#哪些情况下索引会失效？" class="headerlink" title="哪些情况下索引会失效？"></a>哪些情况下索引会失效？</h4><ul>
<li>以“%(表示任意0个或多个字符)”开头的LIKE语句；</li>
<li>OR语句前后没有同时使用索引；</li>
<li>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；</li>
<li>对于多列索引，必须满足 <strong>最左匹配原则</strong>/最左前缀原则 (最左优先，eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)；</li>
<li>如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）</li>
</ul>
<h4 id="在哪些地方适合创建索引？"><a href="#在哪些地方适合创建索引？" class="headerlink" title="在哪些地方适合创建索引？"></a>在哪些地方适合创建索引？</h4><ul>
<li>某列经常作为最大最小值；</li>
<li>经常被查询的字段；</li>
<li>经常用作表连接的字段；</li>
<li>经常出现在ORDER BY/GROUP BY/DISDINCT后面的字段 即 分组，排序，联合操作的字段建立索引</li>
<li>选择唯一性索引</li>
<li>限制索引的数目，每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间越大</li>
<li>尽量使用数据量少的索引，例如，对一个CHAR(100)类型的字段进行全文检索需要的时间肯定要比对CHAR(10)类型的字段需要的时间要多。</li>
</ul>
<h4 id="聚集索引-非聚集索引"><a href="#聚集索引-非聚集索引" class="headerlink" title="聚集索引 非聚集索引"></a>聚集索引 非聚集索引</h4><p>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块</p>
<p>区别：</p>
<ul>
<li><p>聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个</p>
</li>
<li><p>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续</p>
</li>
<li><p>聚集索引:物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序。</p>
</li>
<li><p>非聚集索引:物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序。</p>
</li>
<li><p>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</p>
</li>
</ul>
<p>优势与缺点：</p>
<p>聚集索引插入数据时速度要慢（时间花费在“物理存储的排序”上，也就是首先要找到位置然后插入），查询数据比非聚集数据的速度快</p>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p><strong>juhB-树有如下特点:B-树允许每个节点有更多的子节点即可（多叉树）</strong></p>
<ol>
<li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</li>
<li>在关键字全集内做一次查找,性能逼近二分查找；</li>
</ol>
<p><strong>B+树是B-树的变体，也是一种多路搜索树, 它与 B- 树的不同之处在于:</strong></p>
<ol>
<li>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)</li>
<li>为所有叶子结点增加了一个链指针</li>
<li>B+树是一个平衡的多叉树，从根节点到每个叶子节点的<strong>高度差值不超过1</strong>，而且<strong>同层级</strong>的节点间有指针相互链接。</li>
</ol>
<h4 id="为什么用B-树"><a href="#为什么用B-树" class="headerlink" title="为什么用B+树"></a>为什么用B+树</h4><ul>
<li>相对于b树/二叉树来说,B树每个节点能存储的节点数更多，<strong>层级更低</strong>。</li>
<li>相对于b树来说,每次查询是一定要到叶子节点，<strong>查询就更稳定</strong></li>
<li>相对于b树/二叉树/Hash来说,叶子节点有双向链表，便于<strong>范围查询</strong>。</li>
<li>哈希索引在<strong>等值查询</strong>上有绝对优势，但是无法<strong>范围查询</strong>，无法用于<strong>排序</strong>，不支持最左前缀匹配原则（必须全部match）</li>
</ul>
<h4 id="B-树和B-树的区别"><a href="#B-树和B-树的区别" class="headerlink" title="B-树和B+树的区别"></a>B-树和B+树的区别</h4><p>   1.B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。</p>
<ol start="2">
<li>B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。</li>
<li>B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确，那么由于磁盘 IO 数据大小是固定的，在一次 IO 中，单个元素越小，量就越大。这就意味着B+树单次磁盘 IO 的信息量大于B-树</li>
<li></li>
</ol>
<h3 id="Hash索引-b-树索引"><a href="#Hash索引-b-树索引" class="headerlink" title="Hash索引 b+树索引"></a>Hash索引 b+树索引</h3><p><strong>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。</strong></p>
<p>在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。</p>
<p>因此，B+树索引被广泛应用于数据库、文件系统等场景。顺便说一下，xfs文件系统比ext3/ext4效率高很多的原因之一就是，它的文件及目录索引结构全部采用B+树索引，而ext3/ext4的文件目录结构则采用Linked list, hashed B-tree、Extents/Bitmap等索引数据结构，因此在高I/O压力下，其IOPS能力不如xfs。</p>
<p>简单地说，<strong>哈希索引就是采用一定的哈希算法</strong>，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。</p>
<p>从上面的图来看，B+树索引和哈希索引的明显区别是：</p>
<ul>
<li><strong>如果是等值查询，那么哈希索引明显有绝对优势</strong>，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</li>
<li>从示意图中也能看到，<strong>如果是范围查询检索，这时候哈希索引就毫无用武之地了</strong>，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</li>
<li>同理，<strong>哈希索引也没办法利用索引完成排序</strong>，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</li>
<li><strong>哈希索引也不支持多列联合索引的最左匹配规则</strong>；</li>
<li>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，<strong>在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题</strong>。</li>
</ul>
<p>在MySQL中，只有HEAP/MEMORY引擎表才能显式支持哈希索引（NDB也支持，但这个不常用），InnoDB引擎的自适应哈希索引（adaptive hash index）不在此列，因为这不是创建索引时可指定的。</p>
<p>还需要注意到：HEAP/MEMORY引擎表在mysql实例重启后，数据会丢失。</p>
<p>通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：</p>
<blockquote>
<p>在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引</p>
<p>例如这种SQL：<br>SELECT … FROM t WHERE C1 = ?; — 仅等值查询</p>
</blockquote>
<p>在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p> R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p>
<p><strong>红黑树的特性</strong>:<br><strong>（1）每个节点或者是黑色，或者是红色。</strong><br><strong>（2）根节点是黑色。</strong><br><strong>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！</strong><br><strong>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</strong><br><strong>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</strong></p>
<p>红黑树的查找时间复杂度O(logn)</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>在MySQL中，为了应对并发场景下的读写，锁通常分为两类：共享锁以及排他锁。其中，共享锁允许多个连接在同一时间并发的读取相同的资源，彼此之间互不影响,所以又称为读锁。排他锁则会阻塞其他尝试获取共享锁或者排他锁的操作，确保同一时间只有一个连接可以写入数据，并禁止其他用户的读写，又称写锁。</p>
<p>在实际使用下，加锁往往意味着高昂的开销，MySQL为了平衡锁的开销以及并发的线程之间的安全，采用了两种不同的锁策略：</p>
<ul>
<li><strong>table lock(表锁)</strong></li>
</ul>
<p>表锁会锁定整张表，如果当前有用户正在执行写操作并且获取了写锁，这可能导致整张表被锁定，阻塞其他用户的读写操作。如果用户执行的是读操作，则会获取读锁，此时其他用户的并发读操作将被接受，写操作会被阻塞。</p>
<p>举个例子，执行语句: </p>
<p>update table set a = 1 where b =2;</p>
<ul>
<li><strong>row lock(行锁)</strong></li>
</ul>
<p>行锁的粒度是在每一条行数据，这意味行锁可以尽可能的支持并发处理，相应的行锁开销也会比较大。并且，<strong>在InnoDB中的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则行锁将会自动升级为表锁</strong>。</p>
<p>相比较而言，表锁的优势在于开销小，加锁快，无死锁，劣势是锁的粒度大，发生锁冲突的概率较高，并发能力较弱。而行锁则相反。实际使用中，两者都会由MySQL自动加锁。行锁冲突可以通过执行 show status like ‘innodb_row_lock%’语句进行分析，表锁冲突则可通过执行show status like ‘table_locks%’ 进行查看。</p>
<h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><ul>
<li><p>悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于<strong>数据更新比较频繁</strong>的场景；</p>
</li>
<li><p>乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于</p>
<p>读多写少的场景。乐观锁的实现方式有：</p>
<ul>
<li>加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；</li>
</ul>
</li>
<li><p>先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新</p>
</li>
</ul>
<h3 id="Drop-Delete-Truncate"><a href="#Drop-Delete-Truncate" class="headerlink" title="Drop/Delete/Truncate"></a>Drop/Delete/Truncate</h3><ul>
<li><strong>Delete</strong>用来删除表的全部或者<strong>部分数据</strong>，执行delete之后，用户<strong>需要提交</strong>之后才会执行，会触发表上的DELETE<strong>触发器</strong>（包含一个OLD的虚拟表，可以只读访问被删除的数据），DELETE之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据；</li>
<li><strong>Truncate</strong>删除表中的所有数据，这个操作<strong>不能回滚</strong>，也不会触发这个表上的触发器。操作比DELETE快很多（直接把表drop掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为1；</li>
<li><strong>Drop</strong>命令从数据库中<strong>删除表</strong>，所有的数据行，索引和约束都会被删除；不能回滚，不会触发触发器；</li>
</ul>
<h3 id="视图-游标"><a href="#视图-游标" class="headerlink" title="视图 游标"></a>视图 游标</h3><ul>
<li><p>视图：从数据库的基本表中通过查询选取出来的数据组成的</p>
<p>虚拟表</p>
<p>（数据库中存放视图的定义）。可以对其进行增/删/改/查等操作。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；可以跟基本表一样，进行增删改查操作(ps:增删改操作有条件限制)；如连表查询产生的视图无法进行，对视图的增删改会影响原表的数据。好处：</p>
<ul>
<li>通过只给用户访问视图的权限，保证数据的<strong>安全性</strong>；</li>
<li><strong>简化</strong>复杂的SQL操作，隐藏数据的复杂性（比如复杂的连接）；</li>
</ul>
</li>
<li><p>游标（Cursor）：用于定位在查询返回的<strong>结果集的特定行</strong>，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。</p>
</li>
</ul>
<h3 id="Redo日志"><a href="#Redo日志" class="headerlink" title="Redo日志"></a>Redo日志</h3><p>MySQL的崩溃恢复crash_safe能力依赖于Redo Log事务日志。当MySQL更改数据的时候，它的设计思想是先对内存中的数据进行修改，并且写Redo Log，即更改数据，总是遵循WAL日志先行机制。</p>
<p>当MySQL更新数据的时候，其内部流程是怎么实现的呢？</p>
<p>假设我要执行一条SQL：update T set name = ‘winner’ where ID=2，那么内部执行流程为：</p>
<p>1、优化器找存储引擎取出ID=2这一行，如果ID=2这一行记录所在的数据页本身就在内存当中，那么就直接返回给执行器；否则需要从磁盘读取到内存当中，然后再返回给优化器；</p>
<p>2、优化器拿到行数据之后，会对内存中的数据页进行修改，同时将这个更新操作记录到Redo Log。此时Redo Log处于 perpare 状态，然后告知执行器已经完成了，可以随时提交事务；</p>
<p>3、接下来执行器会生成这个更新操作的binlog；</p>
<p>4、执行器调用存储引擎的提交事务的接口，将刚刚写入的Redo Log改成commit状态；</p>
<p><strong>为什么需要两阶段</strong></p>
<p>这里它的2阶段是对应于不同类型的日志，所以两阶段为的就是让这个2个不同的日志做好处理与准备。</p>
<p>1、假设是先写Redo Log，后写binlog。如果这个时候MySQL发生了进程的异常重启，由于Redo Log已经写完，MySQL崩溃之后通过crash_safe能力，能够把数据恢复回来。但是由于binlog还没写完就crash了，所以binlog里面并没有记录该SQL语句，所以使用binlog回档数据的时候，恢复出来的数据其实是少了一次更新操作的，这样就造成了灾难恢复出来的库和原库数据不一致；</p>
<p>2、假设是先写binlog，后写Redo Log。Binlog写完之后发生了crash，由于Redo Log还没有写，崩溃恢复之后这个事务的更新是无效的。但是binlog里面记录了这条更新的语句，所以使用binlog回档的时候就多了一条事务的更新。造成回档出来的数据和原库的数据不一致。</p>
<p><strong>那么两阶段提交就是：</strong></p>
<p>1、prepare阶段，写redo log；</p>
<p>2、commit阶段，写binlog并且将redo log的状态改成commit状态；</p>
<p>mysql发生崩溃恢复的过程中，会根据redo log日志，结合 binlog 记录来做事务回滚：</p>
<p>1、如果redo log 和 binlog都存在，逻辑上一致，那么提交事务；</p>
<p>2、如果redo log存在而binlog不存在，逻辑上不一致，那么回滚事务；</p>
<p>最后大家可发现，这里的两阶段提交，实际是存在与redo log与binlog。所以当未开启binlog，那就是提交事务直接写到redo log里面。这也就是redo log事务两阶段提交，看场景区分的原因。</p>
<p><strong>了解下redo log、bin log的区别:</strong></p>
<ul>
<li><p>Binlog是server层的日志，主要做mysql功能层面的事情</p>
</li>
<li><p>与redo日志的区别:</p>
<ul>
<li><p>redo是innodb独有的，binlog是所有引擎都可以使用的</p>
</li>
<li><p>redo是物理日志，记录的是在某个数据页上做了什么修改，binlog是逻</p>
<p>辑日志，记录的是这个语句的原始逻辑</p>
</li>
<li><p>redo是循环写的，空间会用完，binlog是可以追加写的，不会覆盖之前</p>
<p>的日志信息</p>
</li>
</ul>
</li>
</ul>
<p><strong>binlog</strong>：</p>
<ul>
<li><p>Binlog中会记录所有的逻辑，并且采用追加写的方式</p>
</li>
<li><p>一般在企业中数据库会有备份系统，可以定期执行备份，备份的</p>
<p>周期可以自己设置</p>
</li>
<li><p>恢复数据的过程：</p>
<p>– 1、找到最近一次的全量备份数据</p>
<p>– 2、从备份的时间点开始，将备份的binlog取出来，重放到要恢复的那个时</p>
<p>刻</p>
</li>
</ul>
<h3 id="与Redis的区别"><a href="#与Redis的区别" class="headerlink" title="与Redis的区别"></a>与Redis的区别</h3><p>1.mysql和redis的数据库类型</p>
<p>mysql是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。</p>
<p>redis是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限</p>
<p>2.mysql的运行机制</p>
<p>mysql作为持久化存储的关系型数据库，相对薄弱的地方在于每次请求访问数据库时，都存在着I/O操作，如果反复频繁的访问数据库。第一：会在反复链接数据库上花费大量时间，从而导致运行效率过慢；第二：反复的访问数据库也会导致数据库的负载过高，那么此时缓存的概念就衍生了出来。</p>
<p>3.缓存</p>
<p>缓存就是数据交换的缓冲区（cache），当浏览器执行请求时，首先会对在缓存中进行查找，如果存在，就获取；否则就访问数据库。</p>
<p>缓存的好处就是读取速度快</p>
<p>4.redis数据库</p>
<p>redis数据库就是一款缓存数据库，用于存储使用频繁的数据，这样减少访问数据库的次数，提高运行效率。</p>
<p>5.redis和mysql的区别总结</p>
<p>（1）类型上</p>
<p>从类型上来说，mysql是关系型数据库，redis是缓存数据库</p>
<p>（2）作用上</p>
<p>mysql用于持久化的存储数据到硬盘，功能强大，但是速度较慢</p>
<p>redis用于存储使用较为频繁的数据到缓存中，读取速度快</p>
<p>（3）需求上</p>
<p>mysql和redis因为需求的不同，一般都是配合使用。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>内存管理主要是做什么呢？</p>
<p>主要负责内存的分配与回收（malloc函数：申请内存，free函数：释放内存）,另外地址转换也就是将逻辑地址转换成相应的物理地址功能也是操作系统内存管理做的事情。</p>
<h4 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h4><p>简单分为连续分配管理方式和非连续分配管理方式。前者是指为一个用户程序分配一个连续的内存空间，常见的如块式管理，后者允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如页式管理和段式管理。</p>
<p><strong>块式管理</strong>：远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程，如果程序需要进程的话就给他分配一块，如果只需要很小的空间的话，很大一部分就会被浪费了，这些在每个块中未被利用的空间叫做<strong>碎片</strong>。</p>
<p><strong>页式管理：</strong>把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，较少了碎片，页式管理通过页表对应逻辑地址和物理地址。</p>
<p><strong>段式管理：</strong>段式管理将主存分为一段段的，每一段的空间又要比一页的空间小很多，但是最重要的是段式有实际意义的，每个段定义了一组逻辑信息，例如主程序段MAIN，栈段S，段式管理通过段表对应逻辑地址和物理地址。</p>
<p><strong>段页式管理：</strong>结合了段式管理和页式管理的优点，简单来说段页式管理机制就是吧主存先分成若干段，每个段又分成若干页，段与段之间以及段的内部的都是离散的。</p>
<h4 id="快表和多级页表"><a href="#快表和多级页表" class="headerlink" title="快表和多级页表"></a>快表和多级页表</h4><p>在分页管理中有两点非常重要，虚拟地址到物理地址的转换要快，解决虚拟地址空间大，页表也会很大的问题。</p>
<p>快表是来解决转换速度的问题，可以理解为一种高速缓冲存储器Cache，其中的内容是页表的一部分或者全部内容。做为页表的Cache，它的作用于页表相似，但是提高了访问速度。</p>
<p>流程：</p>
<ol>
<li>根据虚拟地址中的页号查快表</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中</li>
<li>快表填满后，又要等级新页的时候，就按照一定的淘汰策略淘汰快表中的一个页。</li>
</ol>
<p>多级页表的主要目的是避免把全部页表一直放在内存中占用过多的空间，特别是那些根本就不需要的页表就不需要保存在内存中，属于典型的时间换空间的场景。</p>
<h4 id="物理地址和虚拟地址"><a href="#物理地址和虚拟地址" class="headerlink" title="物理地址和虚拟地址"></a>物理地址和虚拟地址</h4><p>逻辑地址有操作系统决定，物理地址指的是真实物理内存中的地址，更具体一点就是内存地址寄存器中的地址，物理地址是内存单元真正的地址。</p>
<h4 id="CPU寻址"><a href="#CPU寻址" class="headerlink" title="CPU寻址"></a>CPU寻址</h4><p>现代处理器使用的是一种称为虚拟寻址的寻址方式，使用虚拟寻址，CPU需要将虚拟地址转换为物理地址，这样才能访问到真是的物理地址。完成该任务的硬件是CPU中的一个被称为内存管理单元的硬件。</p>
<p>通过虚拟地址访问内存的优势</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区</li>
<li>程序可以使用一些列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页保存到磁盘文件，数据或者代码页会根据需要在物理内存与磁盘之间移动</li>
<li>不同进程使用的虚拟地址彼此隔离。</li>
</ul>
<h3 id="分页和分段"><a href="#分页和分段" class="headerlink" title="分页和分段"></a>分页和分段</h3><ul>
<li>页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；</li>
<li>段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；</li>
<li>段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。</li>
</ul>
<p>区别：</p>
<ul>
<li>目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；</li>
<li>大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；</li>
<li>地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）；</li>
<li>分段便于信息的保护和共享；分页的共享收到限制；</li>
<li>碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）</li>
</ul>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。</p>
<p>正式因为虚拟内存的存在，通过虚拟内存可以让程序可以拥有超过系统物理内存大小的可用内存空间，另外虚拟内存为每个进程提供了一个一致的，私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉。</p>
<p>虚拟内存的优点是让程序可以获得更多的可用内存。</p>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>局部性原理表现在以下两个方面：</p>
<ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p>
<blockquote>
<p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
</blockquote>
<p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>
<ul>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li><strong>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>
<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>
</ul>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程是计算机中运行的一个应用程序,运行时程序的封装，系统进行资源调度，分配的基本单位</p>
<p>线程：执行该进程的逻辑单元。线程是用来执行进程的，进程的子任务，cpu调度分派的基本单位，保证程序的实时性</p>
<p>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存</p>
<p>关于进程的定义有很多，一个经典的定义是一个执行中程序的实例，进程是程序的动态表现。 一个程序进行起来后，会使用很多资源，比如使用寄存器，内存，文件等。每当切换进程时，必须要考虑保存当前进程的状态。状态包括存放在内存中的程序的代码和数据，它<strong>的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开的文件描述符的集合，这个状态叫做上下文（Context）。可见，想要切换进程，保存的状态还不少。</strong></p>
<p>线程存在于进程中，一个进程可以有一个或多个线程。线程是运行在进程上下文中的逻辑流，简单说，线程可以理解为一个方法(Java)或函数（C），这个线程可以独立完成一项任务。同样线程有自己的上下文，包括<strong>唯一的整数线程ID， 栈、栈指针、程序计数器、通用目的寄存器和条件码。可以理解为线程上下文是进程上下文的子集。</strong></p>
<p>由于保存线程的上下文明显比进程的上下文小，因此系统切换线程时，必然开销更小。</p>
<p><strong>同一进程中的线程可以共享哪些数据</strong></p>
<ul>
<li>进程代码段</li>
<li>进程的公有数据（全局变量、静态变量…）</li>
<li>进程打开的文件描述符</li>
<li>进程的当前目录</li>
<li>信号处理器/信号处理函数：对收到的信号的处理方式</li>
<li>进程ID与进程组ID</li>
</ul>
<p><strong>线程独占哪些资源</strong></p>
<ul>
<li>线程ID</li>
<li>一组寄存器的值</li>
<li>线程自身的栈（堆是共享的）</li>
<li>错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；</li>
<li>信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）</li>
</ul>
<h4 id="进程间的五种通信方式"><a href="#进程间的五种通信方式" class="headerlink" title="进程间的五种通信方式"></a>进程间的五种通信方式</h4><ul>
<li><p>管道通信 </p>
<p>管道是一种进程间通信的方式，在linux中分为有名管道和无名管道。有名管道就是把一个进程的输出写到一个文件中，再把此文件作为另一个进程的输入。<br>无名管道也是如此，只不过这个管道文件不直接可见而已，通常无名管道都作为一个进程组的形式完成，如ls | grep ‘a’，这就是一种进程间单向的通信方式。</p>
<p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</p>
<p>一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据；</p>
<p>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)</p>
</li>
<li><p>消息队列</p>
<p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。    </p>
<p>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p>
<p>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</p>
<p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
</li>
<li><p>共享内存</p>
<p>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。</p>
<ol>
<li>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</li>
<li>因为多个进程可以同时操作，所以需要进行同步。</li>
<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li>
</ol>
</li>
<li><p>信号量</p>
<p>信号量（semaphore），它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<ol>
<li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</li>
<li>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</li>
<li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li>
<li>支持信号量组。</li>
</ol>
</li>
<li><p>套接字socket通信</p>
<p>套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信</p>
</li>
</ul>
<p>几种方式的比较：</p>
<ul>
<li>管道：速度慢，容量有限</li>
<li>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。</li>
<li>信号量：不能传递复杂消息，只能用来同步</li>
<li>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了一块内存的。</li>
</ul>
<h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p><strong>一、先来先去服务</strong>FCFS</p>
<p>　　先来先去服务调度算法是一种最简单的调度算法，也称为先进先出或严格排队方案。当每个进程就绪后，它加入就绪队列。当前正运行的进程停止执行，选择在就绪队列中存在时间最长的进程运行。该算法既可以用于作业调度，也可以用于进程调度。先来先去服务比较适合于常作业（进程），而不利于段作业（进程）。</p>
<p><strong>二、时间片轮转法</strong></p>
<p>　　轮转法是基于适中的抢占策略的，以一个周期性间隔产生时钟中断，当中断发生后，当前正在运行的进程被置于就绪队列中，然后基于先来先去服务策略选择下一个就绪作业的运行。这种技术也称为时间片，因为每个进程再被抢占之前都给定一片时间。</p>
<p><strong>三、最短进程优先</strong></p>
<p>　　最短进程优先是一个非抢占策略，他的原则是下一次选择预计处理时间最短的进程，因此短进程将会越过长作业，跳至队列头。该算法即可用于作业调度，也可用于进程调度。但是他对长作业不利，不能保证紧迫性作业（进程）被及时处理，作业的长短只是被估算出来的。</p>
<p><strong>四、最短剩余时间优先</strong></p>
<p>　　最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。</p>
<p><strong>五、最高响应比优先</strong></p>
<p>根据比率：R=(w+s)/s （R为响应比，w为等待处理的时间，s为预计的服务时间）</p>
<p>　　如果该进程被立即调用，则R值等于归一化周转时间（周转时间和服务时间的比率）。R最小值为1.0，只有第一个进入系统的进程才能达到该值。调度规则为：当前进程完成或被阻塞时，选择R值最大的就绪进程，它说明了进程的年龄。当偏向短作业时，长进程由于得不到服务，等待时间不断增加，从而增加比值，最终在竞争中赢了短进程。</p>
<p>　　和最短进程优先、最短剩余时间优先一样，使用最高响应比策略需要估计预计服务时间。</p>
<p><strong>六、反馈法</strong></p>
<p>　　如果没有关于进程相对长度的任何信息，则最短进程优先，最短剩余时间、最高响应优先比都不能使用。另一种导致偏向短作业的方法是处罚运行时间较长的作业，换句话说，如果不能获得剩余的执行时间，那就关注已执行了的时间。</p>
<p>　　方法为：调度基于被抢占原则（按时间片）并使用动态优先级机制。当一个进程第一次进入系统中时，他被放置在一个优先级队列中，当第一次被抢占后并返回就绪状态时，它被放置在下一个低优先级队列中，在随后的时间里，每当被抢占时，他被降级到下一个低优先级队列中。一个短进程很快被执行完，不会在就绪队列中降很多级，一个长进程会逐渐降级。因此先到的进程和短进程优先于长进程和老进程。在每个队列中，除了优先级在最低的队列中之外，都是用简单的先来先去服务机制，一旦一个进程处于优先级最低的队列中，它就不可能在降级，但会重复的返回该队列，直到运行结束。因此，该队列课按照轮转方式调度。</p>
<p> <strong>七、多级反馈队列调度算法</strong></p>
<p>　　多级反馈队列算法，不必事先知道各种进程所需要执行的时间，他是当前被公认的一种较好的进程调度算法。其实施过程如下：</p>
<p>　　1)设置多个就绪队列，并为各个队列赋予不同的优先级。在优先权越高的队列中，为每个进程所规定的执行时间片就越小。</p>
<p>　　2)当一个新进程进入内存后，首先放入第一队列的末尾，按照先来先去原则排队等候调度。如果他能在一个时间片中完成，便可撤离；如果未完成，就转入第二队列的末尾，同样等待调度…..如此下去，当一个长作业（进程）从第一队列依次将到第n队列（最后队列）后，便按第n队列时间片轮转运行。</p>
<p>　　3)仅当第一队列空闲的时候，调度程序才调度第二队列中的进程运行；仅当第1到（i-1）队列空时，才会调度第i队列中的进程运行，并执行相应的时间片轮转。</p>
<p>　　4)如果处理机正在处理第i队列中某进程，又有新进程进入优先权较高的队列，则此新队列抢占正在运行的处理机，并把正在运行的进程放在第i队列的队尾。</p>
<h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><p><strong>运行态</strong>：该进程正在执行。</p>
<p><strong>就绪态</strong>：进程已经做好了准备，只要有机会就开始执行。</p>
<p><strong>阻塞态</strong>（等待态）：进程在某些事情发生前不能执行，等待阻塞进程的事件完成。</p>
<p>主要是上面三个</p>
<p><strong>新建态</strong>：刚刚创建的进程，操作系统还没有把它加入到可执行进程组中，通常是进程控制块已经创建但是还没有加载到内存中的进程。</p>
<p><strong>退出态</strong>：操作系统从可执行进程组中释放出的进程，或由于自身或某种原因停止运行。</p>
<p><strong>空-&gt;新建</strong>：创建执行一个程序的新进程，可能的事件有：新的批处理作业、交互登录（终端用户登录到系统）、操作系统因为提供一项服务而创建、由现有的进程派生等。</p>
<p>新建-&gt;就绪：操作系统准备好再接纳一个进程时，把一个进程从新建态转换为就绪态。</p>
<p><strong>就绪-&gt;运行</strong>：需要选择一个新进程运行时，操作系统的调度器或分配器根据某种调度算法选择一个处于就绪态的进程。</p>
<p><strong>运行-&gt;退出</strong>：导致进程终止的原因有：正常完成、超过时限、系统无法满足进程需要的内存空间、进程试图访问不允许访问的内存单元（越界）、算术错误（如除以0或存储大于硬件可以接纳的数字）、父进程终止（操作系统可能会自动终止该进程所有的后代进程）、父进程请求终止后代进程等。</p>
<p><strong>运行-&gt;就绪</strong>：最常见的原因是，正在运行的进程到达了“允许不中断执行”的最大时间段，该把处理器的资源释放给其他在就绪态的进程使用了；还有一中原因可能是由于具有更改优先级的就绪态进程抢占了该进程的资源，使其被中断转换到就绪态。</p>
<p><strong>运行-&gt;阻塞</strong>：如果进程请求它必须等待的某些事件，例如一个无法立即得到的资源（如I/O操作），只有在获得等待的资源后才能继续进程的执行，则进入等待态（阻塞态）。</p>
<p><strong>阻塞-&gt;就绪</strong>：当等待的事件发生时，处于阻塞态的进程转换到就绪态。</p>
<p><strong>就绪-&gt;退出</strong>：在上图中没有标出这种转换，在某些进程中，父进程可以在任何时刻终止一个子进程，如果一个父进程终止，所有相关的子进程都被终止。</p>
<p><strong>阻塞-&gt;退出</strong>：跟上一项原因类似。</p>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>一个子进程结束后，它的父进程并没有等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。</p>
<p>危害：占用进程号，而系统所能使用的进程号是有限的；占用内存。</p>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>new runnable blocked waiting time-waiting terminated</p>
<ol>
<li>当进入到同步代码块或者同步方法时，且没有获取到锁，线程就进入到了blocked状态，直到被释放锁，重新进入到runnable状态</li>
<li>当线程调用wait或者join时，线程都会进入到waiting状态，当调用notify或notifyAll时，或者join的线程执行结束后，会进入到runnable状态</li>
<li>当线程调用sleep(time),或者wait(time)时，进入到timed waiting状态 当休眠结束时，或者调用otify或notifyAll时会重新进入到runnable状态</li>
<li>程序结束后，线程进入到terminated状态</li>
</ol>
<h4 id="进程的同步方式"><a href="#进程的同步方式" class="headerlink" title="进程的同步方式"></a>进程的同步方式</h4><ol>
<li>互斥量 采用互斥对象机制</li>
<li>信号量 允许同一时刻多个线程访问同一资源</li>
<li>事件</li>
</ol>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><blockquote>
<p>为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。</p>
</blockquote>
<ul>
<li><strong>互斥量</strong> Mutex：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；</li>
<li><strong>信号量</strong> Semaphore：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了<strong>最大资源计数</strong>和<strong>当前可用资源计数</strong>，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过<code>ReleaseSemaphore</code>函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量；</li>
<li><strong>事件</strong> Event：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒<strong>一个</strong>等待中的线程，然后自动恢复为未激发状态。</li>
<li><strong>临界区</strong> Critical Section：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。</li>
</ul>
<h4 id="多线程中的上下文切换"><a href="#多线程中的上下文切换" class="headerlink" title="多线程中的上下文切换"></a>多线程中的上下文切换</h4><p>即使是单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程时同时执行的，时间片一般是几十毫秒（ms）。</p>
<p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态，<strong>从任务保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>进程上下文和中断上下文是操作系统中很重要的两个概念，这两个概念在操作系统课程中不断被提及，是最经常接触、看上去很懂但又说不清楚到底怎么回事的两个概念。造成这种局面的原因，可能是原来接触到的操作系统课程的教学总停留在一种浅层次的理论层面上，没有深入去研究。<br>　　处理器总处于以下三种状态之一：<br>1、内核态，运行于进程上下文，内核代表进程运行于内核空间；<br>2、内核态，运行于中断上下文，内核代表硬件运行于内核空间；<br>3、用户态，运行于用户空间。<br>　　用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递 很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存 器值、变量等。<strong>所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。</strong><br>　　硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的 一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。<strong>所谓的“ 中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。</strong><br>　　LINUX完全注释中的一段话：<br>　　<strong>当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称 为该进程的上下文</strong>。当内核需要切换到另一个进程时，它需要保存当前进程的 所有状态，即保存当前进程的上下文，以便在再次执行该进程时，能够必得到切换时的状态执行下去。在LINUX中，当前进程上下文均保存在进程的任务数据结 构中。在发生中断时,内核就在被中断进程的上下文中，在内核态下执行中断服务例程。但同时会保留所有需要用到的资源，以便中继服务结束时能恢复被中断进程 的执行。<br>　　上下文context： 上下文简单说来就是一个环境，相对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。<br><strong>一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。</strong><br>用户级上下文: 正文、数据、用户堆栈以及共享存储区；<br>寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；<br>系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。<br>当发生进程调度时，进行进程切换就是上下文切换(context switch).操作系统必须对上面提到的全部信息进行切换，新调度的进程才能运行。而系统调用进行的模式切换(mode switch)。模式切换与进程切换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是切换进程寄存器上下文的切换。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>两个或多个并发的进程中，每个进程持有资源而等待其他进程释放资源</p>
<p>条件：互斥 请求与等待 不可抢占 环路等待</p>
<p><strong>死锁避免</strong></p>
<p>死锁避免的基本思想：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。<br>如果操作系统能保证所有进程在有限时间内得到需要的全部资源，则系统处于安全状态否则系统是不安全的。</p>
<ol>
<li><ol>
<li>安全状态是指：如果系统存在 由所有的安全序列{P1，P2，…Pn},则系统处于安全状态。一个进程序列是安全的，如果对其中每一个进程Pi(i &gt;=1 &amp;&amp; i &lt;= n)他以后尚需要的资源不超过系统当前剩余资源量与所有进程Pj(j &lt; i)当前占有资源量之和，系统处于安全状态则不会发生死锁。</li>
<li>不安全状态：如果不存在任何一个安全序列，则系统处于不安全状态</li>
</ol>
</li>
</ol>
<p><strong>死锁预防</strong></p>
<p>我们可以通过破坏死锁产生的4个必要条件来 预防死锁，由于资源互斥是资源使用的固有特性是无法改变的。</p>
<ol>
<li>破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。</li>
<li>破坏”请求与保持条件“：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。</li>
<li>破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。</li>
</ol>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到 第一个线程释放信号量。为了完成这个过程，需要创建一个信号量VI，然后将Acquire Semaphore VI以及Release Semaphore VI分别放置在每个关键代码段的首末端。确认这些信号量VI引用的是初始创建的信号量。</p>
<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>IO多路复用（IO Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。</p>
<p>实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。</p>
<h3 id="用户态内核态"><a href="#用户态内核态" class="headerlink" title="用户态内核态"></a>用户态内核态</h3><h4 id="操作系统需要两种CPU状态"><a href="#操作系统需要两种CPU状态" class="headerlink" title="操作系统需要两种CPU状态"></a>操作系统需要两种CPU状态</h4><p>内核态（Kernel Mode）：运行操作系统程序，操作硬件</p>
<p>用户态（User Mode）：运行用户程序</p>
<h4 id="指令划分"><a href="#指令划分" class="headerlink" title="指令划分"></a>指令划分</h4><p>特权指令：只能由操作系统使用、用户程序不能使用的指令。 举例：启动I/O 内存清零 修改程序状态字 设置时钟 允许/禁止终端 停机</p>
<p>非特权指令：用户程序可以使用的指令。 举例：控制转移 算数运算 取数指令 <strong>访管指令</strong>（使用户程序从用户态陷入内核态）</p>
<h4 id="特权级别"><a href="#特权级别" class="headerlink" title="特权级别"></a>特权级别</h4><p><strong>特权环：R0、R1、R2和R3</strong></p>
<p>R0相当于内核态，R3相当于用户态；</p>
<p>不同级别能够运行不同的指令集合；</p>
<h4 id="CPU状态之间的转换"><a href="#CPU状态之间的转换" class="headerlink" title="CPU状态之间的转换"></a>CPU状态之间的转换</h4><p><strong>用户态—&gt;内核态：</strong>唯一途径是通过中断、异常、陷入机制（访管指令）</p>
<p><strong>内核态—&gt;用户态：</strong>设置程序状态字PSW</p>
<h4 id="内核态与用户态的区别"><a href="#内核态与用户态的区别" class="headerlink" title="内核态与用户态的区别"></a>内核态与用户态的区别</h4><ul>
<li><p>内核态与用户态是操作系统的两种运行级别，当程序运行在3级特权级上时，就可以称之为运行在用户态。<strong>因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；</strong></p>
</li>
<li><p>当程序运行在0级特权级上时，就可以称之为运行在内核态。</p>
</li>
<li><p>运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。</p>
</li>
<li><p>这两种状态的主要差别是</p>
<blockquote>
<ul>
<li>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的</li>
<li>处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>通常来说，以下三种情况会导致用户态到内核态的切换</strong></p>
<ul>
<li>系统调用</li>
</ul>
<p><strong>这是用户态进程主动要求切换到内核态的一种方式</strong>，<strong>用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。</strong>比如前例中fork()实际上就是执行了一个创建新进程的系统调用。</p>
<p>而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
<p>用户程序通常调用库函数，由库函数再调用系统调用，因此有的库函数会使用户程序进入内核态（只要库函数中某处调用了系统调用），有的则不会。</p>
<p>read write 文件读写操作</p>
<ul>
<li>异常</li>
</ul>
<p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
<ul>
<li>外围设备的中断</li>
</ul>
<p><strong>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号</strong>，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，</p>
<p>如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<p><strong>这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。</strong></p>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>一个操作系统可以支持多种底层不同的文件系统（比如NTFS, FAT, ext3, ext4），为了给内核和用户进程提供统一的文件系统视图，Linux在用户进程和底层文件系统之间加入了一个抽象层，即虚拟文件系统(Virtual File System, VFS)，进程所有的文件操作都通过VFS，由VFS来适配各种底层不同的文件系统，完成实际的文件操作。</p>
<p>通俗的说，VFS就是定义了一个通用文件系统的接口层和适配层，一方面为用户进程提供了一组统一的访问文件，目录和其他对象的统一方法，另一方面又要和不同的底层文件系统进行适配。如图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8jbw57szj30h106bjrt.jpg" alt="img"></p>
<p>1、超级块（super_block），用于保存一个文件系统的所有元数据，相当于这个文件系统的信息库，为其他的模块提供信息。因此一个超级块可代表一个文件系统。文件系统的任意元数据修改都要修改超级块。超级块对象是常驻内存并被缓存的。</p>
<p>2、目录项模块，管理路径的目录项。比如一个路径 /home/foo/hello.txt，那么目录项有home, foo, hello.txt。目录项的块，存储的是这个目录下的所有的文件的inode号和文件名等信息。其内部是树形结构，操作系统检索一个文件，都是从根目录开始，按层次解析路径中的所有目录，直到定位到文件。</p>
<p>3、inode模块，管理一个具体的文件，是文件的唯一标识，一个文件对应一个inode。通过inode可以方便的找到文件在磁盘扇区的位置。同时inode模块可链接到address_space模块，方便查找自身文件数据是否已经缓存。</p>
<p>4、打开文件列表模块，包含所有内核已经打开的文件。已经打开的文件对象由open系统调用在内核中创建，也叫文件句柄。打开文件列表模块中包含一个列表，每个列表表项是一个结构体struct file，结构体中的信息用来表示打开的一个文件的各种状态参数。</p>
<p>5、file_operations模块。这个模块中维护一个数据结构，是一系列函数指针的集合，其中包含所有可以使用的系统调用函数，例如open、read、write、mmap等。每个打开文件（打开文件列表模块的一个表项）都可以连接到file_operations模块，从而对任何已打开的文件，通过系统调用函数，实现各种操作。</p>
<p>6、address_space模块，它表示一个文件在页缓存中已经缓存了的物理页。它是页缓存和外部设备中文件系统的桥梁。如果将文件系统可以理解成数据源，那么address_space可以说关联了内存系统和文件系统。</p>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a><strong>读文件</strong></h4><p>1、进程调用库函数向内核发起读文件请求；</p>
<p>2、内核通过检查进程的文件描述符定位到虚拟文件系统的已打开文件列表表项；</p>
<p>3、调用该文件可用的系统调用函数read()</p>
<p>3、read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode；</p>
<p>4、在inode中，通过文件内容偏移量计算出要读取的页；</p>
<p>5、通过inode找到文件对应的address_space；</p>
<p>6、在address_space中访问该文件的页缓存树，查找对应的页缓存结点：</p>
<p>（1）如果页缓存命中，那么直接返回文件内容；</p>
<p>（2）如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第6步查找页缓存；</p>
<p>7、文件内容读取成功。</p>
<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a><strong>写文件</strong></h4><p>前5步和读文件一致，在address_space中查询对应页的页缓存是否存在：</p>
<p>6、如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。</p>
<p>7、如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。</p>
<p>8、一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：</p>
<p>（1）手动调用sync()或者fsync()系统调用把脏页写回</p>
<p>（2）pdflush进程会定时把脏页写回到磁盘</p>
<p>同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放</p>
<h3 id="操作系统中断和异常"><a href="#操作系统中断和异常" class="headerlink" title="操作系统中断和异常"></a>操作系统中断和异常</h3><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p><strong>中断是为了实现多道程序并发执行而引入的一种技术</strong></p>
<ol>
<li>当中断发生时，CPU立即进入核心态</li>
<li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li>
<li>对于不同的中断信号，会进行不同的处理</li>
</ol>
<p>发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配I/0设备等）需要使用特权指令，因此CPU要从用户态转为核心态。<strong>中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权</strong>。有了中断，才能实现多道程序并发执行。</p>
<p><strong>用户态 → 核心态：</strong> 通过中断实现的。并且中断是唯一途径。</p>
<p><strong>核心态 → 用户态：</strong> 通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”</p>
<p><strong>中断分类</strong></p>
<ul>
<li>内中断：信号的来源在CPU内部，与当前执行的指令有关</li>
<li>外中断：信号的来源在CPU外部，与当前执行的指令无关</li>
</ul>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h4><p>​    当下述情况发生，CPU中断当前的执行流程，转到相应的错误处理程序或陷入处理程序：</p>
<ul>
<li>CPU执行指令时本身出现算术异常、零做除数、访存指令越界、虚存缺页等；</li>
<li>正常异常，即执行了一条trap指令，用于实现系统调用</li>
</ul>
<h3 id="中断和异常的区分"><a href="#中断和异常的区分" class="headerlink" title="中断和异常的区分"></a>中断和异常的区分</h3><p>1、中断：通道（或设备）完成输入输出后，通道会“通知”CPU此次输入输出结束，这个“通知”就是中断。<br>可以看到，中断与CPU正在执行的指令并没有关系。</p>
<p>2、异常：而异常则是正在执行的指令本身出现了错误（如算术溢出、地址越界）等。</p>
<p>3、但中断和异常的结果都是使得“CPU暂停正在执行的程序”：</p>
<p>  CPU接受“中断”后停止当前的任务，去继续上一个任务或继续当时在执行的任务（如何选择则是与调度有关）。</p>
<p>  CPU接受“异常”后停止当前任务，去处理这些错误。 处理完成后CPU返回暂停点继续工作。</p>
<p>4、中断：与正在执行的指令无关，可以屏蔽</p>
<p>  异常：与正在执行的指令有关，不可屏蔽</p>
<h3 id="epoll-select-poll"><a href="#epoll-select-poll" class="headerlink" title="epoll select poll"></a>epoll select poll</h3><p>常用的IO复用模型有三种 select poll epoll (fd 文件描述符)</p>
<ol>
<li>select 时间复杂度O(n)，它仅仅知道有I/O事件发生，却并不知道哪几个流(可能有一个，多个，甚至全部)，我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。</li>
<li>poll 时间复杂度O(n)，poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的</li>
<li>Epoll, 事件复杂度O(1)。<strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></li>
</ol>
<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<p><strong>select：</strong></p>
<p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p>
<p>1、 单个进程可监视的fd数量被限制，即能监听端口的大小有限。</p>
<p>   一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</p>
<p>2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：</p>
<p>​    当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p>
<p>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p>
<p><strong>poll：</strong></p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<p><strong>它没有最大连接数的限制</strong>，原因是它是基于链表来存储的，但是同样有一个缺点：</p>
<p>1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。          </p>
<p>2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p>
<p><strong>epoll:</strong></p>
<p>epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p>
<p><strong>epoll的优点：</strong></p>
<p>1、<strong>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）</strong>；<br><strong>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；</strong><br><strong>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</strong></p>
<p>3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p>
<h2 id="面向对象思想的理解"><a href="#面向对象思想的理解" class="headerlink" title="面向对象思想的理解"></a>面向对象思想的理解</h2><p>更多的是考虑如何去选择合适的工具</p>
<p>封装 继承 多态</p>
<p>多态：同一个行为具有多个不同表现形式称为多态 有继承 子类重写父类，父类引用子类</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p> 封装是指将对象的实现细节隐藏起来，对外提供公共访问方法，将对象的功能暴露出来。</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>适当的封装可以让程式码更容易理解与维护，也加强了程序代码的安全性。最终目的是实现模块设计的”高内聚低耦合“。</p>
<p>从上图可以得出，实现一个类封装的步骤如下：</p>
<p>♦ 修改属性的可见性（访问级别）来限制对属性的访问（一般限制为private），例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;<span class="comment">//年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 　♦ 对每个值属性提供对外的公共方法访问，也就是创建一对赋值取值的方法，用于对私有属性的访问，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突，this指当前对象。</p>
<p>因此，一个类定义时，一般用private修饰成员变量，public修饰成员方法。获取成员变量应该用对象.get变量名()而不是对象.成员变量名。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p> 继承是指子类可以复用父类的属性和方法，Java的继承是单继承，每个子类只有一个直接父类。Java的继承通过extends关键字实现，实现继承的类称为子类，被继承的类称为父类（基类或超类）。Java继承语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">  <span class="comment">//类定义部分      </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是 Java 不支持多继承，但支持多重继承。</p>
<p>子类包含与父类同名方法的现象称为方法重写，也称为方法覆盖。</p>
<p>　　方法的重写要遵循“两同两小一大”规则，“两同”即方法名相同、形参列表相同；“两小”指子类方法返回值类型应该比父类方法返回值类型要小或相等，子类方法声明抛出的异常应该比父类方法声明抛出的异常类要小或相等；“一大”指子类方法的访问权限应比父类方法的访问权限更大或相等。</p>
<p>子类重写方法的返回值必须比父类方法的返回值小或者相等的意思是说：子类重写方法的返回值应为<strong>父类方法返回值类型的子类或者和父类方法返回值相等</strong></p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指子类对象可以直接赋给父类变量（父类引用指向子类对象），但运行时依然表现出子类的行为特征，也就是说，同一类型的对象在执行同一个方法时，可能表现出多种行为特征。</p>
<p>　<strong>多态存在的三个必要条件</strong></p>
<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ul>
<p>　　比如：Parent p = new Child();</p>
<p>　　当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</p>
<p>　　多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p>
<p>　　下面举一个多态的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      show(<span class="keyword">new</span> Cat());  <span class="comment">// 以 Cat 对象调用 show 方法</span></span><br><span class="line">      show(<span class="keyword">new</span> Dog());  <span class="comment">// 以 Dog 对象调用 show 方法</span></span><br><span class="line">                </span><br><span class="line">      Animal a = <span class="keyword">new</span> Cat();  <span class="comment">// 向上转型  </span></span><br><span class="line">      a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">      Cat c = (Cat)a;        <span class="comment">// 向下转型  </span></span><br><span class="line">      c.work();        <span class="comment">// 调用的是 Cat 的 work</span></span><br><span class="line">  &#125;  </span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Animal a)</span>  </span>&#123;</span><br><span class="line">      a.eat();  </span><br><span class="line">        <span class="comment">// 类型判断</span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)  &#123;  <span class="comment">// 猫做的事情 </span></span><br><span class="line">            Cat c = (Cat)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) &#123; <span class="comment">// 狗做的事情 </span></span><br><span class="line">            Dog c = (Dog)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;看家&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">执行以上程序，输出结果为：</span><br><span class="line"></span><br><span class="line">吃鱼</span><br><span class="line">抓老鼠</span><br><span class="line">吃骨头</span><br><span class="line">看家</span><br><span class="line">吃鱼</span><br><span class="line">抓老鼠</span><br></pre></td></tr></table></figure>

<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="RestController-Controller"><a href="#RestController-Controller" class="headerlink" title="@RestController @Controller"></a>@RestController @Controller</h3><p><strong>Controller</strong></p>
<p>Controller返回一个页面，单独使用@Controller不加@ResponseBody的话一般使用在要返回一个视图的情况下，这种属于比较传统的Spring MVC应用，对应于前后端不分离的情况。</p>
<p><strong>@RestController</strong></p>
<p>@RestController返回对象，对象数据直接以Json或者XML的形式写入HTTP相应。这种情况属于RESTful Web服务</p>
<p>@Controller + @ResponseBody = @RestController</p>
<h3 id="SpringIoc"><a href="#SpringIoc" class="headerlink" title="SpringIoc"></a>SpringIoc</h3><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong> IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>为什么叫控制反转？</p>
<ul>
<li>控制：指的是对象创建（实例化 管理）的权力</li>
<li>反转：控制权交给外部环境（Spring 框架,Ioc 容器）</li>
</ul>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<p>使用方式：</p>
<ol>
<li>配置文件 bean  解析XML，调用方法实现注入（反射）</li>
<li>注解的方式 Autowrie 解析类，这个类是Spring管理的 赋值</li>
</ol>
<p>完成两个事情 解释和实现赋值</p>
<p>Spring Ioc 的初始化过程</p>
<p><strong>xml</strong>   读取   <strong>Resource</strong>   解析    <strong>BeanDefinition</strong> 注册 <strong>BeanFactory</strong></p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，</p>
<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p><strong>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP</strong> 。</p>
<p><strong>Spring AOP 和AspectJ AOP 区别</strong></p>
<p>Spring AOP 属于运行时增强，而AspectJ AOP是编译时增强。前者是基于代理，而后者是基于字节码操作。</p>
<h3 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h3><p>bean 简单来说就是那些被IoC 容器所管理的对象。</p>
<p>通过配置元数据来定义，从而告诉容器我们需要管理哪些对象，配置元数据可以是XML文件，注解或者Java配置类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Constructor-arg with <span class="string">&#x27;value&#x27;</span> attribute --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;...&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;...&quot;</span>&gt;</span><br><span class="line">   &lt;constructor-arg value=<span class="string">&quot;...&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p><strong>bean 的作用域</strong></p>
<p><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</p>
<p><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</p>
<p><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</p>
<p><strong>session</strong> : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</p>
<p><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</p>
<p><strong>如何配置 bean 的作用域呢？</strong></p>
<p>xml 方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注解方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">personPrototype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单线程bean的线程安全问题</strong></p>
<p>单线程bean存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p>
<p>常见的两种解决办法：</p>
<ul>
<li>在bean中尽量避免定义可变的成员变量</li>
<li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中</li>
</ul>
<h4 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzhqabbt5oj20qy0d2jt1.jpg" alt="在这里插入图片描述"></p>
<p>对Bean的创建最为核心三个方法解释如下：</p>
<ul>
<li>createBeanInstance：例化，其实也就是调用对象的构造方法实例化对象</li>
<li>populateBean：填充属性，这一步主要是对bean的依赖属性进行注入(@Autowired)</li>
<li>initializeBean：回到一些形如initMethod、InitializingBean等方法</li>
</ul>
<p>从对**<code>单例Bean</code><strong>的初始化可以看出，循环依赖主要发生在</strong>第二步（populateBean）**，也就是field属性注入的处理</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>大体来说，Spring Bean 的生命周期可以分为四个阶段</p>
<ol>
<li>实例化 Instantiation</li>
<li>属性赋值 Populate</li>
<li>初始化 Initialization</li>
<li>销毁 Destruction</li>
</ol>
<p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>
<p>主要逻辑都在doCreate()方法中，逻辑很清晰，就是顺序调用以下三个方法，这三个方法与三个生命周期阶段一一对应，非常重要，在后续扩展接口分析中也会涉及。</p>
<ol>
<li>createBeanInstance() -&gt; 实例化</li>
<li>populateBean() -&gt; 属性赋值</li>
<li>initializeBean() -&gt; 初始化</li>
</ol>
<p>至于销毁，是在容器关闭的时候调用的。</p>
<p><strong>InitializingBean</strong> 对应生命周期的初始化阶段，在上面源码的<code>invokeInitMethods(beanName, wrappedBean, mbd);</code>方法中调用。<br> 有一点需要注意，因为Aware方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用Aware接口获取的资源，这也是我们自定义扩展Spring的常用方式。<br> 除了实现InitializingBean接口之外还能通过注解或者xml配置的方式指定初始化方法，至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式。</p>
<p><strong>DisposableBean</strong> 类似于InitializingBean，对应生命周期的销毁阶段，以ConfigurableApplicationContext#close()方法作为入口，实现是通过循环取所有实现了DisposableBean接口的Bean然后调用其destroy()方法 。</p>
<p>Spring会扫描<strong>指定包</strong>下面的Java类，然后将其变成beanDefinition对象，然后Spring会根据beanDefinition来创建bean，特别要记住一点，Spring是根据beanDefinition来创建Spring bean的</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzhrhqc614j20u00ubwij.jpg" alt="img"></p>
<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>对于Spring循环依赖的情况总结如下：</p>
<p>不能解决的问题：</p>
<ul>
<li>构造器注入循环依赖</li>
<li>prototype模式field属性注入循环依赖</li>
</ul>
<p>能解决的情况：</p>
<ul>
<li>singleton模式field属性注入（setter方法注入）循环依赖</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="”三级缓存“"><a href="#”三级缓存“" class="headerlink" title="”三级缓存“"></a>”三级缓存“</h4><p><strong><code>三级缓存</code>**其实它更像是Spring容器工厂的内的</strong><code>术语</code>**，采用三级缓存模式来解决循环依赖问题，这三级缓存分别指：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 从上至下 分表代表这“三级缓存”</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>); <span class="comment">//一级缓存</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>); <span class="comment">// 二级缓存</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>); <span class="comment">// 三级缓存</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Names of beans that are currently in creation. */</span></span><br><span class="line">	<span class="comment">// 这个缓存也十分重要：它表示bean创建过程中都会在里面呆着~</span></span><br><span class="line">	<span class="comment">// 它在Bean开始创建时放值，创建完成时会将其移出~</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/** Names of beans that have already been created at least once. */</span></span><br><span class="line">	<span class="comment">// 当这个Bean被创建完成后，会标记为这个 注意：这里是set集合 不会重复</span></span><br><span class="line">	<span class="comment">// 至少被创建了一次的  都会放进这里~~~~</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>singletonObjects：用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用</li>
<li>earlySingletonObjects：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖</li>
<li>singletonFactories：单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖</li>
</ul>
<p>获取单例bean的过程为：</p>
<ol>
<li>先从一级缓存singletonObjects中去获取，如果获取到了就直接return</li>
<li>如果获取不到或者对象正在创建中(isSingletonCurrentlyCreation())，那就再从二级缓存earlySingletonObjects中获取，如果获取到就return</li>
<li>如果还是获取不到，且允许singletonFactories（allowEarlyReference=true）通过getObject()获取。就从三级缓存singletonFactory.getObject()获取。（如果获取到了就从singletonFactories中移除，并且放进earlySingletonObjects。其实也就是从三级缓存移动（是剪切、不是复制哦~）到了二级缓存）</li>
</ol>
<blockquote>
<p><strong>加入<code>singletonFactories</code>三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决</strong></p>
</blockquote>
<p><strong>二级缓存<code>earlySingletonObjects</code>它里面的数据什么时候添加什么移除？？?</strong></p>
<p><strong>添加：</strong>向里面添加数据只有一个地方，就是上面说的getSingleton()里从三级缓存里挪过来<br><strong>移除：</strong>addSingleton、addSingletonFactory、removeSingleton从语义中可以看出添加单例、添加单例工厂ObjectFactory的时候都会删除二级缓存里面对应的缓存值，是互斥的。</p>
<p>Spring容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中，而对于创建完毕的Bean将从当前创建Bean池中清除掉。</p>
<p>这个“当前创建Bean池”指的是上面提到的singletonsCurrentlyInCreation那个集合。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzhsfbafegj20sy0ajta1.jpg" alt="img"></p>
<h4 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h4><p>以如上A,B类的互相依赖注入为例：</p>
<ol>
<li>入口处即是实例化，初始化A这个单例bean, AbstractFactory.doGetBean(“a”)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">	... </span><br><span class="line">	<span class="comment">// 标记beanName a是已经创建过至少一次的~~~ 它会一直存留在缓存里不会被移除（除非抛出了异常）</span></span><br><span class="line">	<span class="comment">// 参见缓存Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(256))</span></span><br><span class="line">	<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">		markBeanAsCreated(beanName);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 此时a不存在任何一级缓存中，且不是在创建中  所以此处返回null</span></span><br><span class="line">	<span class="comment">// 此处若不为null，然后从缓存里拿就可以了(主要处理FactoryBean和BeanFactory情况吧)</span></span><br><span class="line">	Object beanInstance = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 这个getSingleton方法非常关键。</span></span><br><span class="line">	<span class="comment">//1、标注a正在创建中~</span></span><br><span class="line">	<span class="comment">//2、调用singletonObject = singletonFactory.getObject();（实际上调用的是createBean()方法）  因此这一步最为关键</span></span><br><span class="line">	<span class="comment">//3、此时实例已经创建完成  会把a移除整整创建的缓存中</span></span><br><span class="line">	<span class="comment">//4、执行addSingleton()添加进去。（备注：注册bean的接口方法为registerSingleton，它依赖于addSingleton方法）</span></span><br><span class="line">	sharedInstance = getSingleton(beanName, () -&gt; &#123; ... <span class="keyword">return</span> createBean(beanName, mbd, args); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>下面进入到最为复杂的<code>AbstractAutowireCapableBeanFactory.createBean/doCreateBean()</code>环节，创建A的实例</li>
</ol>
<p>具体流程为：</p>
<ul>
<li>通过构造函数创建A对象，此时A对象是半成品，还没有注入属性和调用init方法，将半成品A对象封装成工厂对象存入到三级缓存</li>
<li>A对象需要注入B对象，发现缓存里还没有B对象，开始创建B对象</li>
<li>通过构造函数创建B对象，此时B对象也是半成品，同样在三级缓存中创建B工厂对象</li>
<li>B对象需要注入A对象，从三级缓存获取A工厂对象，使用工厂对象获取半成品A对象同时放入二级缓存中，提前曝光A对象，同时在三级缓存中删除A对象</li>
<li>B对象继续注入其他属性和初始化，之后将完成B对象放入完成品缓存一级缓存中，同时删除B工厂对象</li>
<li>A对象获取单例B的引用完成属性注入</li>
<li>A对象继续注入其他属性和初始化，之后将完成品A对象放入完成品缓存一级缓存同时删除二级缓存中的A</li>
</ul>
<p>singletonFactory是传入的一个匿名内部类，调用ObjectFactory.getObject()最终会调用getEarlyBeanReference方法。再来看看循环依赖中是怎么拿其它半成品的实例对象的。</p>
<p>  我们假设现在有这样的场景AService依赖BService，BService依赖AService</p>
<p>​    1. AService首先实例化，实例化通过ObjectFactory半成品暴露在三级缓存中</p>
<p>​    2. 填充属性BService，发现BService还未进行过加载，就会先去加载BService</p>
<p>​    3. 再加载BService的过程中，实例化，也通过ObjectFactory半成品暴露在三级缓存</p>
<p>​    4. 填充属性AService的时候，这时候能够从三级缓存中拿到半成品的ObjectFactory</p>
<p>拿到ObjectFactory对象后，调用ObjectFactory.getObject()方法最终会调用getEarlyBeanReference()方法，getEarlyBeanReference这个方法主要逻辑大概描述下如果bean被AOP切面代理则返回的是beanProxy对象，如果未被代理则返回的是原bean实例，这时我们会发现能够拿到bean实例(属性未填充)，然后从三级缓存移除，放到二级缓存earlySingletonObjects中，而此时B注入的是一个半成品的实例A对象，不过随着B初始化完成后，A会继续进行后续的初始化操作，最终B会注入的是一个完整的A实例，因为在内存中它们是同一个对象。</p>
<p><strong>只用二级缓存会有什么问题</strong></p>
<p>当有aop的时候，发现singletonFactory.getObject()返回的是一个AService的代理对象，还是被CGLIB代理的。再看一张再执行一遍singletonFactory.getObject()返回的不是同一个AService的代理对象。这就会有问题了，因为AService是单例的，每次执行singleFactory.getObject()方法又会产生新的代理对象，假设这里只有一级和三级缓存的话，我每次从三级缓存中拿到singleFactory对象，执行getObject()方法又会产生新的代理对象，这是不行的，</p>
<p>如果没有AOP的话确实可以两级缓存就可以解决循环依赖的问题，如果加上AOP，两级缓存是无法解决的，不可能每次执行singleFactory.getObject()方法都给我产生一个新的代理对象，所以还要借助另外一个缓存来保存产生的代理对象</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>我们一般使用@Autowired注解来自动装配bean，要想把类标识成可用于@Autowired注解自动装配的bean的类，可以采用一下注解</p>
<p>@controller 控制器（注入服务）</p>
<p>2、@service 服务（注入dao）</p>
<p>3、@repository dao（实现dao访问）</p>
<p>4、@component （把普通pojo实例化到spring容器中，相当于配置文件中的<bean id class>）</bean></p>
<p>　 @Component,@Service,@Controller,@Repository注解的类，并把这些类纳入进spring容器中管理。 </p>
<p>下面写这个是引入component的扫描组件 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">”com.mmnc”</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p> 其中base-package为需要扫描的包（含所有子包） </p>
<p>1、@Service用于标注业务层组件<br>2、@Controller用于标注控制层组件(如struts中的action)<br>3、@Repository用于标注数据访问组件，即DAO组件.<br>4、@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p>
<p><strong>@Component注解和@Bean注解的作用，以及两者的区别：</strong><br>@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。</p>
<p>@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。</p>
<p> 两者的目的是一样的，都是注册bean到Spring容器中。</p>
<p>区别：</p>
<p>@Component（@Controller、@Service、@Repository）通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中。</p>
<p>而@Bean注解通常是我们在标有该注解的方法中定义产生这个bean的逻辑。</p>
<p>@Component 作用于类，@Bean作用于方法。</p>
<p>总结：</p>
<p>@Component和@Bean都是用来注册Bean并装配到Spring容器中，但是Bean比Component的自定义性更强。可以实现一些Component实现不了的自定义加载类。</p>
<h3 id="Spring框架中设计模式"><a href="#Spring框架中设计模式" class="headerlink" title="Spring框架中设计模式"></a>Spring框架中设计模式</h3><ul>
<li><p>工厂设计模式：Spring 使用工厂设计模式通过BeanFactory,ApplicationContext创建bean对象</p>
</li>
<li><p>代理设计模式：Spring AOP功能</p>
</li>
<li><p>单例设计模式：Spring Bean默认都是单例实现</p>
</li>
<li><p>包装器设计模式：不同的客户在每次访问中根据需要会去访问不同的数据库，这种模式可以让我们根据客户的需求能够动态切换不同的数据源</p>
</li>
<li><p>观察者模式:Spring事件驱动模型</p>
</li>
<li><p>适配器模式</p>
</li>
</ul>
<h3 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</li>
<li>一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。</li>
<li>隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。</li>
<li>持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。</li>
</ul>
<h4 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h4><p>Spring支持编程式事务管理以及声明式事务管理两种方式。</p>
<p><strong>编程式事务管理</strong></p>
<p>编程式事务管理是侵入性事务管理，使用TransactionTemplate或者直接使用PlatformTransactionManager，对于编程式事务管理，Spring推荐使用TransactionTemplate。</p>
<p><strong>声明式事务管理</strong></p>
<p>声明式事务管理建立在AOP之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。<br>编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过注解的方式，便可以将事务规则应用到业务逻辑中。<br>显然声明式事务管理要优于编程式事务管理，这正是Spring倡导的非侵入式的编程方式。唯一不足的地方就是声明式事务管理的粒度是方法级别，而编程式事务管理是可以到代码块的，但是可以通过提取方法的方式完成声明式事务管理的配置。</p>
<h4 id="传播机制"><a href="#传播机制" class="headerlink" title="传播机制"></a>传播机制</h4><p>PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</p>
<p>PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。</p>
<p>PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。</p>
<p>PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。</p>
<p>PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
<p>PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<p>PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>事务的隔离级别定义一个事务可能受其他并发务活动活动影响的程度，可以把事务的隔离级别想象为这个事务对于事物处理数据的自私程度。</p>
<p>在一个典型的应用程序中，多个事务同时运行，经常会为了完成他们的工作而操作同一个数据。并发虽然是必需的，但是会导致以下问题：</p>
<ol>
<li>脏读（Dirty read）<br>脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。</li>
<li>不可重复读（Nonrepeatable read）<br>不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。</li>
</ol>
<blockquote>
<p>不可重复读重点在修改。</p>
</blockquote>
<ol>
<li>幻读（Phantom reads）<br>幻读和不可重复读相似。当一个事务（T1）读取几行记录后，另一个并发事务（T2）插入了一些记录时，幻读就发生了。在后来的查询中，第一个事务（T1）就会发现一些原来没有的额外记录。</li>
</ol>
<blockquote>
<p>幻读重点在新增或删除。</p>
</blockquote>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ISOLATION_DEFAULT</td>
<td>使用后端数据库默认的隔离级别</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>允许读取尚未提交的更改。可能导致脏读、幻读或不可重复读。</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>（Oracle 默认级别）允许从已经提交的并发事务读取。可防止脏读，但幻读和不可重复读仍可能会发生。</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>（MYSQL默认级别）对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻读仍可能发生。</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。</td>
</tr>
</tbody></table>
<p>事物配置中有哪些属性可以配置?以下只是简单的使用参考</p>
<ol>
<li>事务的传播性：<br>@Transactional(propagation=Propagation.REQUIRED)</li>
<li>事务的隔离级别：<br>@Transactional(isolation = Isolation.READ_UNCOMMITTED)</li>
<li>只读：<br>@Transactional(readOnly=true)<br>该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。</li>
<li>事务的超时性：<br>@Transactional(timeout=30)</li>
<li>回滚：<br>指定单一异常类：@Transactional(rollbackFor=RuntimeException.class)<br>指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class})</li>
</ol>
<h3 id="Transactional-rollbackFor-Exception-class"><a href="#Transactional-rollbackFor-Exception-class" class="headerlink" title="Transactional(rollbackFor=Exception.class)"></a>Transactional(rollbackFor=Exception.class)</h3><p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
<h3 id="一些常用的注解"><a href="#一些常用的注解" class="headerlink" title="一些常用的注解"></a>一些常用的注解</h3><h4 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h4><p>GET 请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;users&quot;)` 等价于`@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.GET)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() &#123;</span><br><span class="line"> <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>POST 请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;users&quot;)` 等价于`@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.POST)</span><br></pre></td></tr></table></figure>

<p>关于<code>@RequestBody</code>注解的使用，在下面的“前后端传值”这块会讲到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserCreateRequest userCreateRequest)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> userRespository.save(userCreateRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PUT 请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PutMapping(&quot;/users/&#123;userId&#125;&quot;)` 等价于`@RequestMapping(value=&quot;/users/&#123;userId&#125;&quot;,method=RequestMethod.PUT)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/users/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">updateUser</span><span class="params">(<span class="meta">@PathVariable(value = &quot;userId&quot;)</span> Long userId,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserUpdateRequest userUpdateRequest)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DELETE 请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@DeleteMapping(&quot;/users/&#123;userId&#125;&quot;)`等价于`@RequestMapping(value=&quot;/users/&#123;userId&#125;&quot;,method=RequestMethod.DELETE)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/users/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable(value = &quot;userId&quot;)</span> Long userId)</span></span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>PATCH 请求</strong></p>
<p>一般实际项目中，我们都是 PUT 不够用了之后才用 PATCH 请求去更新数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PatchMapping(&quot;/profile&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">updateStudent</span><span class="params">(<span class="meta">@RequestBody</span> StudentUpdateRequest studentUpdateRequest)</span> </span>&#123;</span><br><span class="line">      studentRepository.updateDetail(studentUpdateRequest);</span><br><span class="line">      <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="前后端传值"><a href="#前后端传值" class="headerlink" title="前后端传值"></a>前后端传值</h4><p><strong><code>@PathVariable</code> 和 <code>@RequestParam</code></strong></p>
<p><code>@PathVariable</code>用于获取路径参数，<code>@RequestParam</code>用于获取查询参数。</p>
<p>举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/klasses/&#123;klassId&#125;/teachers&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Teacher&gt; <span class="title">getKlassRelatedTeachers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="meta">@PathVariable(&quot;klassId&quot;)</span> Long klassId,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="meta">@RequestParam(value = &quot;type&quot;, required = false)</span> String type )</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们请求的 url 是：<code>/klasses/123456/teachers?type=web</code></p>
<p>那么我们服务获取到的数据就是：<code>klassId=123456,type=web</code>。</p>
<p><strong><code>@RequestBody</code></strong></p>
<p>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且<strong>Content-Type 为 application/json</strong> 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用<code>HttpMessageConverter</code>或者自定义的<code>HttpMessageConverter</code>将请求的 body 中的 json 字符串转换为 java 对象。</p>
<p>我用一个简单的例子来给演示一下基本使用！</p>
<p>我们有一个注册的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign-up&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">signUp</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> UserRegisterRequest userRegisterRequest)</span> </span>&#123;</span><br><span class="line">  userService.save(userRegisterRequest);</span><br><span class="line">  <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserRegisterRequest</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRegisterRequest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发送 post 请求到这个接口，并且 body 携带 JSON 数据：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;userName&quot;</span>:<span class="string">&quot;coder&quot;</span>,<span class="attr">&quot;fullName&quot;</span>:<span class="string">&quot;shuangkou&quot;</span>,<span class="attr">&quot;password&quot;</span>:<span class="string">&quot;123456&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的后端就可以直接把 json 格式的数据映射到我们的 <code>UserRegisterRequest</code> 类上。</p>
<h4 id="读取配置信息"><a href="#读取配置信息" class="headerlink" title="读取配置信息"></a>读取配置信息</h4><p><strong>很多时候我们需要将一些常用的配置信息比如阿里云 oss、发送短信、微信认证的相关配置信息等等放到配置文件中。</strong></p>
<p><strong>下面我们来看一下 Spring 为我们提供了哪些方式帮助我们从配置文件中读取这些配置信息。</strong></p>
<p>我们的数据源<code>application.yml</code>内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wuhan2020:</span> <span class="number">2020</span><span class="string">年初武汉爆发了新型冠状病毒，疫情严重，但是，我相信一切都会过去！武汉加油！中国加油！</span></span><br><span class="line"></span><br><span class="line"><span class="attr">my-profile:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Guide哥</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">koushuangbwcx@163.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">library:</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">湖北武汉加油中国加油</span></span><br><span class="line">  <span class="attr">books:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">天才基本法</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">时间的秩序</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">了不起的我</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？</span> <span class="string">如何走出人生的艰难时刻？</span></span><br></pre></td></tr></table></figure>

<p><strong><code>@Value</code>(常用)</strong></p>
<p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 读取比较简单的配置信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;wuhan2020&#125;&quot;)</span></span><br><span class="line">String wuhan2020;</span><br></pre></td></tr></table></figure>

<p><strong><code>@ConfigurationProperties</code>(常用)</strong></p>
<p>通过<code>@ConfigurationProperties</code>读取配置信息并与 bean 绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;library&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LibraryProperties</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; books;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        String description;</span><br><span class="line">    &#125;</span><br><span class="line">  省略getter/setter</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以像使用普通的 Spring bean 一样，将其注入到类中使用。</p>
<p> <strong>5.3. <code>@PropertySource</code>（不常用）</strong></p>
<p><code>@PropertySource</code>读取指定 properties 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:website.properties&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">  省略getter/setter</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h3><ul>
<li><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为<code>com.mysql.jdbc.Driver</code>。</li>
<li><code>#&#123;&#125;</code>是 sql 的参数占位符，Mybatis 会将 sql 中的<code>#&#123;&#125;</code>替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#&#123;item.name&#125;</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li>
</ul>
<h3 id="分页方式"><a href="#分页方式" class="headerlink" title="分页方式"></a>分页方式</h3><p>正常人，一般使用物理分页</p>
<p>分为物理分页和逻辑分页</p>
<p><strong>(1)</strong> MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；**(2)** 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，**(3)** 也可以使用分页插件来完成物理分页。 </p>
<p>所谓逻辑分页，是指使用MyBatis自带的RowBound进行分页，它会一次性查出多条数据，然后再检索分页中的数据，具体一次性查询多少条数据，受封装jdbc配置的fetch-size决定</p>
<p>而物理分页，是从数据库中查询指定条数的数据，而我们用的分页插件PageHelper实现的就是物理分页</p>
<h3 id="常见标签"><a href="#常见标签" class="headerlink" title="常见标签"></a>常见标签</h3><p>常见的 select insert update delete</p>
<p>还有 resultMap,parameterMap,sql,include,selectKey,</p>
<p>动态sql 的9个标签 trim where set foreach if choose when otherwise bind等 sql为sql片段标签，通过include标签引入sql片段，selectKey为不支持自增的主键生成策略标签。</p>
<h3 id="Dao-接口的工作原理是什么？"><a href="#Dao-接口的工作原理是什么？" class="headerlink" title="Dao 接口的工作原理是什么？"></a>Dao 接口的工作原理是什么？</h3><p>Dao 接口，就是人们常说的 <code>Mapper</code> 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 <code>MappedStatement</code> 的 id 值，接口方法内的参数，就是传递给 sql 的参数。 <code>Mapper</code> 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 <code>MappedStatement</code> ，举例： <code>com.mybatis3.mappers. StudentDao.findStudentById</code> ，可以唯一找到 namespace 为 <code>com.mybatis3.mappers. StudentDao</code> 下面 <code>id = findStudentById</code> 的 <code>MappedStatement</code> 。在 MyBatis 中，每一个 <code>&lt;select&gt;</code> 、 <code>&lt;insert&gt;</code> 、 <code>&lt;update&gt;</code> 、 <code>&lt;delete&gt;</code> 标签，都会被解析为一个 <code>MappedStatement</code> 对象。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz2njni4tbj311c0u0777.jpg" alt="image-20220205151001519"></p>
<p>Dao 接口方法可以重载，但是需要满足以下条件：</p>
<ol>
<li>仅有一个无参方法和一个有参方法</li>
<li>多个有参方法时，参数数量必须一致。且使用相同的 <code>@Param</code> ，或者使用 <code>param1</code> 这种</li>
</ol>
<h2 id="IO流的分类以及选择"><a href="#IO流的分类以及选择" class="headerlink" title="IO流的分类以及选择"></a>IO流的分类以及选择</h2><p>按方向分：输入流 输出流 输入流用于读文件 输出流用于写文件</p>
<p>按读取的单位分：字节流( 二进制文件)字符流(文本文件)</p>
<p>按处理的方式分：节点流 处理流</p>
<p>IO流的4大基本类：InputStream OutPutStream Reader,Writer</p>
<h2 id="序列化和反序列化的定义"><a href="#序列化和反序列化的定义" class="headerlink" title="序列化和反序列化的定义"></a>序列化和反序列化的定义</h2><p>  (1)Java序列化就是指把Java对象转换为字节序列的过程</p>
<p>​    Java反序列化就是指把字节序列恢复为Java对象的过程。</p>
<p>  (2)序列化最重要的作用：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序字节流,以便在网络上传输或者保存在本地文件中。</p>
<p>​    反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。</p>
<p>  总结：核心作用就是对象状态的保存和重建。（整个过程核心点就是字节流中所保存的对象状态及描述信息）</p>
<h3 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h3><p>当执行序列化时，我们写对象到磁盘中，会根据当前这个类的结构生成一个版本号id</p>
<p>当反序列化时，程序会比较磁盘中的序列化版本号ID跟当前的类结构生成的版本号ID是否一致，如果一致则成功，否则失败</p>
<p>加上版本号，有助于当我们的类结构发生了变化，依然可以之前已经序列化的对象反序列化成功</p>
<h2 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h2><p>异常体系保证程序的健壮性</p>
<p>Java 标准库内建了一些通用的异常，这些类以Throwable为顶层父类</p>
<p>Throwalble又派生出Error类和Exception类</p>
<p>**Error:**Error类以及他的子类的实例，代表了JVM本身的错误，错误不能被程序员通过代码处理，Error很少出现</p>
<p>**Exception:**Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gys94615ykj31aa0taq5o.jpg" alt="image-20220127151508581"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gys95810qlj31bm0jojxa.jpg" alt="image-20220127151606585"></p>
<p><img src="/2020/11/09/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/2.png"></p>
<p>常见的5个运行时异常</p>
<p>这类异常，编译时没有提示异常处理，因此通常此类异常的正确理解应该是逻辑错误</p>
<ul>
<li>算数异常</li>
<li>空指针异常</li>
<li>类型转化异常</li>
<li>数组越界</li>
<li>NumberFormateException 数字格式异常，转化失败，比如a12转化失败</li>
</ul>
<p>常见的5个非运行时异常</p>
<ul>
<li>IOException</li>
<li>SQLException</li>
<li>FileNotFoundException</li>
<li>NoSuchFileException</li>
<li>NoSuchMethodException</li>
</ul>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p> JVM 文件中</p>
<p>Java 核心类由一个名为BootstrapClassLoader来加载 ——-jre/lib   getClassLoader得到的结果是null</p>
<p>Java扩展类，是由ExtClassLoader——jre/lib/ext</p>
<p>项目中编写的类 由AppClassLoader——-第三方的jar包和自己开发的类</p>
<p>从上到下寻找类 </p>
<p>这里面就要基于双亲委托机制？</p>
<p>所谓双亲委托机制，就是加载一个类，会先获取到一个系统类加载器AppClassLoader的实例，然后往上层层请求，先由BootstarpClassLoader去加载，如果BootStrapClassLoader发现没有，再下发给ExtClassLoader去加载，还是没有，才由AppClassLoader去加载。如果还是没有，则报错</p>
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p>Web层：负责与用户交互并对外提供服务接口</p>
<p>业务逻辑层：实现业务逻辑模块</p>
<p>数据存取层：将业务逻辑层处理的结果持久化，方便后续查询</p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>Model 模型代表一个存取数据的对象或JAVA POJO</p>
<p>View 视图代表模型包含的数据的可视化 HTML JSP Thymeleaf</p>
<p>Controller 控制器作用于模型和视图上，它控制数据流向模型对象，并在数据变化时更新视图，它将视图与模型分开，目前的代表技术是servlet</p>
<h2 id="并发并行"><a href="#并发并行" class="headerlink" title="并发并行"></a>并发并行</h2><p>并发：同一个CPU执行多个任务，按细分的时间片交替执行</p>
<p>并行：多个CPU上同时执行多个任务</p>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><ul>
<li><strong>大小限制</strong>：<strong>栈底</strong>的地址和栈的<strong>最大容量</strong>是系统预先规定好的（2M/1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间, stack overflow。因此，能从栈获得的空间较小。<strong>堆</strong>是用<strong>链表</strong>来存储的<strong>不连续</strong>内存区域，大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较<strong>灵活</strong>，也比较<strong>大</strong>。</li>
<li><strong>申请效率</strong>：栈由系统自动分配，速度较<strong>快</strong>。但程序员是<strong>无法控制</strong>的。堆是由new分配的内存，一般速度比较<strong>慢</strong>，而且容易产生内存<strong>碎片</strong>,不过用起来最<strong>方便</strong>.</li>
<li><strong>存储内容</strong>：栈存储<strong>返回地址，参数，局部变量</strong>。<strong>堆</strong>在这块内存空间中的首地址处记录本次分配的大小，具体内容由程序员安排。</li>
<li><strong>数据访问</strong>：存储在堆中的对象是<strong>全局可以被访问</strong>的，然而栈内存<strong>不能</strong>被其他线程所访问，且遵循<strong>LIFO</strong>原则。</li>
<li><strong>生命周期</strong>：栈内存的生命周期很短，而堆内存的生命周期从程序的运行开始到运行结束。</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><img src="/2020/11/09/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/3.png"></p>
<p><strong>冒泡排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)</span><br><span class="line">                <span class="keyword">if</span> (array[j + <span class="number">1</span>] &lt; array[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>选择排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次选择最小的放前面 分为有序区和无序区 最稳定 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; array[minIndex]) <span class="comment">//找到最小的数</span></span><br><span class="line">                minIndex = j; <span class="comment">//将最小数的索引保存</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = array[minIndex];</span><br><span class="line">        array[minIndex] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="keyword">int</span> current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        current = array[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> preIndex = i;</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; array[preIndex]) &#123;</span><br><span class="line">            array[preIndex + <span class="number">1</span>] = array[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快速排序</strong></p>
<p>快排优化：</p>
<p>1.选取基数时采用三数取中</p>
<p>2.当排序序列的长度分割到一定大小后，采用插入排序</p>
<p>3.在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</p>
<p>4.使用并行或多线程处理子序列（略）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        randomizedQuicksort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">randomizedQuicksort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = randomizedPartition(nums, l, r);</span><br><span class="line">            randomizedQuicksort(nums, l, pos - <span class="number">1</span>);</span><br><span class="line">            randomizedQuicksort(nums, pos + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomizedPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Random().nextInt(r - l + <span class="number">1</span>) + l; <span class="comment">// 随机选一个作为我们的主元</span></span><br><span class="line">        swap(nums, r, i);</span><br><span class="line">        <span class="keyword">return</span> partition(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[r];</span><br><span class="line">        <span class="keyword">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序。堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</span></span><br><span class="line"><span class="comment">它的基本思想是将待排序的序列构造成一个大顶堆（或小顶堆）。此时，整个序列的最大值就是堆顶的根节点，将其与堆数组的末尾元素交换，此时末尾元素就是最大值，然后将剩余的 n-1 个序列重新构造成一个最大堆，再将新的最大堆的顶与末尾元素交换，如此反复执行，便能得到一个有序序列了。</span></span><br><span class="line"><span class="comment">堆排序中重要的一个部分是不断调整堆使其满足最大堆的性质，即父节点都比子节点的值大。调整最大堆的算法如下所示，输入为一个数组A和一个下标i，它用来维护以下标i为根结点的子树最大堆的性质，通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为结点的子树重新遵循最大堆的性质。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        buildMaxHeap(arr);</span><br><span class="line">        <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">        <span class="comment">//最大值的节点与最后一个节点交换位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            <span class="comment">//最后一个节点为最大值后，再对前边节点进行堆排序，每交换出一个最大值，最大堆的大小减1</span></span><br><span class="line">            heapSize--;</span><br><span class="line">            maxHeapify(arr, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4 3 9 5 10 2 6</span></span><br><span class="line"><span class="comment">     * 0 1 2 3 4  5 6</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *       4</span></span><br><span class="line"><span class="comment">     *   3       9</span></span><br><span class="line"><span class="comment">     * 5   10  2   6 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 要进行调整的节点位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapSize 最大堆的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftIndex = <span class="number">2</span> * index + <span class="number">1</span>;<span class="comment">//左节点</span></span><br><span class="line">        <span class="keyword">int</span> rightIndex = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> largeIndex;<span class="comment">//临时存储三个节点中最大的节点</span></span><br><span class="line">        <span class="keyword">if</span> (leftIndex &lt; heapSize &amp;&amp; arr[leftIndex] &gt; arr[index]) &#123;</span><br><span class="line">            largeIndex = leftIndex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            largeIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt; heapSize &amp;&amp; arr[rightIndex] &gt; arr[largeIndex]) &#123;</span><br><span class="line">            largeIndex = rightIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largeIndex != index) &#123;</span><br><span class="line">            <span class="comment">//与最大值的节点交换位置</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[largeIndex];</span><br><span class="line">            arr[largeIndex] = arr[index];</span><br><span class="line">            arr[index] = temp;</span><br><span class="line">            <span class="comment">//递归的方式对新的节点进行最大堆调整</span></span><br><span class="line">            maxHeapify(arr, largeIndex, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立最大堆，遍历其中的非叶子节点，调整位置，达到最大堆的特点，即父节点的值大于子节点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (arr.length - <span class="number">2</span>) / <span class="number">2</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">            maxHeapify(arr, i, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] test = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        heapSort(test);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;test.length; i++)&#123;</span><br><span class="line">            System.out.print(test[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul>
<li><p>ls 查看目录中的文件</p>
</li>
<li><p>cd /home 进入 ‘/ home’ 目录；cd .. 返回上一级目录；cd ../.. 返回上两级目录</p>
</li>
<li><p>mkdir dir1 创建一个叫做 ‘dir1’ 的目录</p>
</li>
<li><p>rmdir dir1 删除一个叫做 ‘dir1’ 的目录 （只能删除空目录）</p>
</li>
<li><p>rm -f file1 删除一个叫做 ‘file1’ 的文件’，-f 参数，忽略不存在的文件，从不给出提示。</p>
</li>
<li><p>rm -rf /mulu  目录下面文件以及子目录下文件</p>
</li>
<li><p>cp /test1/file1 /test3/file2  如将/test1目录下的file1复制到/test3目录，并将文件名改为file2</p>
</li>
<li><p>mv /test1/file1 /test3/file2  如将/test1目录下的file1移动到/test3 目录，并将文件名改为file2</p>
</li>
<li><p>mv * ../ Linux当前目录所有文件移动到上一级目录</p>
</li>
<li><p>ps -ef|grep xxx 显示进程pid</p>
</li>
<li><p>kill  使用kill命令来终结进程。先使用ps命令找到进程id，使用kill -9命令，终止进程。</p>
</li>
<li><p>tar –xvf file.tar  解压 tar包</p>
</li>
<li><p>unzip file.zip 解压zip</p>
</li>
<li><p>unrar e file.rar 解压rar</p>
</li>
<li><p>free -m  查看服务器内存使用情况</p>
</li>
<li><p>逻辑CPU个数： # cat /proc/cpuinfo | grep ‘processor’ | wc -l</p>
</li>
<li><p>物理CPU个数： # cat /proc/cpuinfo | grep ‘physical id’ | sort | uniq | wc -l</p>
</li>
<li><p>每个物理CPU中Core的个数： # cat /proc/cpuinfo | grep ‘cpu cores’ | wc -l</p>
</li>
<li><p>cpu详细信息：#cat /proc/cpuinfo</p>
</li>
</ul>
<h3 id="Linux-查看端口号被哪个进程占用"><a href="#Linux-查看端口号被哪个进程占用" class="headerlink" title="Linux 查看端口号被哪个进程占用"></a>Linux 查看端口号被哪个进程占用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">losf -i:22(22为端口号)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 能够看到COMMAND 进程的名称 PID 进程标识符 USER FD文件描述符</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp|grep 端口号，用于查看指定端口号的进程情况，如查看22端口的情况，netstat -tunlp|grep 22</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gzcxgfvawtj30k2035dga.jpg" alt="img"></p>
<h3 id="查看日志文件"><a href="#查看日志文件" class="headerlink" title="查看日志文件"></a>查看日志文件</h3><p>查看日志常用命令</p>
<p>  tail:  </p>
<p>​    -n  是显示行号；相当于nl命令；例子如下：</p>
<p>​      <strong>tail -100f test.log    实时监控100行日志</strong></p>
<p>​      tail -n 10 test.log  查询日志尾部最后10行的日志;</p>
<p>​      tail -n +10 test.log  查询10行之后的所有日志;</p>
<p>  head:  </p>
<p>​    跟tail是相反的，tail是看后多少行日志；例子如下：</p>
<p>​      head -n 10 test.log  查询日志文件中的头10行日志;</p>
<p>​      head -n -10 test.log  查询日志文件除了最后10行的其他所有日志;</p>
<p>  cat： </p>
<p>​    tac是倒序查看，是cat单词反写；例子如下：</p>
<p>​      <strong>cat -n test.log |grep “debug”  查询关键字的日志</strong></p>
<p><strong>应用场景一：按行号查看—过滤出关键字附近的日志</strong></p>
<p>   1）cat -n test.log |grep “debug” 得到关键日志的行号</p>
<p>   2）cat -n test.log |tail -n +92|head -n 20  选择关键字所在的中间一行. 然后查看这个关键字前10行和后10行的日志:</p>
<p>​      tail -n +92表示查询92行之后的日志</p>
<p>​      head -n 20 则表示在前面的查询结果里再查前20条记录</p>
<p>  <strong>应用场景二：根据日期查询日志</strong></p>
<p>   sed -n ‘/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p’ test.log</p>
<p>   特别说明:上面的两个日期必须是日志中打印出来的日志,否则无效；</p>
<p>​           先 grep ‘2014-12-17 16:17:20’ test.log 来确定日志中是否有该 时间点</p>
<p> <strong>应用场景三：日志内容特别多，打印在屏幕上不方便查看</strong></p>
<p>  (1)使用more和less命令,</p>
<p>​      如： cat -n test.log |grep “debug” |more   这样就分页打印了,通过点击空格键翻页</p>
<p>  (2)使用 &gt;xxx.txt 将其保存到文件中,到时可以拉下这个文件分析</p>
<p>​      如：cat -n test.log |grep “debug” &gt;debug.txt</p>
<h3 id="找出日志文件中访问量最大的top10-ip地址"><a href="#找出日志文件中访问量最大的top10-ip地址" class="headerlink" title="找出日志文件中访问量最大的top10 ip地址"></a>找出日志文件中访问量最大的top10 ip地址</h3><p>日志文件中第三列为ip地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.log|awk -F &quot; &quot; &#x27;&#123;print $3&#125;&#x27;|sort|uniq -c|sort -nrk 1|awk -F &quot; &quot; &#x27;&#123;print $2&#125;&#x27;|head -10</span><br></pre></td></tr></table></figure>

<p>1.cat *.log将文本内容打印到屏幕</p>
<p>2.使用awk命令可以按照分割符将一行分割为多个列，第一列用$1表示，第二列用$2表示，依次类推</p>
<p>awk -F” “ ‘{print $3} //表示用空格作为分隔符进行分割，打印出第3列</p>
<p>3.sort 进行排序，默认是按照ascii码进行排序的</p>
<p>4.uniq -c 统计相邻的行的重复数量，结果是类似 3 127.13.13.13,前面的数字代码重复的行数</p>
<p>sort|uniq -c //统计重复的行数</p>
<p>5.sort -n是按照数值进行由小到大进行排序， -r是表示逆序，-k是执行按照第几列进行排序</p>
<p>sort -nrk 1</p>
<p>6.使用awk命令可以按照分割符将一行分割为多个列，第一列用$1表示，第二列用$2表示，依次类推</p>
<p>awk -F” “ ‘{print $2}’ //表示用空格作为分隔符进行分割，打印出第2列</p>
<p>7.head -n表示取前n个<br>————————————————</p>
<h2 id="select和epoll区别"><a href="#select和epoll区别" class="headerlink" title="select和epoll区别"></a>select和epoll区别</h2><ul>
<li>select和epoll都是同步io多路复用机制。</li>
<li>select使用超时轮询的方式对文件描述符集合进行监视。先将进程从工作队列加入到文件描述符的等待队列中，使进程阻塞，在超时时间内如果有文件描述符就绪，产生中断，唤醒进程，将进程从等待队列重新放回到工作队列中。但是进程只知道有文件描述符就绪，而不知道是哪一个或哪几个，所以要将文件描述符集合从用户态空间复制到内核态中，进行遍历。o(n)的复杂度，即无差别轮询。</li>
<li>epoll相比于select加入了回调函数机制和维护了一个就绪列表。当有文件描述符就绪时，产生中断，通过回调换数将就绪文件描述符的引用加入到就绪列表中，进程唤醒后只需要处理就绪列表即可。复杂度为o(1)，即只关注活跃的文件描述符和连接。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">epoll_create(); //创建epoll对象</span><br><span class="line">epoll_ctr();  //维护监视列表，将文件描述符添加到epoll对象中或进行删除</span><br><span class="line">epoll_wait();   //对就绪列表里的文件描述符进行处理</span><br></pre></td></tr></table></figure>

<p>就绪列表采用双向链表，方便维护有序和插入删除fd<br>监视列表采用红黑树，方便维护有序和插入删除fd<br>就绪列表的节点为红黑树节点的间接引用、</p>
<p>select 异步阻塞设计，具有良好的跨平台支持。原理<br>发送io后即返回，当内核文件加载好后，通过socket<br>发送消息提醒用户线程任务可以继续执行，单个IO速度并没有改善，但是配合多线程使用，可以同时进行多个IO任务</p>
<p>但是其具有一个缺点，select在单个进程中能够监听的文件描述符的数量存在最大限制，在linux上为1024，对于socket进行扫描时是依次扫描，效率低，浪费cpu时间。</p>
<p>epoll的优点：<br>并没有最大连接限制，没有监听上限，效率提升不是轮询的方式，只有活跃的FD才会调用callback函数</p>
<p>两种工作模式：<br>LT模式：当epoll检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll时，会再次响应应用程序并通知此事件。</p>
<p>ET模式：当epoll检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll时，不会再次响应应用程序并通知此事件。</p>
<h2 id="CPU调度算法"><a href="#CPU调度算法" class="headerlink" title="CPU调度算法"></a>CPU调度算法</h2><p>1、先到先服务调度算法（FCFS）</p>
<p>　　根据就绪队列的到达时间来服务，此时就绪队列是一个FIFO队列，先到先服务，后到的线程不能抢占前面正在服务的线程。这种算法的优点是实现简单，缺点也很明显，就是CPU进程区间变化很大时，平均等待时间会变化很大。</p>
<p>2、最短作业优先调度（SJF）</p>
<p>　　顾名思义，就是CPU进程区间最短的先执行，如果两个进程区间具有同样的长度，那么按照FCFS来调度。</p>
<p>　　SJF可以是抢占的，也可以是不抢占的。它的平均等待时间优于FCFS。</p>
<p>3、优先级调度</p>
<p>　　其实上面的SJF算法就是一种特殊的优先级调度，只不过这里的优先级定义更加广泛一些，SJF算法的优先级是按照CPU进程区间长短来定义的，这里的优先级可以是其他的一些定义。</p>
<p>　　优先级调度可以是抢占的，也可以是非抢占的。</p>
<p>　　优先级调度的一个主要问题是无穷阻塞（也称为饥饿），如果一个线程的优先级很低，可能需要等待很长的时间才能到这个线程执行，甚至永远不执行，一种解决方法是老化（随着时间的增长，增加线程的优先级）</p>
<p>4、轮转法调度（RR）</p>
<p>　　轮转法调度专门是为分时系统设计的。它类似于FCFS，但是增加了抢占为了切换线程。定义一个较小的时间单元，称为时间片，通常为10-100ms。为了实现RR算法，将就绪队列保存为FIFO队列，新进程增加到就绪队列队尾，CPU调度程序从就绪队列选择第一个进程，设置定时器在一个时间片之后再中断，再分派这个进程。</p>
<p>　　如果该进程的CPU区间小于时间片，进程本身就会释放CPU，调度程序继续处理下一个进程，如果当前进程的CPU区间比时间片长，定时器会产生CPU中断，实行上下文切换，然后将此进程放到就绪队列队尾，继续调度就绪队列第一个进程。</p>
<p>5、多级队列调度：</p>
<p>　　这里对进程进行分组，在组内使用FCFS和SJF算法，在组间实行优先级调度或者轮转法调度。但是不允许进程在组间切换。</p>
<p>6、多级反馈队列调度</p>
<p>　　允许进程在组间切换，主要思想是根据不同区间的特点区分进程，如果CPU进程占用过多CPU时间，那么它会被转移到更低优先级队列。这种形式老化阻止饥饿。</p>
<h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><h3 id="存储ip地址，用什么数据类型比较好"><a href="#存储ip地址，用什么数据类型比较好" class="headerlink" title="存储ip地址，用什么数据类型比较好"></a>存储ip地址，用什么数据类型比较好</h3><p>以ipv4为例子介绍，ipv4的大小为32bits(4Bytes),在使用过程中，我们通常是用点分十进制格式，如192.168.120.11，问题就是如何把192.168.120.11存入到数据库中。</p>
<p>考虑下面三个因素 </p>
<ul>
<li>可读性</li>
<li>存储效率</li>
<li>查询效率</li>
</ul>
<p>把”192.168.120.65”存储到数据库中有多少中可行方法呢？见下表所示：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>大小</strong></th>
<th><strong>注释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>varchar(15)</td>
<td>占7～15字节</td>
<td>可读性最好（192.168.120.65），但是最费存储空间</td>
</tr>
<tr>
<td>bigint</td>
<td>8 字节</td>
<td>可以将ip地址存储为类似192168120065的格式，这种可读性稍差，也比较费存储空间</td>
</tr>
<tr>
<td>int</td>
<td>4 字节</td>
<td>这种可读性很差，会存储为1084782657，由192<em>16777216+168</em>65536+120*256+65-2147483648计算所得，占用存储空间少。</td>
</tr>
<tr>
<td>tinyint</td>
<td>4 字节</td>
<td>用4个字段来分开存储ip地址，可读性稍差（分别为192， 168， 120， 65），存储空间占用少</td>
</tr>
<tr>
<td>varbinary(4)</td>
<td>4 字节</td>
<td>可读性差（0xC0A87841），存储空间占用少</td>
</tr>
</tbody></table>
<p>高性能MySql中，作者建议当存储IPV4地址时，应该使用32位的无符号整数(UNSIGNED INT)来存储地址，而不是使用字符串</p>
<p>(无符号版本和有符号版本的区别就是无符号类型能保存2倍于有符号类型的正整数数据，比如16位系统中一个smallint能存储的数据的范围为-32768<del>32767，而unsigned能存储的数据范围则是0</del>65535。)</p>
<p>相对字符串存储，使用无符号整数来存储有如下的好处：</p>
<ul>
<li><strong>节省空间，不管是数据存储空间，还是索引存储空间</strong></li>
<li><strong>便于使用范围查询（BETWEEN…AND），且效率更高</strong></li>
</ul>
<p>使用无符号整数来存储也有缺点：</p>
<ul>
<li>不便于阅读</li>
<li>需要手动转换</li>
</ul>
<p>MySQL中提供了函数将字符串格式的IP地址转换成整数INET_ATON,以及反过来的转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select inet_aton(&#x27;192.168.0.1&#x27;);</span><br><span class="line">+--------------------------+</span><br><span class="line">| inet_aton(&#x27;192.168.0.1&#x27;) |</span><br><span class="line">+--------------------------+</span><br><span class="line">| 3232235521 |</span><br><span class="line">+--------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select inet_ntoa(3232235521);</span><br><span class="line">+-----------------------+</span><br><span class="line">| inet_ntoa(3232235521) |</span><br><span class="line">+-----------------------+</span><br><span class="line">| 192.168.0.1 |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>对于IPv6来说，使用VARBINARY同样可获得相同的好处，同时MySQL也提供了相应的转换函数，即INET6_ATON和INET6_NTOA。gezho</p>
<h3 id="100亿个数据中找出最大的100个"><a href="#100亿个数据中找出最大的100个" class="headerlink" title="100亿个数据中找出最大的100个"></a>100亿个数据中找出最大的100个</h3><p>海量数据处理，思路基本上是：必须分块处理，然后再合并起来。</p>
<p>1.采用小顶堆算法<br>我们知道完全二叉树有几个非常重要的特性，就是假如该二叉树中总共有N个节点，那么该二叉树的深度就是log2N，对于小顶堆来说移动根元素到 底部或者移动底部元素到根部只需要log2N，相比N来说时间复杂度优化太多了（1亿的logN值是26-27的一个浮点数）。基本的思路就是先从文件中取出1000个元素构建一个小顶堆数组k，然后依次对剩下的100亿-1000个数字进行遍历m，如果m大于小顶堆的根元素，即k[0]，那么用m取代k[0]，对新的数组进行重新构建组成一个新的小顶堆。这个算法的时间复杂度是O((100亿-1000)log(1000))，即O((N-M)logM)，空间复杂度是M</p>
<p>这个算法优点是性能尚可，空间复杂度低，IO读取比较频繁，对系统压力大。</p>
<p>2.采用分区法<br>将100亿个数据分成1000个分区，每个分区上1000万个数据，在每个分区上上再细分成100个分区，即总共分成1000*100个分区，然后启动多线程进行处理，各个分区上采用小顶堆算法取出最大的1000个数据，分层进行合并然后重新计算不同层上的最大1000个数，最终递归到最上层。 但linux系统上一个进程能启动的默认线程数是1024个，所以要么调整最大线程数，要么在线程调用处做一些处理，比如一个线程完成一个分区之后再去处理相邻的分区，或者在分区的时候把所有的分区数目限制在1024之内。这个算法切合了map-reduce的思想，利用了多线程和多处理器的优势，减少了多余的比较和IO读取，性能比第一种会更好但算法更复杂一点，要考虑的情况也更多。</p>
<h3 id="几条机器每台存储着几亿条搜索日志，只有一台2G的电脑，怎么选出搜索热度最高的十个搜索关键词"><a href="#几条机器每台存储着几亿条搜索日志，只有一台2G的电脑，怎么选出搜索热度最高的十个搜索关键词" class="headerlink" title="几条机器每台存储着几亿条搜索日志，只有一台2G的电脑，怎么选出搜索热度最高的十个搜索关键词"></a>几条机器每台存储着几亿条搜索日志，只有一台2G的电脑，怎么选出搜索热度最高的十个搜索关键词</h3><p>先对文件进行分流，分流采用hash，这样相同的关键字必然是分到一起，然后分别统计每一个分流上每个关键字出现的次数并分别排序，将前十个关键字保存下来，如此过程，将所有的划分的日志做相同过程，得到多份热度最高的十个关键字，归并排序这些关键字。</p>
<p>一次大概读取2G的数据进入内存，然后对这2G数据进行关键词次数统计并排序（这里统计可以使用mapreduce的思想）然后取关键词出现次数最多的10个然后将这10个关键词以及出现次数存入硬盘；重复上面的操作将所有的搜索日志分批读入内存生成小文件；然后归并排序</p>
<h3 id="从海量数据中找出中位数"><a href="#从海量数据中找出中位数" class="headerlink" title="从海量数据中找出中位数"></a>从海量数据中找出中位数</h3><p>题目：一个文件中有 10G 个整数，乱序排列，要求找出中位数。内存限制为 2G。只写出思路即可(内存限制为 2G的意思就是，可以使用2G的空间来运行程序，而不考虑这台机器上的其他软件的占用内存)。</p>
<p>0亿个数字，每个数字在内存中占4B，10亿个数字完全加载到内存中需要：10<em>108</em>4B ，约为：4GB内存。显然不能把所有的数字都装入内存。</p>
<p>这里，采用基于二进制位比较 和 快速排序算法中的“分割思想”来寻找中位数。具体如下：</p>
<p>假设10亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制：1GB)，将每个数字用二进制表示，比较二进制的最高位(第32位)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。【这里的最高位类似于快速排序中的枢轴元素】</p>
<p>从而将10亿个数字分成了两个文件(几乎是二分的)，假设 file_0文件中有 6亿 个数字，file_1文件中有 4亿 个数字。那么中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 1亿 个数字。</p>
<p>【为什么呢？因为10亿个数字的中位数是10亿个数排序之后的第5亿个数。现在file_0有6亿个数，file_1有4亿个数，file_0中的数都比file_1中的数要大(最高位为符号位，file_1中的数都是负数，file_0中的数都是正数，也即这里一共只有4亿个负数，排序之后的第5亿个数一定是正数，那么排序之后的第5亿个数一定位于file_0中)】。除去4亿个负数，中位数就是6亿个正数从小到大排序之后 的第 1 亿个数。</p>
<p>现在，我们只需要处理 file_0 文件了(不需要再考虑file_1文件)。对于 file_0 文件，同样采取上面的措施处理：将file_0文件依次读一部分到内存(不超内存限制：1GB)，将每个数字用二进制表示，比较二进制的次高位(第31位)，如果数字的次高位为0，写入file_0_0文件中；如果次高位为1，写入file_0_1文件 中。</p>
<p>现假设 file_0_0文件中有3亿个数字，file_0_1中也有3亿个数字，则中位数就是：file_0_0文件中的数字从小到大排序之后的第1亿个数字。</p>
<p>抛弃file_0_1文件，继续对 file_0_0文件 根据 次次高位(第30位) 划分，假设此次划分的两个文件为：file_0_0_0中有0.5亿个数字，file_0_0_1中有2.5亿个数字，那么中位数就是 file_0_0_1文件中的所有数字排序之后的 第 0.5亿 个数。</p>
<p>……</p>
<p>按照上述思路，直到划分的文件可直接加载进内存时(比如划分的文件中只有5KW个数字了)，就可以直接对数字进行快速排序，找出中位数了。当然，你也使用“快排的分割算法”来找出中位数(比使用快速排序要快)</p>
<h3 id="海量数据处理-分而治之"><a href="#海量数据处理-分而治之" class="headerlink" title="海量数据处理 -分而治之"></a>海量数据处理 -分而治之</h3><p>对于海量数据而言，由于无法一次性装进内存处理，导致我们不得不把海量的数据通过hash映射分割成相应的小块数据，然后再针对各个小块数据通过hash_map 进行统计或者其他操作。</p>
<h4 id="海量日志数据，提取出某日访问百度次数最多的那个ip"><a href="#海量日志数据，提取出某日访问百度次数最多的那个ip" class="headerlink" title="海量日志数据，提取出某日访问百度次数最多的那个ip"></a>海量日志数据，提取出某日访问百度次数最多的那个ip</h4><p>解法：具体分为以下3个步骤</p>
<ul>
<li>1.分而治之/hash映射<ul>
<li>首先把这一天访问百度日志的所有IP提取出来，然后逐个写入到一个大文件中，接着采用映射的方法，比如%1000，把整个大文件映射为1000个小文件。</li>
</ul>
</li>
<li>2.hash_map统计<ul>
<li>当大文件转化成了小文件，那么我们便可以采用hash_map(ip, value)来分别对1000个小文件中的IP进行频率统计，再找出每个小文件中出现频率最大的IP。</li>
</ul>
</li>
<li>3.堆/快速排序<ul>
<li>统计出1000个频率最大的IP后，依据各自频率的大小进行排序(可采取堆排序)，找出那个频率最大的IP，即为所求。</li>
</ul>
</li>
</ul>
<p>注：Hash取模是一种等价映射，不会存在同一个元素分散到不同小文件中去的情况，即这里采用的是%1000算法，那么同一个IP在hash后，只可能落在同一个文件中，不可能被分散的。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/other/" rel="tag"># other</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/23/Redis/" rel="prev" title="Redis">
      <i class="fa fa-chevron-left"></i> Redis
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/24/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="next" title="Java多线程">
      Java多线程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">Java知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">Java基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#default%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.2.</span> <span class="nav-text">default关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java8-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.3.</span> <span class="nav-text">Java8 新特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.5.</span> <span class="nav-text">方法引用实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Final-Static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.6.</span> <span class="nav-text">Final Static关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#final"><span class="nav-number">1.6.1.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static"><span class="nav-number">1.6.2.</span> <span class="nav-text">static</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.7.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.7.1.</span> <span class="nav-text">成员内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.7.2.</span> <span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.7.3.</span> <span class="nav-text">匿名内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.7.4.</span> <span class="nav-text">静态内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="nav-number">1.8.</span> <span class="nav-text">容器类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equals-hashcode"><span class="nav-number">1.9.</span> <span class="nav-text">equals(),hashcode()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.10.</span> <span class="nav-text">抽象类与接口的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D"><span class="nav-number">1.11.</span> <span class="nav-text">数组在内存中如何分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.12.</span> <span class="nav-text">Java数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.12.1.</span> <span class="nav-text">树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-StringBuffer-StringBuilder"><span class="nav-number">1.13.</span> <span class="nav-text">String,StringBuffer,StringBuilder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.14.</span> <span class="nav-text">String创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="nav-number">1.15.</span> <span class="nav-text">方法重载与重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E5%92%8CSet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.16.</span> <span class="nav-text">List和Set的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collections-Collection-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.17.</span> <span class="nav-text">Collections Collection 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays-sort-%E5%92%8C-Collections-sort%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">1.18.</span> <span class="nav-text">Arrays.sort 和 Collections sort实现原理和区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-LinkList"><span class="nav-number">1.19.</span> <span class="nav-text">ArrayList LinkList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA%E5%8F%8D%E5%B0%84"><span class="nav-number">1.20.</span> <span class="nav-text">JAVA反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object%E7%B1%BB%E4%B8%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.21.</span> <span class="nav-text">Object类下方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.22.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">1.22.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">1.22.2.</span> <span class="nav-text">可达性分析算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="nav-number">1.22.3.</span> <span class="nav-text">如何将垃圾回收？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.23.</span> <span class="nav-text">注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.24.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OOM%E5%BC%82%E5%B8%B8"><span class="nav-number">1.25.</span> <span class="nav-text">OOM异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">1.26.</span> <span class="nav-text">内存溢出&#x2F;内存泄露</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="nav-number">2.</span> <span class="nav-text">Hash相关知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash%E5%86%B2%E7%AA%81"><span class="nav-number">2.1.</span> <span class="nav-text">Hash冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="nav-number">2.2.</span> <span class="nav-text">一致性哈希</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E5%9F%BA%E6%9C%AC"><span class="nav-number">2.3.</span> <span class="nav-text">HashMap基本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.</span> <span class="nav-text">HashMap线程安全问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E6%89%A9%E5%AE%B9"><span class="nav-number">2.5.</span> <span class="nav-text">HashMap扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hashtable-HashMap-ConcurrentHashMap"><span class="nav-number">2.6.</span> <span class="nav-text">Hashtable HashMap  ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">2.7.</span> <span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet"><span class="nav-number">2.8.</span> <span class="nav-text">HashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet-HashMap%E5%8C%BA%E5%88%AB"><span class="nav-number">2.9.</span> <span class="nav-text">HashSet HashMap区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">3.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM"><span class="nav-number">3.1.</span> <span class="nav-text">Java内存模型JMM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">Java 代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">4.1.</span> <span class="nav-text">静态代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">4.2.</span> <span class="nav-text">动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">4.2.1.</span> <span class="nav-text">Cglib动态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-Cglib%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.2.</span> <span class="nav-text">JDK Cglib区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">Java 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">5.1.</span> <span class="nav-text">乐观锁 悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81VS%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">5.2.</span> <span class="nav-text">自旋锁VS适应性自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E9%94%81VS%E5%81%8F%E5%90%91%E9%94%81VS%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81VS%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">5.3.</span> <span class="nav-text">无锁VS偏向锁VS轻量级锁VS重量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81-VS-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">5.4.</span> <span class="nav-text">公平锁 VS 非公平锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81VS%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">5.5.</span> <span class="nav-text">可重入锁VS非可重入锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E4%BA%AB%E9%94%81VS%E5%85%B1%E4%BA%AB%E9%94%81"><span class="nav-number">5.6.</span> <span class="nav-text">独享锁VS共享锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">5.7.</span> <span class="nav-text">分布式锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">Java进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">6.1.</span> <span class="nav-text">创建进程的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-wait"><span class="nav-number">6.2.</span> <span class="nav-text">线程间通信(wait)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sleep-Wait%E5%8C%BA%E5%88%AB"><span class="nav-number">6.3.</span> <span class="nav-text">Sleep Wait区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">6.4.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Volatile"><span class="nav-number">6.5.</span> <span class="nav-text">Volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized-%E5%85%B3%E9%94%AE%E5%AD%97-wait-notify"><span class="nav-number">6.6.</span> <span class="nav-text">Synchronized 关键字(wait notify)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized-Volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">6.7.</span> <span class="nav-text">Synchronized Volatile 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized-lock"><span class="nav-number">6.8.</span> <span class="nav-text">Synchronized lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E5%92%8Creentrantlock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.9.</span> <span class="nav-text">synchronized和reentrantlock的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition"><span class="nav-number">6.10.</span> <span class="nav-text">Condition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">6.11.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">6.12.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Runnable-Calllable%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.12.1.</span> <span class="nav-text">Runnable Calllable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Execute-submit"><span class="nav-number">6.12.2.</span> <span class="nav-text">Execute() submit()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">6.12.3.</span> <span class="nav-text">线程池的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0%EF%BC%88ThreadPoolExecutor%EF%BC%89"><span class="nav-number">6.12.4.</span> <span class="nav-text">线程池七大参数（ThreadPoolExecutor）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%96%E7%95%A5"><span class="nav-number">6.12.5.</span> <span class="nav-text">线程池策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Demo"><span class="nav-number">6.12.6.</span> <span class="nav-text">Demo</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor%E6%A1%86%E6%9E%B6"><span class="nav-number">6.13.</span> <span class="nav-text">Executor框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">6.14.</span> <span class="nav-text">Atomic 原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JUC%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">6.14.1.</span> <span class="nav-text">JUC包中的原子类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AtomicInteger-cas"><span class="nav-number">6.14.2.</span> <span class="nav-text">AtomicInteger(cas)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS"><span class="nav-number">6.15.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#state"><span class="nav-number">6.15.1.</span> <span class="nav-text">state</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CLH%E9%94%81%E9%98%9F%E5%88%97"><span class="nav-number">6.15.2.</span> <span class="nav-text">CLH锁队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS"><span class="nav-number">6.16.</span> <span class="nav-text">CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">6.17.</span> <span class="nav-text">join关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">6.18.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F%E5%86%8D%E7%BB%93%E6%9D%9F"><span class="nav-number">6.19.</span> <span class="nav-text">例题 主线程等待子线程结束再结束</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#join"><span class="nav-number">6.19.1.</span> <span class="nav-text">join</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch-1"><span class="nav-number">6.19.2.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">6.19.3.</span> <span class="nav-text">CyclicBarrier</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-Java%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E6%95%B0%E5%AD%97"><span class="nav-number">6.20.</span> <span class="nav-text">例题 Java多个线程顺序打印数字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8synchronized"><span class="nav-number">6.20.1.</span> <span class="nav-text">使用synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%85%8D%E4%B8%AAwait-notifyAll"><span class="nav-number">6.20.2.</span> <span class="nav-text">synchronized配个wait() notifyAll()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%89"><span class="nav-number">6.20.3.</span> <span class="nav-text">可重入锁（公平锁）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode%E4%B8%8A%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0"><span class="nav-number">6.21.</span> <span class="nav-text">Leetcode上按序打印</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized"><span class="nav-number">6.21.1.</span> <span class="nav-text">Synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%9F%E5%8A%A9%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%93%8D%E4%BD%9C"><span class="nav-number">6.21.2.</span> <span class="nav-text">借助原子类操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0FooBar"><span class="nav-number">6.22.</span> <span class="nav-text">多线程交替打印FooBar</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">6.22.1.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized"><span class="nav-number">6.22.2.</span> <span class="nav-text">synchronized</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-1"><span class="nav-number">7.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6"><span class="nav-number">7.1.</span> <span class="nav-text">条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.</span> <span class="nav-text">常用实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">7.3.</span> <span class="nav-text">关系型数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis"><span class="nav-number">7.4.</span> <span class="nav-text">Redis</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">8.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.1.</span> <span class="nav-text">七层模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%EF%BC%8C%E7%82%B9%E5%88%B0%E7%82%B9%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.2.</span> <span class="nav-text">端到端，点到点的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.3.</span> <span class="nav-text">GET和POST的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">8.4.</span> <span class="nav-text">HTTP常见状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E4%B8%8EHttps"><span class="nav-number">8.5.</span> <span class="nav-text">HTTP与Https</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="nav-number">8.5.1.</span> <span class="nav-text">TCP长连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%BC%98%E7%82%B9"><span class="nav-number">8.5.2.</span> <span class="nav-text">长连接短连接优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#https%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-number">8.6.</span> <span class="nav-text">https建立连接过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="nav-number">8.6.1.</span> <span class="nav-text">中间人攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AF%81%E6%98%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%B6%E5%88%B0%E7%9A%84%E5%85%AC%E9%92%A5%E4%B8%80%E5%AE%9A%E6%98%AF%E8%AF%A5%E7%BD%91%E7%AB%99%E7%9A%84%E5%85%AC%E9%92%A5%EF%BC%9F"><span class="nav-number">8.6.2.</span> <span class="nav-text">如何证明浏览器收到的公钥一定是该网站的公钥？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="nav-number">8.6.3.</span> <span class="nav-text">数字证书</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%94%BE%E9%98%B2%E6%AD%A2%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E8%A2%AB%E7%AF%A1%E6%94%B9%EF%BC%9F"><span class="nav-number">8.6.4.</span> <span class="nav-text">如何放防止数字证书被篡改？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="nav-number">8.6.5.</span> <span class="nav-text">数字签名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%9C%89%E5%8F%AF%E8%83%BD%E7%AF%A1%E6%94%B9%E8%AF%A5%E8%AF%81%E4%B9%A6%E5%90%97%EF%BC%9F"><span class="nav-number">8.6.6.</span> <span class="nav-text">中间人有可能篡改该证书吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%9C%89%E5%8F%AF%E8%83%BD%E6%8A%8A%E8%AF%81%E4%B9%A6%E6%8E%89%E5%8C%85%E5%90%97%EF%BC%9F"><span class="nav-number">8.6.7.</span> <span class="nav-text">中间人有可能把证书掉包吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%B6%E4%BD%9C%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E6%97%B6%E9%9C%80%E8%A6%81hash%E4%B8%80%E6%AC%A1%EF%BC%9F"><span class="nav-number">8.6.8.</span> <span class="nav-text">为什么制作数字签名时需要hash一次？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%AF%81%E6%98%8ECA%E6%9C%BA%E6%9E%84%E7%9A%84%E5%85%AC%E9%92%A5%E6%98%AF%E5%8F%AF%E4%BF%A1%E7%9A%84%EF%BC%9F"><span class="nav-number">8.6.9.</span> <span class="nav-text">怎么证明CA机构的公钥是可信的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS%E5%BF%85%E9%A1%BB%E5%9C%A8%E6%AF%8F%E6%AC%A1%E8%AF%B7%E6%B1%82%E4%B8%AD%E9%83%BD%E8%A6%81%E5%85%88%E5%9C%A8SSL-TLS%E5%B1%82%E8%BF%9B%E8%A1%8C%E6%8F%A1%E6%89%8B%E4%BC%A0%E8%BE%93%E5%AF%86%E9%92%A5%E5%90%97%EF%BC%9F"><span class="nav-number">8.6.10.</span> <span class="nav-text">HTTPS必须在每次请求中都要先在SSL&#x2F;TLS层进行握手传输密钥吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSL-TLS"><span class="nav-number">8.7.</span> <span class="nav-text">SSL TLS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD"><span class="nav-number">8.8.</span> <span class="nav-text">输入url到页面加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie-Session%E5%8C%BA%E5%88%AB"><span class="nav-number">8.9.</span> <span class="nav-text">Cookie,Session区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="nav-number">8.9.1.</span> <span class="nav-text">存储位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">8.9.2.</span> <span class="nav-text">存储的数据格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F"><span class="nav-number">8.9.3.</span> <span class="nav-text">存储的数据大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F"><span class="nav-number">8.9.4.</span> <span class="nav-text">声明周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%80%85%E8%81%94%E7%B3%BB"><span class="nav-number">8.9.5.</span> <span class="nav-text">二者联系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Token"><span class="nav-number">8.10.</span> <span class="nav-text">Token</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91%E9%87%8D%E5%AE%9A%E5%90%91%E5%8C%BA%E5%88%AB"><span class="nav-number">8.11.</span> <span class="nav-text">转发重定向区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91"><span class="nav-number">8.11.1.</span> <span class="nav-text">转发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">8.11.2.</span> <span class="nav-text">重定向</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Restful"><span class="nav-number">8.12.</span> <span class="nav-text">Restful</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RestFul-%E9%A3%8E%E6%A0%BC"><span class="nav-number">8.12.1.</span> <span class="nav-text">RestFul 风格</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-UDP%E5%8C%BA%E5%88%AB"><span class="nav-number">8.13.</span> <span class="nav-text">TCP UDP区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">8.13.1.</span> <span class="nav-text">TCP三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">8.13.2.</span> <span class="nav-text">tcp四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#time-wait%E7%8A%B6%E6%80%81"><span class="nav-number">8.13.3.</span> <span class="nav-text">time_wait状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8A%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81"><span class="nav-number">8.13.4.</span> <span class="nav-text">半关闭状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">8.13.5.</span> <span class="nav-text">TCP如何保证数据传输的可靠性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">8.13.6.</span> <span class="nav-text">粘包问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SYN-%E6%94%BB%E5%87%BB"><span class="nav-number">8.14.</span> <span class="nav-text">SYN 攻击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket"><span class="nav-number">8.15.</span> <span class="nav-text">socket</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">9.</span> <span class="nav-text">Mysql数据库知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="nav-number">9.1.</span> <span class="nav-text">数据库三大范式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">9.2.</span> <span class="nav-text">两种存储引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B"><span class="nav-number">9.3.</span> <span class="nav-text">查询流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E7%82%B9-ACID"><span class="nav-number">9.4.</span> <span class="nav-text">事务的特点 ACID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-number">9.5.</span> <span class="nav-text">事务的并发问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">9.6.</span> <span class="nav-text">事务隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%B4%E9%9A%99%E9%94%81"><span class="nav-number">9.7.</span> <span class="nav-text">间隙锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC"><span class="nav-number">9.8.</span> <span class="nav-text">MVCC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySql%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="nav-number">9.9.</span> <span class="nav-text">MySql如何解决幻读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="nav-number">9.9.1.</span> <span class="nav-text">串行化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC-%E5%BF%AB%E7%85%A7%E8%AF%BB-%E4%B8%80%E8%87%B4%E6%80%A7%E8%AF%BB"><span class="nav-number">9.9.2.</span> <span class="nav-text">MVCC(快照读&#x2F;一致性读)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E8%AF%BB"><span class="nav-number">9.9.3.</span> <span class="nav-text">实时读</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6%E4%B8%8EInnoDB%E9%94%81%E7%AE%97%E6%B3%95"><span class="nav-number">9.10.</span> <span class="nav-text">锁机制与InnoDB锁算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="nav-number">9.11.</span> <span class="nav-text">大表优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%A0%E5%8C%96%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-number">9.12.</span> <span class="nav-text">池化设计思想，数据库连接池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">9.13.</span> <span class="nav-text">mysql联合索引详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-explain"><span class="nav-number">9.14.</span> <span class="nav-text">慢查询优化 explain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="nav-number">9.15.</span> <span class="nav-text">倒排索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0%EF%BC%88B-B%E6%A0%91%EF%BC%89"><span class="nav-number">9.16.</span> <span class="nav-text">Mysql索引实现（B+ B树）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%AE%9A%E4%B9%89"><span class="nav-number">9.16.1.</span> <span class="nav-text">索引定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-number">9.16.2.</span> <span class="nav-text">哪些情况下索引会失效？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">9.16.3.</span> <span class="nav-text">在哪些地方适合创建索引？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">9.16.4.</span> <span class="nav-text">聚集索引 非聚集索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B%E6%A0%91"><span class="nav-number">9.16.5.</span> <span class="nav-text">B树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91"><span class="nav-number">9.16.6.</span> <span class="nav-text">为什么用B+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.16.7.</span> <span class="nav-text">B-树和B+树的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash%E7%B4%A2%E5%BC%95-b-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="nav-number">9.17.</span> <span class="nav-text">Hash索引 b+树索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">9.18.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">9.19.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">9.19.1.</span> <span class="nav-text">乐观锁和悲观锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Drop-Delete-Truncate"><span class="nav-number">9.20.</span> <span class="nav-text">Drop&#x2F;Delete&#x2F;Truncate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE-%E6%B8%B8%E6%A0%87"><span class="nav-number">9.21.</span> <span class="nav-text">视图 游标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redo%E6%97%A5%E5%BF%97"><span class="nav-number">9.22.</span> <span class="nav-text">Redo日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8ERedis%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.23.</span> <span class="nav-text">与Redis的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">10.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">10.1.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">10.1.1.</span> <span class="nav-text">内存管理机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E8%A1%A8%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">10.1.2.</span> <span class="nav-text">快表和多级页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%92%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80"><span class="nav-number">10.1.3.</span> <span class="nav-text">物理地址和虚拟地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E5%AF%BB%E5%9D%80"><span class="nav-number">10.1.4.</span> <span class="nav-text">CPU寻址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5"><span class="nav-number">10.2.</span> <span class="nav-text">分页和分段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">10.3.</span> <span class="nav-text">虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-number">10.3.1.</span> <span class="nav-text">局部性原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">10.3.2.</span> <span class="nav-text">页面置换算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">10.4.</span> <span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E4%BA%94%E7%A7%8D%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">10.4.1.</span> <span class="nav-text">进程间的五种通信方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">10.4.2.</span> <span class="nav-text">进程调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">10.4.3.</span> <span class="nav-text">进程的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">10.4.4.</span> <span class="nav-text">僵尸进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">10.4.5.</span> <span class="nav-text">线程的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">10.4.6.</span> <span class="nav-text">进程的同步方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">10.4.7.</span> <span class="nav-text">线程同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">10.4.8.</span> <span class="nav-text">多线程中的上下文切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">10.4.9.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">10.4.10.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">10.4.11.</span> <span class="nav-text">IO多路复用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-number">10.5.</span> <span class="nav-text">用户态内核态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9C%80%E8%A6%81%E4%B8%A4%E7%A7%8DCPU%E7%8A%B6%E6%80%81"><span class="nav-number">10.5.1.</span> <span class="nav-text">操作系统需要两种CPU状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%88%92%E5%88%86"><span class="nav-number">10.5.2.</span> <span class="nav-text">指令划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%9D%83%E7%BA%A7%E5%88%AB"><span class="nav-number">10.5.3.</span> <span class="nav-text">特权级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">10.5.4.</span> <span class="nav-text">CPU状态之间的转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.5.5.</span> <span class="nav-text">内核态与用户态的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">10.6.</span> <span class="nav-text">读写文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-number">10.6.1.</span> <span class="nav-text">读文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">10.6.2.</span> <span class="nav-text">写文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-number">10.7.</span> <span class="nav-text">操作系统中断和异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">10.7.1.</span> <span class="nav-text">中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">10.7.2.</span> <span class="nav-text">异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8C%BA%E5%88%86"><span class="nav-number">10.8.</span> <span class="nav-text">中断和异常的区分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-select-poll"><span class="nav-number">10.9.</span> <span class="nav-text">epoll select poll</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">11.</span> <span class="nav-text">面向对象思想的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">11.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">11.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">11.3.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">12.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RestController-Controller"><span class="nav-number">12.1.</span> <span class="nav-text">@RestController @Controller</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringIoc"><span class="nav-number">12.2.</span> <span class="nav-text">SpringIoc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP"><span class="nav-number">12.3.</span> <span class="nav-text">AOP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Bean"><span class="nav-number">12.4.</span> <span class="nav-text">Spring Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="nav-number">12.4.1.</span> <span class="nav-text">创建流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">12.4.2.</span> <span class="nav-text">生命周期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-number">12.5.</span> <span class="nav-text">循环依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%9D%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E2%80%9C"><span class="nav-number">12.5.1.</span> <span class="nav-text">”三级缓存“</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="nav-number">12.5.2.</span> <span class="nav-text">流程总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Component"><span class="nav-number">12.6.</span> <span class="nav-text">@Component</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">12.7.</span> <span class="nav-text">Spring框架中设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1"><span class="nav-number">12.8.</span> <span class="nav-text">Spring事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">12.8.1.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">12.8.2.</span> <span class="nav-text">配置方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="nav-number">12.8.3.</span> <span class="nav-text">传播机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">12.8.4.</span> <span class="nav-text">隔离级别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transactional-rollbackFor-Exception-class"><span class="nav-number">12.9.</span> <span class="nav-text">Transactional(rollbackFor&#x3D;Exception.class)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="nav-number">12.10.</span> <span class="nav-text">一些常用的注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#http%E8%AF%B7%E6%B1%82"><span class="nav-number">12.10.1.</span> <span class="nav-text">http请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E5%80%BC"><span class="nav-number">12.10.2.</span> <span class="nav-text">前后端传值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="nav-number">12.10.3.</span> <span class="nav-text">读取配置信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mybatis"><span class="nav-number">13.</span> <span class="nav-text">Mybatis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">13.1.</span> <span class="nav-text">#{}和${}的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%96%B9%E5%BC%8F"><span class="nav-number">13.2.</span> <span class="nav-text">分页方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%A0%87%E7%AD%BE"><span class="nav-number">13.3.</span> <span class="nav-text">常见标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dao-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">13.4.</span> <span class="nav-text">Dao 接口的工作原理是什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB%E4%BB%A5%E5%8F%8A%E9%80%89%E6%8B%A9"><span class="nav-number">14.</span> <span class="nav-text">IO流的分类以及选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">15.</span> <span class="nav-text">序列化和反序列化的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#serialVersionUID"><span class="nav-number">15.1.</span> <span class="nav-text">serialVersionUID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="nav-number">16.</span> <span class="nav-text">Java的异常体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">17.</span> <span class="nav-text">类加载机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="nav-number">18.</span> <span class="nav-text">三层架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVC"><span class="nav-number">19.</span> <span class="nav-text">MVC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C"><span class="nav-number">20.</span> <span class="nav-text">并发并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">21.</span> <span class="nav-text">堆和栈的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">22.</span> <span class="nav-text">排序算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux"><span class="nav-number">23.</span> <span class="nav-text">linux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%A2%AB%E5%93%AA%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8"><span class="nav-number">23.1.</span> <span class="nav-text">Linux 查看端口号被哪个进程占用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="nav-number">23.2.</span> <span class="nav-text">查看日志文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E5%87%BA%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AE%BF%E9%97%AE%E9%87%8F%E6%9C%80%E5%A4%A7%E7%9A%84top10-ip%E5%9C%B0%E5%9D%80"><span class="nav-number">23.3.</span> <span class="nav-text">找出日志文件中访问量最大的top10 ip地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select%E5%92%8Cepoll%E5%8C%BA%E5%88%AB"><span class="nav-number">24.</span> <span class="nav-text">select和epoll区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">25.</span> <span class="nav-text">CPU调度算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="nav-number">26.</span> <span class="nav-text">场景题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8ip%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E5%A5%BD"><span class="nav-number">26.1.</span> <span class="nav-text">存储ip地址，用什么数据类型比较好</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#100%E4%BA%BF%E4%B8%AA%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%84100%E4%B8%AA"><span class="nav-number">26.2.</span> <span class="nav-text">100亿个数据中找出最大的100个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E6%9D%A1%E6%9C%BA%E5%99%A8%E6%AF%8F%E5%8F%B0%E5%AD%98%E5%82%A8%E7%9D%80%E5%87%A0%E4%BA%BF%E6%9D%A1%E6%90%9C%E7%B4%A2%E6%97%A5%E5%BF%97%EF%BC%8C%E5%8F%AA%E6%9C%89%E4%B8%80%E5%8F%B02G%E7%9A%84%E7%94%B5%E8%84%91%EF%BC%8C%E6%80%8E%E4%B9%88%E9%80%89%E5%87%BA%E6%90%9C%E7%B4%A2%E7%83%AD%E5%BA%A6%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%81%E4%B8%AA%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="nav-number">26.3.</span> <span class="nav-text">几条机器每台存储着几亿条搜索日志，只有一台2G的电脑，怎么选出搜索热度最高的十个搜索关键词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%89%BE%E5%87%BA%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">26.4.</span> <span class="nav-text">从海量数据中找出中位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="nav-number">26.5.</span> <span class="nav-text">海量数据处理 -分而治之</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%8F%90%E5%8F%96%E5%87%BA%E6%9F%90%E6%97%A5%E8%AE%BF%E9%97%AE%E7%99%BE%E5%BA%A6%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E9%82%A3%E4%B8%AAip"><span class="nav-number">26.5.1.</span> <span class="nav-text">海量日志数据，提取出某日访问百度次数最多的那个ip</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yang</p>
  <div class="site-description" itemprop="description">醉后不知天在水，满船星梦压星河</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/youngbuss" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;youngbuss" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yanghy@bupt.edu.cn" title="E-Mail → mailto:yanghy@bupt.edu.cn" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020-9 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yang</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
